<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>librsb: The Sparse BLAS interface to librsb (blas_sparse.h, rsb_blas_sparse.F90)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">librsb
   &#160;<span id="projectnumber">1.3.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">The Sparse BLAS interface to librsb (blas_sparse.h, rsb_blas_sparse.F90)</div>  </div>
</div><!--header-->
<div class="contents">

<p>A Sparse BLAS interface (see <a href="http://www.netlib.org/blas/blast-forum/">http://www.netlib.org/blas/blast-forum/</a>) to <code>librsb</code>. Level 1 (vector-vector operations) is supported in a basic way. Level 2 (sparse matrix-dense vector operations) is supported fully. Level 3 (sparse matrix-dense matrix operations) is supported as a wrapper around Level 2.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1f4e5a89c4961c95c4d4267b86540643"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga1f4e5a89c4961c95c4d4267b86540643">BLAS_susdot</a> (const enum <a class="el" href="blas__sparse_8h.html#a125c156d54359fba48a6b9cf2a2d0a07">blas_conj_type</a> conj, const int nnz, const float *x, const int *indx, const float *y, const int incy, float *r, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> index_base)</td></tr>
<tr class="separator:ga1f4e5a89c4961c95c4d4267b86540643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93ef5ce40255281ae251ab5675cbbc00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga93ef5ce40255281ae251ab5675cbbc00">blas_susdot_</a> (const enum <a class="el" href="blas__sparse_8h.html#a125c156d54359fba48a6b9cf2a2d0a07">blas_conj_type</a> *conj, const int *nnz, const float *x, const int *indx, const float *y, const int *incy, float *r, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *index_base, int *istat)</td></tr>
<tr class="separator:ga93ef5ce40255281ae251ab5675cbbc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b636bea0fc01655c2e61cc83df49875"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga2b636bea0fc01655c2e61cc83df49875">BLAS_dusdot</a> (const enum <a class="el" href="blas__sparse_8h.html#a125c156d54359fba48a6b9cf2a2d0a07">blas_conj_type</a> conj, const int nnz, const double *x, const int *indx, const double *y, const int incy, double *r, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> index_base)</td></tr>
<tr class="separator:ga2b636bea0fc01655c2e61cc83df49875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6af9e342a35e6b3a626da8abadf4d1bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga6af9e342a35e6b3a626da8abadf4d1bb">blas_dusdot_</a> (const enum <a class="el" href="blas__sparse_8h.html#a125c156d54359fba48a6b9cf2a2d0a07">blas_conj_type</a> *conj, const int *nnz, const double *x, const int *indx, const double *y, const int *incy, double *r, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *index_base, int *istat)</td></tr>
<tr class="separator:ga6af9e342a35e6b3a626da8abadf4d1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c01ce25e9923b35fc74edfdc269ddf9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga4c01ce25e9923b35fc74edfdc269ddf9">BLAS_cusdot</a> (const enum <a class="el" href="blas__sparse_8h.html#a125c156d54359fba48a6b9cf2a2d0a07">blas_conj_type</a> conj, const int nnz, const void *x, const int *indx, const void *y, const int incy, void *r, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> index_base)</td></tr>
<tr class="separator:ga4c01ce25e9923b35fc74edfdc269ddf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10fc0f80f4e51078636cd5173510c3b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga10fc0f80f4e51078636cd5173510c3b9">blas_cusdot_</a> (const enum <a class="el" href="blas__sparse_8h.html#a125c156d54359fba48a6b9cf2a2d0a07">blas_conj_type</a> *conj, const int *nnz, const void *x, const int *indx, const void *y, const int *incy, void *r, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *index_base, int *istat)</td></tr>
<tr class="separator:ga10fc0f80f4e51078636cd5173510c3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga205c79d7338c077fc229f9079212efce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga205c79d7338c077fc229f9079212efce">BLAS_zusdot</a> (const enum <a class="el" href="blas__sparse_8h.html#a125c156d54359fba48a6b9cf2a2d0a07">blas_conj_type</a> conj, const int nnz, const void *x, const int *indx, const void *y, const int incy, void *r, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> index_base)</td></tr>
<tr class="separator:ga205c79d7338c077fc229f9079212efce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4b5dcd77e8ef3876dac25ddea14fde5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gab4b5dcd77e8ef3876dac25ddea14fde5">blas_zusdot_</a> (const enum <a class="el" href="blas__sparse_8h.html#a125c156d54359fba48a6b9cf2a2d0a07">blas_conj_type</a> *conj, const int *nnz, const void *x, const int *indx, const void *y, const int *incy, void *r, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *index_base, int *istat)</td></tr>
<tr class="separator:gab4b5dcd77e8ef3876dac25ddea14fde5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58dd46bdc43875a6e77975d29dc3f02c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga58dd46bdc43875a6e77975d29dc3f02c">BLAS_susaxpy</a> (const int nnz, float alpha, const float *x, const int *indx, float *y, const int incy, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> index_base)</td></tr>
<tr class="separator:ga58dd46bdc43875a6e77975d29dc3f02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54ab59491084aa891fa686b6fc411cc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga54ab59491084aa891fa686b6fc411cc3">blas_susaxpy_</a> (const int *nnz, float *alpha, const float *x, const int *indx, float *y, const int *incy, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *index_base, int *istat)</td></tr>
<tr class="separator:ga54ab59491084aa891fa686b6fc411cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad881a3b5aaa54c05badefa59d9a46ca3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gad881a3b5aaa54c05badefa59d9a46ca3">BLAS_dusaxpy</a> (const int nnz, double alpha, const double *x, const int *indx, double *y, const int incy, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> index_base)</td></tr>
<tr class="separator:gad881a3b5aaa54c05badefa59d9a46ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1745b7ce9014a8d32a6d954d6ce3bd87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga1745b7ce9014a8d32a6d954d6ce3bd87">blas_dusaxpy_</a> (const int *nnz, double *alpha, const double *x, const int *indx, double *y, const int *incy, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *index_base, int *istat)</td></tr>
<tr class="separator:ga1745b7ce9014a8d32a6d954d6ce3bd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9512ccca0297deb504ef8a9c15eb32cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga9512ccca0297deb504ef8a9c15eb32cf">BLAS_cusaxpy</a> (const int nnz, const void *alpha, const void *x, const int *indx, void *y, const int incy, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> index_base)</td></tr>
<tr class="separator:ga9512ccca0297deb504ef8a9c15eb32cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbe35bc39022ca809f84f65982e8e40f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gadbe35bc39022ca809f84f65982e8e40f">blas_cusaxpy_</a> (const int *nnz, const void *alpha, const void *x, const int *indx, void *y, const int *incy, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *index_base, int *istat)</td></tr>
<tr class="separator:gadbe35bc39022ca809f84f65982e8e40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7973eedf292007ad12b1844b9b6a1fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gaa7973eedf292007ad12b1844b9b6a1fc">BLAS_zusaxpy</a> (const int nnz, const void *alpha, const void *x, const int *indx, void *y, const int incy, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> index_base)</td></tr>
<tr class="separator:gaa7973eedf292007ad12b1844b9b6a1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac310682d723e36eace264d745eb8b3d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gac310682d723e36eace264d745eb8b3d4">blas_zusaxpy_</a> (const int *nnz, const void *alpha, const void *x, const int *indx, void *y, const int *incy, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *index_base, int *istat)</td></tr>
<tr class="separator:gac310682d723e36eace264d745eb8b3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae54815138a8c6d7c2db81a9b8207d44f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gae54815138a8c6d7c2db81a9b8207d44f">BLAS_susga</a> (const int nnz, const float *y, const int incy, float *x, const int *indx, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> index_base)</td></tr>
<tr class="separator:gae54815138a8c6d7c2db81a9b8207d44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cfcf31ed26b3e9950d55a34d3c6ff61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga1cfcf31ed26b3e9950d55a34d3c6ff61">blas_susga_</a> (const int *nnz, const float *y, const int *incy, float *x, const int *indx, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *index_base, int *istat)</td></tr>
<tr class="separator:ga1cfcf31ed26b3e9950d55a34d3c6ff61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fe2f6377727c483e79fc81cc40d0c9c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga3fe2f6377727c483e79fc81cc40d0c9c">BLAS_dusga</a> (const int nnz, const double *y, const int incy, double *x, const int *indx, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> index_base)</td></tr>
<tr class="separator:ga3fe2f6377727c483e79fc81cc40d0c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9abd75bb1658d5e400aa15346af9a67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gad9abd75bb1658d5e400aa15346af9a67">blas_dusga_</a> (const int *nnz, const double *y, const int *incy, double *x, const int *indx, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *index_base, int *istat)</td></tr>
<tr class="separator:gad9abd75bb1658d5e400aa15346af9a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1aa846da09f16b6dd746b7d70dfe0db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gaf1aa846da09f16b6dd746b7d70dfe0db">BLAS_cusga</a> (const int nnz, const void *y, const int incy, void *x, const int *indx, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> index_base)</td></tr>
<tr class="separator:gaf1aa846da09f16b6dd746b7d70dfe0db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3232dc3a0844f917f4f6041990711bea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga3232dc3a0844f917f4f6041990711bea">blas_cusga_</a> (const int *nnz, const void *y, const int *incy, void *x, const int *indx, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *index_base, int *istat)</td></tr>
<tr class="separator:ga3232dc3a0844f917f4f6041990711bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55e6cbfb486c6ebcc7a14cf637587763"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga55e6cbfb486c6ebcc7a14cf637587763">BLAS_zusga</a> (const int nnz, const void *y, const int incy, void *x, const int *indx, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> index_base)</td></tr>
<tr class="separator:ga55e6cbfb486c6ebcc7a14cf637587763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f7d5d7d6afbf3cc11625c4f3c886605"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga6f7d5d7d6afbf3cc11625c4f3c886605">blas_zusga_</a> (const int *nnz, const void *y, const int *incy, void *x, const int *indx, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *index_base, int *istat)</td></tr>
<tr class="separator:ga6f7d5d7d6afbf3cc11625c4f3c886605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga619fd446d5319f1fb864d76a9916954c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga619fd446d5319f1fb864d76a9916954c">BLAS_susgz</a> (const int nnz, float *y, const int incy, float *x, const int *indx, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> index_base)</td></tr>
<tr class="separator:ga619fd446d5319f1fb864d76a9916954c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ab1864a44b0cde9740b7009892cc8ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga7ab1864a44b0cde9740b7009892cc8ca">blas_susgz_</a> (const int *nnz, float *y, const int *incy, float *x, const int *indx, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *index_base, int *istat)</td></tr>
<tr class="separator:ga7ab1864a44b0cde9740b7009892cc8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacce24efbb85dacafbce4a726ec1e3a55"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gacce24efbb85dacafbce4a726ec1e3a55">BLAS_dusgz</a> (const int nnz, double *y, const int incy, double *x, const int *indx, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> index_base)</td></tr>
<tr class="separator:gacce24efbb85dacafbce4a726ec1e3a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e8dee47e7855a130b6896b020209b5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga2e8dee47e7855a130b6896b020209b5e">blas_dusgz_</a> (const int *nnz, double *y, const int *incy, double *x, const int *indx, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *index_base, int *istat)</td></tr>
<tr class="separator:ga2e8dee47e7855a130b6896b020209b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffdbf96c998c35f21a97d017614789a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gaffdbf96c998c35f21a97d017614789a6">BLAS_cusgz</a> (const int nnz, void *y, const int incy, void *x, const int *indx, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> index_base)</td></tr>
<tr class="separator:gaffdbf96c998c35f21a97d017614789a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac47b026c7bde968785c5d0e559fa086d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gac47b026c7bde968785c5d0e559fa086d">blas_cusgz_</a> (const int *nnz, void *y, const int *incy, void *x, const int *indx, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *index_base, int *istat)</td></tr>
<tr class="separator:gac47b026c7bde968785c5d0e559fa086d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67e660789cd15fac6bd2be6977cc2aba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga67e660789cd15fac6bd2be6977cc2aba">BLAS_zusgz</a> (const int nnz, void *y, const int incy, void *x, const int *indx, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> index_base)</td></tr>
<tr class="separator:ga67e660789cd15fac6bd2be6977cc2aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c68bde8c3dd1357ab033ae4982a5eec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga7c68bde8c3dd1357ab033ae4982a5eec">blas_zusgz_</a> (const int *nnz, void *y, const int *incy, void *x, const int *indx, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *index_base, int *istat)</td></tr>
<tr class="separator:ga7c68bde8c3dd1357ab033ae4982a5eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga628897ca7d06ad80f85dc73560979d0d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga628897ca7d06ad80f85dc73560979d0d">BLAS_sussc</a> (const int nnz, const float *x, float *y, const int incy, const int *indx, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> index_base)</td></tr>
<tr class="separator:ga628897ca7d06ad80f85dc73560979d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf25a3761107bfaefcceb78a4317cfb47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gaf25a3761107bfaefcceb78a4317cfb47">blas_sussc_</a> (const int *nnz, const float *x, float *y, const int *incy, const int *indx, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *index_base, int *istat)</td></tr>
<tr class="separator:gaf25a3761107bfaefcceb78a4317cfb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1176f6368b5a5d44ced6fbd2bf19084a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga1176f6368b5a5d44ced6fbd2bf19084a">BLAS_dussc</a> (const int nnz, const double *x, double *y, const int incy, const int *indx, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> index_base)</td></tr>
<tr class="separator:ga1176f6368b5a5d44ced6fbd2bf19084a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43e60ab2bba8fc57b8cc63922e1dbf6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga43e60ab2bba8fc57b8cc63922e1dbf6c">blas_dussc_</a> (const int *nnz, const double *x, double *y, const int *incy, const int *indx, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *index_base, int *istat)</td></tr>
<tr class="separator:ga43e60ab2bba8fc57b8cc63922e1dbf6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41151f3f32daa645aa1ca4781aa19638"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga41151f3f32daa645aa1ca4781aa19638">BLAS_cussc</a> (const int nnz, const void *x, void *y, const int incy, const int *indx, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> index_base)</td></tr>
<tr class="separator:ga41151f3f32daa645aa1ca4781aa19638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cab66955c8629f868c50218afb29ee4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga3cab66955c8629f868c50218afb29ee4">blas_cussc_</a> (const int *nnz, const void *x, void *y, const int *incy, const int *indx, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *index_base, int *istat)</td></tr>
<tr class="separator:ga3cab66955c8629f868c50218afb29ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d95d007f1dc092eab6126e606b70423"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga5d95d007f1dc092eab6126e606b70423">BLAS_zussc</a> (const int nnz, const void *x, void *y, const int incy, const int *indx, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> index_base)</td></tr>
<tr class="separator:ga5d95d007f1dc092eab6126e606b70423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f6ec9614871760de418e56e3529c281"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga6f6ec9614871760de418e56e3529c281">blas_zussc_</a> (const int *nnz, const void *x, void *y, const int *incy, const int *indx, const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *index_base, int *istat)</td></tr>
<tr class="separator:ga6f6ec9614871760de418e56e3529c281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8193efe99bd255f8fcc4d72213c02d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gaf8193efe99bd255f8fcc4d72213c02d3">BLAS_susmv</a> (const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> transA, float alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const float *x, const int incx, float *y, const int incy)</td></tr>
<tr class="separator:gaf8193efe99bd255f8fcc4d72213c02d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae39adcc0126a57ae93a3a312a82d51ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gae39adcc0126a57ae93a3a312a82d51ee">blas_susmv_</a> (const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *transA, float *alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const float *x, const int *incx, float *y, const int *incy, int *istat)</td></tr>
<tr class="separator:gae39adcc0126a57ae93a3a312a82d51ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad018cf218c2c938bb5cf4577f1b53319"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gad018cf218c2c938bb5cf4577f1b53319">BLAS_dusmv</a> (const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> transA, double alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const double *x, const int incx, double *y, const int incy)</td></tr>
<tr class="separator:gad018cf218c2c938bb5cf4577f1b53319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c0ef8d9871085fa78215c5bef419b85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga1c0ef8d9871085fa78215c5bef419b85">blas_dusmv_</a> (const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *transA, double *alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const double *x, const int *incx, double *y, const int *incy, int *istat)</td></tr>
<tr class="separator:ga1c0ef8d9871085fa78215c5bef419b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd371d9e8ab736cd4bd5e46973152bb5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gacd371d9e8ab736cd4bd5e46973152bb5">BLAS_cusmv</a> (const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> transA, const void *alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const void *x, const int incx, void *y, const int incy)</td></tr>
<tr class="separator:gacd371d9e8ab736cd4bd5e46973152bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7afc7a25cf8d4291b7821b5c3a6c16f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga7afc7a25cf8d4291b7821b5c3a6c16f8">blas_cusmv_</a> (const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *transA, const void *alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const void *x, const int *incx, void *y, const int *incy, int *istat)</td></tr>
<tr class="separator:ga7afc7a25cf8d4291b7821b5c3a6c16f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba57464d66e3f29bc3177d480b0b6a54"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gaba57464d66e3f29bc3177d480b0b6a54">BLAS_zusmv</a> (const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> transA, const void *alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const void *x, const int incx, void *y, const int incy)</td></tr>
<tr class="separator:gaba57464d66e3f29bc3177d480b0b6a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01239a7a368b66a4b3802b89b98e6054"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga01239a7a368b66a4b3802b89b98e6054">blas_zusmv_</a> (const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *transA, const void *alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const void *x, const int *incx, void *y, const int *incy, int *istat)</td></tr>
<tr class="separator:ga01239a7a368b66a4b3802b89b98e6054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1227ee6871331ef29910b8fa4969e76a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga1227ee6871331ef29910b8fa4969e76a">BLAS_sussv</a> (enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> transT, float alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> T, float *x, const int incx)</td></tr>
<tr class="separator:ga1227ee6871331ef29910b8fa4969e76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94ffcec367e74167ae2dbbc2ac47a5a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga94ffcec367e74167ae2dbbc2ac47a5a3">blas_sussv_</a> (enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *transT, float *alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *T, float *x, const int *incx, int *istat)</td></tr>
<tr class="separator:ga94ffcec367e74167ae2dbbc2ac47a5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga017a5e4ea8e2f5c046dc720c1927ac0d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga017a5e4ea8e2f5c046dc720c1927ac0d">BLAS_dussv</a> (enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> transT, double alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> T, double *x, const int incx)</td></tr>
<tr class="separator:ga017a5e4ea8e2f5c046dc720c1927ac0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga278c886eeedfd80922c9d498d77cecc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga278c886eeedfd80922c9d498d77cecc4">blas_dussv_</a> (enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *transT, double *alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *T, double *x, const int *incx, int *istat)</td></tr>
<tr class="separator:ga278c886eeedfd80922c9d498d77cecc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d075495d355608bff64aa5802789266"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga6d075495d355608bff64aa5802789266">BLAS_cussv</a> (enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> transT, const void *alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> T, void *x, const int incx)</td></tr>
<tr class="separator:ga6d075495d355608bff64aa5802789266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc0c4d042a0b07a7e743ad09e593b7e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gabc0c4d042a0b07a7e743ad09e593b7e9">blas_cussv_</a> (enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *transT, const void *alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *T, void *x, const int *incx, int *istat)</td></tr>
<tr class="separator:gabc0c4d042a0b07a7e743ad09e593b7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga527f71f83a92aed1698c0f754caea84a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga527f71f83a92aed1698c0f754caea84a">BLAS_zussv</a> (enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> transT, const void *alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> T, void *x, const int incx)</td></tr>
<tr class="separator:ga527f71f83a92aed1698c0f754caea84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28cdd020e7f028658d63d03990135dc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga28cdd020e7f028658d63d03990135dc9">blas_zussv_</a> (enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *transT, const void *alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *T, void *x, const int *incx, int *istat)</td></tr>
<tr class="separator:ga28cdd020e7f028658d63d03990135dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacadd9208ad4a6a8d4ceab32ee173c6f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gacadd9208ad4a6a8d4ceab32ee173c6f4">BLAS_susmm</a> (const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a> order, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> transA, const int nrhs, float alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const float *b, const int ldb, float *c, const int ldc)</td></tr>
<tr class="separator:gacadd9208ad4a6a8d4ceab32ee173c6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43580b6e51c5d8f1e8f8fba0983e3f8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga43580b6e51c5d8f1e8f8fba0983e3f8f">blas_susmm_</a> (const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a> *order, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *transA, const int *nrhs, float *alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const float *b, const int *ldb, float *c, const int *ldc, int *istat)</td></tr>
<tr class="separator:ga43580b6e51c5d8f1e8f8fba0983e3f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16a77093831bc32ccc056258d6f93445"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga16a77093831bc32ccc056258d6f93445">BLAS_dusmm</a> (const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a> order, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> transA, const int nrhs, double alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const double *b, const int ldb, double *c, const int ldc)</td></tr>
<tr class="separator:ga16a77093831bc32ccc056258d6f93445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6399d807d81b53aca98fa6041d42b120"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga6399d807d81b53aca98fa6041d42b120">blas_dusmm_</a> (const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a> *order, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *transA, const int *nrhs, double *alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const double *b, const int *ldb, double *c, const int *ldc, int *istat)</td></tr>
<tr class="separator:ga6399d807d81b53aca98fa6041d42b120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9a587087965874604ce9785f8660664"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gae9a587087965874604ce9785f8660664">BLAS_cusmm</a> (const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a> order, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> transA, const int nrhs, const void *alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const void *b, const int ldb, void *c, const int ldc)</td></tr>
<tr class="separator:gae9a587087965874604ce9785f8660664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf359397dc85638f05255539befeda69c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gaf359397dc85638f05255539befeda69c">blas_cusmm_</a> (const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a> *order, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *transA, const int *nrhs, const void *alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const void *b, const int *ldb, void *c, const int *ldc, int *istat)</td></tr>
<tr class="separator:gaf359397dc85638f05255539befeda69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d81f70e1fb15c3912006ed71a5cd471"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga1d81f70e1fb15c3912006ed71a5cd471">BLAS_zusmm</a> (const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a> order, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> transA, const int nrhs, const void *alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const void *b, const int ldb, void *c, const int ldc)</td></tr>
<tr class="separator:ga1d81f70e1fb15c3912006ed71a5cd471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga099df6bc63ed6a0c2bf387992b58e151"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga099df6bc63ed6a0c2bf387992b58e151">blas_zusmm_</a> (const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a> *order, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *transA, const int *nrhs, const void *alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const void *b, const int *ldb, void *c, const int *ldc, int *istat)</td></tr>
<tr class="separator:ga099df6bc63ed6a0c2bf387992b58e151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ee5de90a2a5f7c31d916bac83e11c0e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga6ee5de90a2a5f7c31d916bac83e11c0e">BLAS_sussm</a> (const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a> order, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> transT, const int nrhs, float alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> T, float *b, const int ldb)</td></tr>
<tr class="separator:ga6ee5de90a2a5f7c31d916bac83e11c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2485bec02ae7bfb424a328f569951d06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga2485bec02ae7bfb424a328f569951d06">blas_sussm_</a> (const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a> *order, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *transT, const int *nrhs, float *alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *T, float *b, const int *ldb, int *istat)</td></tr>
<tr class="separator:ga2485bec02ae7bfb424a328f569951d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74e20c9ec236425337b84086f3d5573b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga74e20c9ec236425337b84086f3d5573b">BLAS_dussm</a> (const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a> order, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> transT, const int nrhs, double alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> T, double *b, const int ldb)</td></tr>
<tr class="separator:ga74e20c9ec236425337b84086f3d5573b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga947b8c225bc826c966fff2fa7c1306c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga947b8c225bc826c966fff2fa7c1306c4">blas_dussm_</a> (const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a> *order, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *transT, const int *nrhs, double *alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *T, double *b, const int *ldb, int *istat)</td></tr>
<tr class="separator:ga947b8c225bc826c966fff2fa7c1306c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4400d79fb5c85fdbcbc652a20f7cdc3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gaa4400d79fb5c85fdbcbc652a20f7cdc3">BLAS_cussm</a> (const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a> order, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> transT, const int nrhs, const void *alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> T, void *b, const int ldb)</td></tr>
<tr class="separator:gaa4400d79fb5c85fdbcbc652a20f7cdc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc0e3e469d5c619582251d0bab7c072d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gadc0e3e469d5c619582251d0bab7c072d">blas_cussm_</a> (const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a> *order, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *transT, const int *nrhs, const void *alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *T, void *b, const int *ldb, int *istat)</td></tr>
<tr class="separator:gadc0e3e469d5c619582251d0bab7c072d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9c025e498f8ef44437bdc97b494005c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gac9c025e498f8ef44437bdc97b494005c">BLAS_zussm</a> (const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a> order, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> transT, const int nrhs, const void *alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> T, void *b, const int ldb)</td></tr>
<tr class="separator:gac9c025e498f8ef44437bdc97b494005c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a9b737504223977a5c6093b1424fb64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga4a9b737504223977a5c6093b1424fb64">blas_zussm_</a> (const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a> *order, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *transT, const int *nrhs, const void *alpha, const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *T, void *b, const int *ldb, int *istat)</td></tr>
<tr class="separator:ga4a9b737504223977a5c6093b1424fb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9fe50c2e7a26e6ef83dfd3ea4cfcdd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gad9fe50c2e7a26e6ef83dfd3ea4cfcdd5">BLAS_suscr_begin</a> (int m, int n)</td></tr>
<tr class="separator:gad9fe50c2e7a26e6ef83dfd3ea4cfcdd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2f7ede753754c2474d5460a92bba99e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gad2f7ede753754c2474d5460a92bba99e">blas_suscr_begin_</a> (int *m, int *n, <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *istat)</td></tr>
<tr class="separator:gad2f7ede753754c2474d5460a92bba99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac931dcb1129ee3016ab82602c3d14fee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gac931dcb1129ee3016ab82602c3d14fee">BLAS_duscr_begin</a> (int m, int n)</td></tr>
<tr class="separator:gac931dcb1129ee3016ab82602c3d14fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7d5969e9edee49441fc89d22715e60d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gad7d5969e9edee49441fc89d22715e60d">blas_duscr_begin_</a> (int *m, int *n, <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *istat)</td></tr>
<tr class="separator:gad7d5969e9edee49441fc89d22715e60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3483c364b4afec22621e46059b166247"><td class="memItemLeft" align="right" valign="top"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga3483c364b4afec22621e46059b166247">BLAS_cuscr_begin</a> (int m, int n)</td></tr>
<tr class="separator:ga3483c364b4afec22621e46059b166247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4d21720c592de22cfd4139517d9d255"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gaf4d21720c592de22cfd4139517d9d255">blas_cuscr_begin_</a> (int *m, int *n, <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *istat)</td></tr>
<tr class="separator:gaf4d21720c592de22cfd4139517d9d255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52b67393ad16e3d40e74fcdba88c7da4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga52b67393ad16e3d40e74fcdba88c7da4">BLAS_zuscr_begin</a> (int m, int n)</td></tr>
<tr class="separator:ga52b67393ad16e3d40e74fcdba88c7da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0246836bd8d4b8697c6674998397f3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gae0246836bd8d4b8697c6674998397f3a">blas_zuscr_begin_</a> (int *m, int *n, <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *istat)</td></tr>
<tr class="separator:gae0246836bd8d4b8697c6674998397f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11c5559450e186c2a86d714f564411f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga11c5559450e186c2a86d714f564411f3">BLAS_suscr_block_begin</a> (int Mb, int Nb, int k, int l)</td></tr>
<tr class="separator:ga11c5559450e186c2a86d714f564411f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0067882e19affabebf581452a7c05252"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga0067882e19affabebf581452a7c05252">blas_suscr_block_begin_</a> (int *Mb, int *Nb, int *k, int *l, <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *istat)</td></tr>
<tr class="separator:ga0067882e19affabebf581452a7c05252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0ca32cd2c78c8553d6d6b324e06ef59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gac0ca32cd2c78c8553d6d6b324e06ef59">BLAS_duscr_block_begin</a> (int Mb, int Nb, int k, int l)</td></tr>
<tr class="separator:gac0ca32cd2c78c8553d6d6b324e06ef59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga864facf0316453a27af4b7024a11453b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga864facf0316453a27af4b7024a11453b">blas_duscr_block_begin_</a> (int *Mb, int *Nb, int *k, int *l, <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *istat)</td></tr>
<tr class="separator:ga864facf0316453a27af4b7024a11453b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga050218d0fa552a3e2c2d5452f876d9b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga050218d0fa552a3e2c2d5452f876d9b5">BLAS_cuscr_block_begin</a> (int Mb, int Nb, int k, int l)</td></tr>
<tr class="separator:ga050218d0fa552a3e2c2d5452f876d9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga967bfc819ed66559e96ae55a6826d1f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga967bfc819ed66559e96ae55a6826d1f8">blas_cuscr_block_begin_</a> (int *Mb, int *Nb, int *k, int *l, <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *istat)</td></tr>
<tr class="separator:ga967bfc819ed66559e96ae55a6826d1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a261b2d1cc996c2a982ff8469faf286"><td class="memItemLeft" align="right" valign="top"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga5a261b2d1cc996c2a982ff8469faf286">BLAS_zuscr_block_begin</a> (int Mb, int Nb, int k, int l)</td></tr>
<tr class="separator:ga5a261b2d1cc996c2a982ff8469faf286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62c3bd7ba1a96f82055478d40af67370"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga62c3bd7ba1a96f82055478d40af67370">blas_zuscr_block_begin_</a> (int *Mb, int *Nb, int *k, int *l, <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *istat)</td></tr>
<tr class="separator:ga62c3bd7ba1a96f82055478d40af67370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7e006a448094a70204be60f24cdf1a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gae7e006a448094a70204be60f24cdf1a3">BLAS_suscr_variable_block_begin</a> (int Mb, int Nb, const int *K, const int *L)</td></tr>
<tr class="separator:gae7e006a448094a70204be60f24cdf1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab267e13449c999ad8a8e3e358f4b2ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gaab267e13449c999ad8a8e3e358f4b2ed">blas_suscr_variable_block_begin_</a> (int *Mb, int *Nb, const int *K, const int *L, <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *istat)</td></tr>
<tr class="separator:gaab267e13449c999ad8a8e3e358f4b2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0c3c6dc5503e21afb8192efb0f66edd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gae0c3c6dc5503e21afb8192efb0f66edd">BLAS_duscr_variable_block_begin</a> (int Mb, int Nb, const int *K, const int *L)</td></tr>
<tr class="separator:gae0c3c6dc5503e21afb8192efb0f66edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12c7c1bdd46724147dbbd9b38dd2028e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga12c7c1bdd46724147dbbd9b38dd2028e">blas_duscr_variable_block_begin_</a> (int *Mb, int *Nb, const int *K, const int *L, <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *istat)</td></tr>
<tr class="separator:ga12c7c1bdd46724147dbbd9b38dd2028e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95174fcf3bfbef91ab6b3b85fc90b128"><td class="memItemLeft" align="right" valign="top"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga95174fcf3bfbef91ab6b3b85fc90b128">BLAS_cuscr_variable_block_begin</a> (int Mb, int Nb, const int *K, const int *L)</td></tr>
<tr class="separator:ga95174fcf3bfbef91ab6b3b85fc90b128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24a2dac4570e6021fdcc5c84b52fb5bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga24a2dac4570e6021fdcc5c84b52fb5bb">blas_cuscr_variable_block_begin_</a> (int *Mb, int *Nb, const int *K, const int *L, <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *istat)</td></tr>
<tr class="separator:ga24a2dac4570e6021fdcc5c84b52fb5bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa582b369a0233027349f8f844cce7622"><td class="memItemLeft" align="right" valign="top"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gaa582b369a0233027349f8f844cce7622">BLAS_zuscr_variable_block_begin</a> (int Mb, int Nb, const int *K, const int *L)</td></tr>
<tr class="separator:gaa582b369a0233027349f8f844cce7622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa51253d1c144c8aa744b2e13742fec40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gaa51253d1c144c8aa744b2e13742fec40">blas_zuscr_variable_block_begin_</a> (int *Mb, int *Nb, const int *K, const int *L, <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *istat)</td></tr>
<tr class="separator:gaa51253d1c144c8aa744b2e13742fec40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7176a90049256cb0e0fe45db66f57dd2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga7176a90049256cb0e0fe45db66f57dd2">BLAS_suscr_end</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A)</td></tr>
<tr class="separator:ga7176a90049256cb0e0fe45db66f57dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5822f3be35eeb550c323de69ec9933d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga5822f3be35eeb550c323de69ec9933d3">blas_suscr_end_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *istat)</td></tr>
<tr class="separator:ga5822f3be35eeb550c323de69ec9933d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d9ce97bf054b1e3750eaae5d4e6c335"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga5d9ce97bf054b1e3750eaae5d4e6c335">BLAS_duscr_end</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A)</td></tr>
<tr class="separator:ga5d9ce97bf054b1e3750eaae5d4e6c335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2120eb06b87f0e85d03a368e5bc55485"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga2120eb06b87f0e85d03a368e5bc55485">blas_duscr_end_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *istat)</td></tr>
<tr class="separator:ga2120eb06b87f0e85d03a368e5bc55485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2b5eccd5cf442b5e2e79201d62ca2b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gac2b5eccd5cf442b5e2e79201d62ca2b5">BLAS_cuscr_end</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A)</td></tr>
<tr class="separator:gac2b5eccd5cf442b5e2e79201d62ca2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa78d3bef027e5a29ab5e5dd6188bcd75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gaa78d3bef027e5a29ab5e5dd6188bcd75">blas_cuscr_end_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *istat)</td></tr>
<tr class="separator:gaa78d3bef027e5a29ab5e5dd6188bcd75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6315d71f6f7abf8b82c89c70d6abbf3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gad6315d71f6f7abf8b82c89c70d6abbf3">BLAS_zuscr_end</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A)</td></tr>
<tr class="separator:gad6315d71f6f7abf8b82c89c70d6abbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c23466b531e84f472d5fa75228cb895"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga6c23466b531e84f472d5fa75228cb895">blas_zuscr_end_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *istat)</td></tr>
<tr class="separator:ga6c23466b531e84f472d5fa75228cb895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26e2c422895e5df8492bdb561cab4a54"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga26e2c422895e5df8492bdb561cab4a54">BLAS_suscr_insert_entry</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, float val, int i, int j)</td></tr>
<tr class="separator:ga26e2c422895e5df8492bdb561cab4a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b3085c739330bca518e8ef371f7d3b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga9b3085c739330bca518e8ef371f7d3b1">blas_suscr_insert_entry_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, float *val, int *i, int *j, int *istat)</td></tr>
<tr class="separator:ga9b3085c739330bca518e8ef371f7d3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga346ff5263bf0b3a5d7dda94e2000130c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga346ff5263bf0b3a5d7dda94e2000130c">BLAS_duscr_insert_entry</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, double val, int i, int j)</td></tr>
<tr class="separator:ga346ff5263bf0b3a5d7dda94e2000130c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29c2f202a144845cc1d32c8d65bd5c5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga29c2f202a144845cc1d32c8d65bd5c5f">blas_duscr_insert_entry_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, double *val, int *i, int *j, int *istat)</td></tr>
<tr class="separator:ga29c2f202a144845cc1d32c8d65bd5c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa39564978ebda8a88f8d19e3e060bc4d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gaa39564978ebda8a88f8d19e3e060bc4d">BLAS_cuscr_insert_entry</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const void *val, int i, int j)</td></tr>
<tr class="separator:gaa39564978ebda8a88f8d19e3e060bc4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d735497bdd3bbafbb6168cb0fde5103"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga6d735497bdd3bbafbb6168cb0fde5103">blas_cuscr_insert_entry_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const void *val, int *i, int *j, int *istat)</td></tr>
<tr class="separator:ga6d735497bdd3bbafbb6168cb0fde5103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ffe345c537b53ac5839da21b236d87c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga1ffe345c537b53ac5839da21b236d87c">BLAS_zuscr_insert_entry</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const void *val, int i, int j)</td></tr>
<tr class="separator:ga1ffe345c537b53ac5839da21b236d87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad6627231dc4230affa318726ff3f345"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gaad6627231dc4230affa318726ff3f345">blas_zuscr_insert_entry_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const void *val, int *i, int *j, int *istat)</td></tr>
<tr class="separator:gaad6627231dc4230affa318726ff3f345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6158601459aabebc22795864a2a62ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gac6158601459aabebc22795864a2a62ba">BLAS_suscr_insert_entries</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, int nnz, const float *val, const int *indx, const int *jndx)</td></tr>
<tr class="separator:gac6158601459aabebc22795864a2a62ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9119b49fd049bcaa310bccb36fcda664"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga9119b49fd049bcaa310bccb36fcda664">blas_suscr_insert_entries_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *nnz, const float *val, const int *indx, const int *jndx, int *istat)</td></tr>
<tr class="separator:ga9119b49fd049bcaa310bccb36fcda664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0683bc8f0af5dd3e53b964190f9e1b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gae0683bc8f0af5dd3e53b964190f9e1b4">BLAS_duscr_insert_entries</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, int nnz, const double *val, const int *indx, const int *jndx)</td></tr>
<tr class="separator:gae0683bc8f0af5dd3e53b964190f9e1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2c1a4c7b2cebca56aedbad7a002e15f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gac2c1a4c7b2cebca56aedbad7a002e15f">blas_duscr_insert_entries_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *nnz, const double *val, const int *indx, const int *jndx, int *istat)</td></tr>
<tr class="separator:gac2c1a4c7b2cebca56aedbad7a002e15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5af752a3fcb2898412f576eee7d9d618"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga5af752a3fcb2898412f576eee7d9d618">BLAS_cuscr_insert_entries</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, int nnz, const void *val, const int *indx, const int *jndx)</td></tr>
<tr class="separator:ga5af752a3fcb2898412f576eee7d9d618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3deb906fcd5f9b9221b5865541c57d18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga3deb906fcd5f9b9221b5865541c57d18">blas_cuscr_insert_entries_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *nnz, const void *val, const int *indx, const int *jndx, int *istat)</td></tr>
<tr class="separator:ga3deb906fcd5f9b9221b5865541c57d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacc9c9e5c95df4ea6656ad93f1f09666"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gaacc9c9e5c95df4ea6656ad93f1f09666">BLAS_zuscr_insert_entries</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, int nnz, const void *val, const int *indx, const int *jndx)</td></tr>
<tr class="separator:gaacc9c9e5c95df4ea6656ad93f1f09666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9ad3afc16fc0181117004fd46ff78ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gad9ad3afc16fc0181117004fd46ff78ae">blas_zuscr_insert_entries_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *nnz, const void *val, const int *indx, const int *jndx, int *istat)</td></tr>
<tr class="separator:gad9ad3afc16fc0181117004fd46ff78ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga547d271038794dfc797aecc70e294761"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga547d271038794dfc797aecc70e294761">BLAS_suscr_insert_col</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, int j, int nnz, const float *val, const int *indx)</td></tr>
<tr class="separator:ga547d271038794dfc797aecc70e294761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d8c691851acf099c25eff1a4c2885c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga2d8c691851acf099c25eff1a4c2885c1">blas_suscr_insert_col_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *j, int *nnz, const float *val, const int *indx, int *istat)</td></tr>
<tr class="separator:ga2d8c691851acf099c25eff1a4c2885c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ee73d3b27bdc68e12c85ba281a337be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga8ee73d3b27bdc68e12c85ba281a337be">BLAS_duscr_insert_col</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, int j, int nnz, const double *val, const int *indx)</td></tr>
<tr class="separator:ga8ee73d3b27bdc68e12c85ba281a337be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5645393bb00d715d882e8e2d55c3f0d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga5645393bb00d715d882e8e2d55c3f0d1">blas_duscr_insert_col_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *j, int *nnz, const double *val, const int *indx, int *istat)</td></tr>
<tr class="separator:ga5645393bb00d715d882e8e2d55c3f0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga589495aa8acd4eac99ef9132bc4062c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga589495aa8acd4eac99ef9132bc4062c9">BLAS_cuscr_insert_col</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, int j, int nnz, const void *val, const int *indx)</td></tr>
<tr class="separator:ga589495aa8acd4eac99ef9132bc4062c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aadf4dc810ff6eb123a1bf9c859efe8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga1aadf4dc810ff6eb123a1bf9c859efe8">blas_cuscr_insert_col_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *j, int *nnz, const void *val, const int *indx, int *istat)</td></tr>
<tr class="separator:ga1aadf4dc810ff6eb123a1bf9c859efe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00cfdd3669b146b25d42a32f104ff8a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga00cfdd3669b146b25d42a32f104ff8a3">BLAS_zuscr_insert_col</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, int j, int nnz, const void *val, const int *indx)</td></tr>
<tr class="separator:ga00cfdd3669b146b25d42a32f104ff8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10a2dc6a5399459c83282bda757f5096"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga10a2dc6a5399459c83282bda757f5096">blas_zuscr_insert_col_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *j, int *nnz, const void *val, const int *indx, int *istat)</td></tr>
<tr class="separator:ga10a2dc6a5399459c83282bda757f5096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b815fa125e3c84a6e6a6ead2c9ef87b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga9b815fa125e3c84a6e6a6ead2c9ef87b">BLAS_suscr_insert_row</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, int i, int nnz, const float *val, const int *indx)</td></tr>
<tr class="separator:ga9b815fa125e3c84a6e6a6ead2c9ef87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71080ddbf0e0e602c7bc36993a6c88ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga71080ddbf0e0e602c7bc36993a6c88ca">blas_suscr_insert_row_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *i, int *nnz, const float *val, const int *indx, int *istat)</td></tr>
<tr class="separator:ga71080ddbf0e0e602c7bc36993a6c88ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3472ca6b036771a68d6f5f01387e482"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gac3472ca6b036771a68d6f5f01387e482">BLAS_duscr_insert_row</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, int i, int nnz, const double *val, const int *indx)</td></tr>
<tr class="separator:gac3472ca6b036771a68d6f5f01387e482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa72e5450302fa424dcd6cfae0bad872d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gaa72e5450302fa424dcd6cfae0bad872d">blas_duscr_insert_row_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *i, int *nnz, const double *val, const int *indx, int *istat)</td></tr>
<tr class="separator:gaa72e5450302fa424dcd6cfae0bad872d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77929c94cee3278cc7594a3f1377f5f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga77929c94cee3278cc7594a3f1377f5f8">BLAS_cuscr_insert_row</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, int i, int nnz, const void *val, const int *indx)</td></tr>
<tr class="separator:ga77929c94cee3278cc7594a3f1377f5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4acfbfdf33a5682ac657add0292711d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gad4acfbfdf33a5682ac657add0292711d">blas_cuscr_insert_row_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *i, int *nnz, const void *val, const int *indx, int *istat)</td></tr>
<tr class="separator:gad4acfbfdf33a5682ac657add0292711d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab52e13dc7c61fc48e593276f04cb2d30"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gab52e13dc7c61fc48e593276f04cb2d30">BLAS_zuscr_insert_row</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, int i, int nnz, const void *val, const int *indx)</td></tr>
<tr class="separator:gab52e13dc7c61fc48e593276f04cb2d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf871e29bfce399dedbebe2aa9c7831df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gaf871e29bfce399dedbebe2aa9c7831df">blas_zuscr_insert_row_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *i, int *nnz, const void *val, const int *indx, int *istat)</td></tr>
<tr class="separator:gaf871e29bfce399dedbebe2aa9c7831df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e567e79f675ed861c8f446d0e7a78f5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga6e567e79f675ed861c8f446d0e7a78f5">BLAS_suscr_insert_clique</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const int k, const int l, const float *val, const int row_stride, const int col_stride, const int *indx, const int *jndx)</td></tr>
<tr class="separator:ga6e567e79f675ed861c8f446d0e7a78f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcee9667fc445e32012c960fca7e698d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gafcee9667fc445e32012c960fca7e698d">blas_suscr_insert_clique_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const int *k, const int *l, const float *val, const int *row_stride, const int *col_stride, const int *indx, const int *jndx, int *istat)</td></tr>
<tr class="separator:gafcee9667fc445e32012c960fca7e698d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga290547e34be3648b2fe6a7378e59a7ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga290547e34be3648b2fe6a7378e59a7ec">BLAS_duscr_insert_clique</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const int k, const int l, const double *val, const int row_stride, const int col_stride, const int *indx, const int *jndx)</td></tr>
<tr class="separator:ga290547e34be3648b2fe6a7378e59a7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f7870f8a1114b94444c721c933e8bef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga1f7870f8a1114b94444c721c933e8bef">blas_duscr_insert_clique_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const int *k, const int *l, const double *val, const int *row_stride, const int *col_stride, const int *indx, const int *jndx, int *istat)</td></tr>
<tr class="separator:ga1f7870f8a1114b94444c721c933e8bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf089aaac5d65a4e38130b25d5ba2ba27"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gaf089aaac5d65a4e38130b25d5ba2ba27">BLAS_cuscr_insert_clique</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const int k, const int l, const void *val, const int row_stride, const int col_stride, const int *indx, const int *jndx)</td></tr>
<tr class="separator:gaf089aaac5d65a4e38130b25d5ba2ba27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06acafbf28371b1ad8a75a85173261e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga06acafbf28371b1ad8a75a85173261e6">blas_cuscr_insert_clique_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const int *k, const int *l, const void *val, const int *row_stride, const int *col_stride, const int *indx, const int *jndx, int *istat)</td></tr>
<tr class="separator:ga06acafbf28371b1ad8a75a85173261e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52519d2caa1070b0c80ac3c6cb104d92"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga52519d2caa1070b0c80ac3c6cb104d92">BLAS_zuscr_insert_clique</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const int k, const int l, const void *val, const int row_stride, const int col_stride, const int *indx, const int *jndx)</td></tr>
<tr class="separator:ga52519d2caa1070b0c80ac3c6cb104d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c3430083655b74988536d823e40c723"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga8c3430083655b74988536d823e40c723">blas_zuscr_insert_clique_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const int *k, const int *l, const void *val, const int *row_stride, const int *col_stride, const int *indx, const int *jndx, int *istat)</td></tr>
<tr class="separator:ga8c3430083655b74988536d823e40c723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa682b478ac48e12d4a091977e8c45768"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gaa682b478ac48e12d4a091977e8c45768">BLAS_suscr_insert_block</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const float *val, int row_stride, int col_stride, int i, int j)</td></tr>
<tr class="separator:gaa682b478ac48e12d4a091977e8c45768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61080e2828351bd1585deb2713ed8a29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga61080e2828351bd1585deb2713ed8a29">blas_suscr_insert_block_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const float *val, int *row_stride, int *col_stride, int *i, int *j, int *istat)</td></tr>
<tr class="separator:ga61080e2828351bd1585deb2713ed8a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d35aa3e27cdbf8a50db5b47ff5e0892"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga5d35aa3e27cdbf8a50db5b47ff5e0892">BLAS_duscr_insert_block</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const double *val, int row_stride, int col_stride, int i, int j)</td></tr>
<tr class="separator:ga5d35aa3e27cdbf8a50db5b47ff5e0892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38012bbc4e99df72fb95409a4860ead7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga38012bbc4e99df72fb95409a4860ead7">blas_duscr_insert_block_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const double *val, int *row_stride, int *col_stride, int *i, int *j, int *istat)</td></tr>
<tr class="separator:ga38012bbc4e99df72fb95409a4860ead7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42054351f49850f079733143b2af87fb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga42054351f49850f079733143b2af87fb">BLAS_cuscr_insert_block</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const void *val, int row_stride, int col_stride, int i, int j)</td></tr>
<tr class="separator:ga42054351f49850f079733143b2af87fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga527ae15ee9e003d948494d9fcdad5dba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga527ae15ee9e003d948494d9fcdad5dba">blas_cuscr_insert_block_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const void *val, int *row_stride, int *col_stride, int *i, int *j, int *istat)</td></tr>
<tr class="separator:ga527ae15ee9e003d948494d9fcdad5dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga573ee2ea89db4a133b8729abbb1223f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga573ee2ea89db4a133b8729abbb1223f0">BLAS_zuscr_insert_block</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const void *val, int row_stride, int col_stride, int i, int j)</td></tr>
<tr class="separator:ga573ee2ea89db4a133b8729abbb1223f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3837cd5c7b2e8ac11c6c0e5cff8914c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gac3837cd5c7b2e8ac11c6c0e5cff8914c">blas_zuscr_insert_block_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const void *val, int *row_stride, int *col_stride, int *i, int *j, int *istat)</td></tr>
<tr class="separator:gac3837cd5c7b2e8ac11c6c0e5cff8914c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ff68116b5ae79c37bf335096de973c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga2ff68116b5ae79c37bf335096de973c0">BLAS_uscr_end</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A)</td></tr>
<tr class="separator:ga2ff68116b5ae79c37bf335096de973c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60974067bf5367a9a3c6eaa9f6f8f4ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga60974067bf5367a9a3c6eaa9f6f8f4ab">blas_uscr_end_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *istat)</td></tr>
<tr class="separator:ga60974067bf5367a9a3c6eaa9f6f8f4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b0cca8196f40f7b55084a978b40717f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga8b0cca8196f40f7b55084a978b40717f">BLAS_usds</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A)</td></tr>
<tr class="separator:ga8b0cca8196f40f7b55084a978b40717f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4db91cffaf71632bd41b7423c64b757"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gae4db91cffaf71632bd41b7423c64b757">blas_usds_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *istat)</td></tr>
<tr class="separator:gae4db91cffaf71632bd41b7423c64b757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aad66cf55b972f14329d6e914e2c152"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga7aad66cf55b972f14329d6e914e2c152">BLAS_susrows_scale</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const float *d, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> trans)</td></tr>
<tr class="separator:ga7aad66cf55b972f14329d6e914e2c152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga556ee3376cfe910182dc057d2ffd3e51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga556ee3376cfe910182dc057d2ffd3e51">blas_susrows_scale_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const float *d, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *trans, int *istat)</td></tr>
<tr class="separator:ga556ee3376cfe910182dc057d2ffd3e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45dcbfbdd60a2af9cd996e5c9039e08a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga45dcbfbdd60a2af9cd996e5c9039e08a">BLAS_dusrows_scale</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const double *d, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> trans)</td></tr>
<tr class="separator:ga45dcbfbdd60a2af9cd996e5c9039e08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72462911e40886183e72b97575b6be78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga72462911e40886183e72b97575b6be78">blas_dusrows_scale_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const double *d, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *trans, int *istat)</td></tr>
<tr class="separator:ga72462911e40886183e72b97575b6be78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a1339d836fe0bef40ee2ff2e0d23c84"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga8a1339d836fe0bef40ee2ff2e0d23c84">BLAS_cusrows_scale</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const void *d, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> trans)</td></tr>
<tr class="separator:ga8a1339d836fe0bef40ee2ff2e0d23c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3161ba6800b4c19a825c6c649c04f10e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga3161ba6800b4c19a825c6c649c04f10e">blas_cusrows_scale_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const void *d, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *trans, int *istat)</td></tr>
<tr class="separator:ga3161ba6800b4c19a825c6c649c04f10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac90f64f4065b6b4f654eb139e0a0c62d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gac90f64f4065b6b4f654eb139e0a0c62d">BLAS_zusrows_scale</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const void *d, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> trans)</td></tr>
<tr class="separator:gac90f64f4065b6b4f654eb139e0a0c62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad776dac8b803704bd8629b026774dd7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gad776dac8b803704bd8629b026774dd7b">blas_zusrows_scale_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const void *d, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *trans, int *istat)</td></tr>
<tr class="separator:gad776dac8b803704bd8629b026774dd7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1113eda1c806ca3631fefde07624fbd6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga1113eda1c806ca3631fefde07624fbd6">BLAS_susget_diag</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, float *d)</td></tr>
<tr class="separator:ga1113eda1c806ca3631fefde07624fbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0444e8a4b321bf1488fb496bdf3116d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga0444e8a4b321bf1488fb496bdf3116d2">blas_susget_diag_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, float *d, int *istat)</td></tr>
<tr class="separator:ga0444e8a4b321bf1488fb496bdf3116d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35b70a7c3083b791cf1b94cb20ef57be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga35b70a7c3083b791cf1b94cb20ef57be">BLAS_dusget_diag</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, double *d)</td></tr>
<tr class="separator:ga35b70a7c3083b791cf1b94cb20ef57be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cfde04c833adeb887db75f4b2e104dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga7cfde04c833adeb887db75f4b2e104dd">blas_dusget_diag_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, double *d, int *istat)</td></tr>
<tr class="separator:ga7cfde04c833adeb887db75f4b2e104dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ec4b6dce3701c5803efa6b7455e1504"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga4ec4b6dce3701c5803efa6b7455e1504">BLAS_cusget_diag</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, void *d)</td></tr>
<tr class="separator:ga4ec4b6dce3701c5803efa6b7455e1504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4865a8fda031074a0d91cf5c548584b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga4865a8fda031074a0d91cf5c548584b9">blas_cusget_diag_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, void *d, int *istat)</td></tr>
<tr class="separator:ga4865a8fda031074a0d91cf5c548584b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad175937c05d3d05d3aa7fa35eb3028ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gad175937c05d3d05d3aa7fa35eb3028ec">BLAS_zusget_diag</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, void *d)</td></tr>
<tr class="separator:gad175937c05d3d05d3aa7fa35eb3028ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73feb9adc685f7ff1d66763b0801a0f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga73feb9adc685f7ff1d66763b0801a0f9">blas_zusget_diag_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, void *d, int *istat)</td></tr>
<tr class="separator:ga73feb9adc685f7ff1d66763b0801a0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadf5ca5826e15d500f60474e94601ed2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gaadf5ca5826e15d500f60474e94601ed2">BLAS_susget_rows_nnz</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const int fr, const int lr, int *nnzp)</td></tr>
<tr class="separator:gaadf5ca5826e15d500f60474e94601ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabcfab419d58bf9bef0085f96ab43488"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gaabcfab419d58bf9bef0085f96ab43488">blas_susget_rows_nnz_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const int *fr, const int *lr, int *nnzp, int *istat)</td></tr>
<tr class="separator:gaabcfab419d58bf9bef0085f96ab43488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb047adeebbb38d542a650c0b935b307"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gafb047adeebbb38d542a650c0b935b307">BLAS_dusget_rows_nnz</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const int fr, const int lr, int *nnzp)</td></tr>
<tr class="separator:gafb047adeebbb38d542a650c0b935b307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa04899898ad27f1aaed04518988764c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gaa04899898ad27f1aaed04518988764c9">blas_dusget_rows_nnz_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const int *fr, const int *lr, int *nnzp, int *istat)</td></tr>
<tr class="separator:gaa04899898ad27f1aaed04518988764c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd5c5c70a203340db368b88296f21da5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gacd5c5c70a203340db368b88296f21da5">BLAS_cusget_rows_nnz</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const int fr, const int lr, int *nnzp)</td></tr>
<tr class="separator:gacd5c5c70a203340db368b88296f21da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf474caab59f5a1c38954e1aabf0d1ff2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gaf474caab59f5a1c38954e1aabf0d1ff2">blas_cusget_rows_nnz_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const int *fr, const int *lr, int *nnzp, int *istat)</td></tr>
<tr class="separator:gaf474caab59f5a1c38954e1aabf0d1ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aafb42cc79b70119dd05d010a2ca844"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga5aafb42cc79b70119dd05d010a2ca844">BLAS_zusget_rows_nnz</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const int fr, const int lr, int *nnzp)</td></tr>
<tr class="separator:ga5aafb42cc79b70119dd05d010a2ca844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeafa9dc10823580bdc76217a75fecba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gaeeafa9dc10823580bdc76217a75fecba">blas_zusget_rows_nnz_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const int *fr, const int *lr, int *nnzp, int *istat)</td></tr>
<tr class="separator:gaeeafa9dc10823580bdc76217a75fecba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f44678556f1aa33e9c74010d0811f76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga1f44678556f1aa33e9c74010d0811f76">BLAS_susget_rows_sparse</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, float *VA, int *IA, int *JA, int *nnz, const int fr, const int lr)</td></tr>
<tr class="separator:ga1f44678556f1aa33e9c74010d0811f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga271d33ae9fc0e16360bf744a25fc6d99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga271d33ae9fc0e16360bf744a25fc6d99">blas_susget_rows_sparse_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, float *VA, int *IA, int *JA, int *nnz, const int *fr, const int *lr, int *istat)</td></tr>
<tr class="separator:ga271d33ae9fc0e16360bf744a25fc6d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99093b2c9c92aa5b0805a136fcd0e2c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga99093b2c9c92aa5b0805a136fcd0e2c3">BLAS_dusget_rows_sparse</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, double *VA, int *IA, int *JA, int *nnz, const int fr, const int lr)</td></tr>
<tr class="separator:ga99093b2c9c92aa5b0805a136fcd0e2c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1be827257216ff2f84b1c9394f00ca60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga1be827257216ff2f84b1c9394f00ca60">blas_dusget_rows_sparse_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, double *VA, int *IA, int *JA, int *nnz, const int *fr, const int *lr, int *istat)</td></tr>
<tr class="separator:ga1be827257216ff2f84b1c9394f00ca60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa38bc05714f7a9c721cda9393f21723d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gaa38bc05714f7a9c721cda9393f21723d">BLAS_cusget_rows_sparse</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, void *VA, int *IA, int *JA, int *nnz, const int fr, const int lr)</td></tr>
<tr class="separator:gaa38bc05714f7a9c721cda9393f21723d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f245b2d0ea2100c1eb100c60c0fe94d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga2f245b2d0ea2100c1eb100c60c0fe94d">blas_cusget_rows_sparse_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, void *VA, int *IA, int *JA, int *nnz, const int *fr, const int *lr, int *istat)</td></tr>
<tr class="separator:ga2f245b2d0ea2100c1eb100c60c0fe94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4948209c662695a0b5655dca77a94b2d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga4948209c662695a0b5655dca77a94b2d">BLAS_zusget_rows_sparse</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, void *VA, int *IA, int *JA, int *nnz, const int fr, const int lr)</td></tr>
<tr class="separator:ga4948209c662695a0b5655dca77a94b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga146c34966aa096df8fefdd400e119083"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga146c34966aa096df8fefdd400e119083">blas_zusget_rows_sparse_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, void *VA, int *IA, int *JA, int *nnz, const int *fr, const int *lr, int *istat)</td></tr>
<tr class="separator:ga146c34966aa096df8fefdd400e119083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc031d78d0274c81039c2448a403cd10"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gafc031d78d0274c81039c2448a403cd10">BLAS_susget_matrix_nnz</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, int *nnz)</td></tr>
<tr class="separator:gafc031d78d0274c81039c2448a403cd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga039a9d4da3423ea71726242e1c1251e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga039a9d4da3423ea71726242e1c1251e7">blas_susget_matrix_nnz_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *nnz, int *istat)</td></tr>
<tr class="separator:ga039a9d4da3423ea71726242e1c1251e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga441bff94fdc50b9bf6e180d36f51c3ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga441bff94fdc50b9bf6e180d36f51c3ce">BLAS_dusget_matrix_nnz</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, int *nnz)</td></tr>
<tr class="separator:ga441bff94fdc50b9bf6e180d36f51c3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a4bc573dc07849e7a72ecb2d2f0c31d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga3a4bc573dc07849e7a72ecb2d2f0c31d">blas_dusget_matrix_nnz_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *nnz, int *istat)</td></tr>
<tr class="separator:ga3a4bc573dc07849e7a72ecb2d2f0c31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe27f3044269d37cadb569fc6796ac01"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gafe27f3044269d37cadb569fc6796ac01">BLAS_cusget_matrix_nnz</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, int *nnz)</td></tr>
<tr class="separator:gafe27f3044269d37cadb569fc6796ac01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19e30bb70673342b4d6308bd9cf46884"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga19e30bb70673342b4d6308bd9cf46884">blas_cusget_matrix_nnz_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *nnz, int *istat)</td></tr>
<tr class="separator:ga19e30bb70673342b4d6308bd9cf46884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85e15d7a3331e8ed4d702908477e2896"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga85e15d7a3331e8ed4d702908477e2896">BLAS_zusget_matrix_nnz</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, int *nnz)</td></tr>
<tr class="separator:ga85e15d7a3331e8ed4d702908477e2896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bdd048dea68ecbd8fd712349d4fbf13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga9bdd048dea68ecbd8fd712349d4fbf13">blas_zusget_matrix_nnz_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, int *nnz, int *istat)</td></tr>
<tr class="separator:ga9bdd048dea68ecbd8fd712349d4fbf13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab48e50e0680b905c6bf51747b14f9ab8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gab48e50e0680b905c6bf51747b14f9ab8">BLAS_susget_infinity_norm</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, float *in, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> trans)</td></tr>
<tr class="separator:gab48e50e0680b905c6bf51747b14f9ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9733f7c93409180f6c67808f86782e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gae9733f7c93409180f6c67808f86782e2">blas_susget_infinity_norm_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, float *in, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *trans, int *istat)</td></tr>
<tr class="separator:gae9733f7c93409180f6c67808f86782e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga497f00123d42a278c3b5332a5d0021f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga497f00123d42a278c3b5332a5d0021f6">BLAS_dusget_infinity_norm</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, double *in, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> trans)</td></tr>
<tr class="separator:ga497f00123d42a278c3b5332a5d0021f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4e31e05708dac4fc74ab200cfc94f80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gad4e31e05708dac4fc74ab200cfc94f80">blas_dusget_infinity_norm_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, double *in, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *trans, int *istat)</td></tr>
<tr class="separator:gad4e31e05708dac4fc74ab200cfc94f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga669fa319b6082b66dc786a4a72a9dbdd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga669fa319b6082b66dc786a4a72a9dbdd">BLAS_cusget_infinity_norm</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, void *in, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> trans)</td></tr>
<tr class="separator:ga669fa319b6082b66dc786a4a72a9dbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga403b439e35e4757f991771a3760ea699"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga403b439e35e4757f991771a3760ea699">blas_cusget_infinity_norm_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, void *in, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *trans, int *istat)</td></tr>
<tr class="separator:ga403b439e35e4757f991771a3760ea699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3178002c71c71591a0c2cf460b9fbf9a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga3178002c71c71591a0c2cf460b9fbf9a">BLAS_zusget_infinity_norm</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, void *in, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> trans)</td></tr>
<tr class="separator:ga3178002c71c71591a0c2cf460b9fbf9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8d8a4ec8eda9377e7407869ba813bba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gad8d8a4ec8eda9377e7407869ba813bba">blas_zusget_infinity_norm_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, void *in, const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *trans, int *istat)</td></tr>
<tr class="separator:gad8d8a4ec8eda9377e7407869ba813bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae011e8a07416ebf9b03487f921f0ad5f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gae011e8a07416ebf9b03487f921f0ad5f">BLAS_susset_elements</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const int *ia, const int *ja, const float *va, const int nnz)</td></tr>
<tr class="separator:gae011e8a07416ebf9b03487f921f0ad5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef2d023342cdd7dbe9eac06ad3ee2592"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gaef2d023342cdd7dbe9eac06ad3ee2592">blas_susset_elements_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const int *ia, const int *ja, const float *va, const int *nnz, int *istat)</td></tr>
<tr class="separator:gaef2d023342cdd7dbe9eac06ad3ee2592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga875c246c53ad28d02e064fe83fa71c74"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga875c246c53ad28d02e064fe83fa71c74">BLAS_dusset_elements</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const int *ia, const int *ja, const double *va, const int nnz)</td></tr>
<tr class="separator:ga875c246c53ad28d02e064fe83fa71c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01e480eb3f48f1322ecb9b07f3240051"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga01e480eb3f48f1322ecb9b07f3240051">blas_dusset_elements_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const int *ia, const int *ja, const double *va, const int *nnz, int *istat)</td></tr>
<tr class="separator:ga01e480eb3f48f1322ecb9b07f3240051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3a9d2433be861bb29a10f361303a6ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gac3a9d2433be861bb29a10f361303a6ff">BLAS_cusset_elements</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const int *ia, const int *ja, const void *va, const int nnz)</td></tr>
<tr class="separator:gac3a9d2433be861bb29a10f361303a6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fa110410ad828a27586b9f1dc68bc4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga5fa110410ad828a27586b9f1dc68bc4c">blas_cusset_elements_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const int *ia, const int *ja, const void *va, const int *nnz, int *istat)</td></tr>
<tr class="separator:ga5fa110410ad828a27586b9f1dc68bc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf861d08ba8631e769fcb8f25264b8965"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gaf861d08ba8631e769fcb8f25264b8965">BLAS_zusset_elements</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const int *ia, const int *ja, const void *va, const int nnz)</td></tr>
<tr class="separator:gaf861d08ba8631e769fcb8f25264b8965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d3dd01c5e3e4b568cf3ff7e6c807789"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga6d3dd01c5e3e4b568cf3ff7e6c807789">blas_zusset_elements_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const int *ia, const int *ja, const void *va, const int *nnz, int *istat)</td></tr>
<tr class="separator:ga6d3dd01c5e3e4b568cf3ff7e6c807789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75f22d2c0b4037375bc9dcbf604d69b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga75f22d2c0b4037375bc9dcbf604d69b0">BLAS_susset_element</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const int i, const int j, float *v)</td></tr>
<tr class="separator:ga75f22d2c0b4037375bc9dcbf604d69b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga722177d7ee3f45cf6ace9854902cf4a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga722177d7ee3f45cf6ace9854902cf4a8">blas_susset_element_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const int *i, const int *j, float *v, int *istat)</td></tr>
<tr class="separator:ga722177d7ee3f45cf6ace9854902cf4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ac36c1131d0f75d0a1775a9c5d8da72"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga7ac36c1131d0f75d0a1775a9c5d8da72">BLAS_dusset_element</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const int i, const int j, double *v)</td></tr>
<tr class="separator:ga7ac36c1131d0f75d0a1775a9c5d8da72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe25bed88ace26d930f31a737e543197"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gafe25bed88ace26d930f31a737e543197">blas_dusset_element_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const int *i, const int *j, double *v, int *istat)</td></tr>
<tr class="separator:gafe25bed88ace26d930f31a737e543197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d1369eb0912f62315bdc8bfdce5b09b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga0d1369eb0912f62315bdc8bfdce5b09b">BLAS_cusset_element</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const int i, const int j, void *v)</td></tr>
<tr class="separator:ga0d1369eb0912f62315bdc8bfdce5b09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e7eb89828c58961f655f8a64b09cda7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga9e7eb89828c58961f655f8a64b09cda7">blas_cusset_element_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const int *i, const int *j, void *v, int *istat)</td></tr>
<tr class="separator:ga9e7eb89828c58961f655f8a64b09cda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae423e34d5a98eb240edb270e26742c90"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gae423e34d5a98eb240edb270e26742c90">BLAS_zusset_element</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const int i, const int j, void *v)</td></tr>
<tr class="separator:gae423e34d5a98eb240edb270e26742c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac91099519c242471405de4e4df28e5bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gac91099519c242471405de4e4df28e5bf">blas_zusset_element_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const int *i, const int *j, void *v, int *istat)</td></tr>
<tr class="separator:gac91099519c242471405de4e4df28e5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7d85107abe6104e71d522362f1cf445"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gaa7d85107abe6104e71d522362f1cf445">BLAS_susget_element</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const int i, const int j, float *v)</td></tr>
<tr class="separator:gaa7d85107abe6104e71d522362f1cf445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga982d5f992dca324bc313412cfb31626d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga982d5f992dca324bc313412cfb31626d">blas_susget_element_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const int *i, const int *j, float *v, int *istat)</td></tr>
<tr class="separator:ga982d5f992dca324bc313412cfb31626d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cdfc09a860b29267539c4868f41ec51"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga7cdfc09a860b29267539c4868f41ec51">BLAS_dusget_element</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const int i, const int j, double *v)</td></tr>
<tr class="separator:ga7cdfc09a860b29267539c4868f41ec51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58daa61154a8bc683070a2082584e878"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga58daa61154a8bc683070a2082584e878">blas_dusget_element_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const int *i, const int *j, double *v, int *istat)</td></tr>
<tr class="separator:ga58daa61154a8bc683070a2082584e878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga984d3e91b376b8caed4a2b9711e761c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga984d3e91b376b8caed4a2b9711e761c5">BLAS_cusget_element</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const int i, const int j, void *v)</td></tr>
<tr class="separator:ga984d3e91b376b8caed4a2b9711e761c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59f571fdb7f3c3919920c006bfff7bee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga59f571fdb7f3c3919920c006bfff7bee">blas_cusget_element_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const int *i, const int *j, void *v, int *istat)</td></tr>
<tr class="separator:ga59f571fdb7f3c3919920c006bfff7bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga231e3c8f71d0409926f7ee5673adfb62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga231e3c8f71d0409926f7ee5673adfb62">BLAS_zusget_element</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, const int i, const int j, void *v)</td></tr>
<tr class="separator:ga231e3c8f71d0409926f7ee5673adfb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga779b26f7805485d4f1993eec9cef0ed1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga779b26f7805485d4f1993eec9cef0ed1">blas_zusget_element_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, const int *i, const int *j, void *v, int *istat)</td></tr>
<tr class="separator:ga779b26f7805485d4f1993eec9cef0ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9926e5d108094c236a1d5fe4a8b62a0d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga9926e5d108094c236a1d5fe4a8b62a0d">BLAS_usgp</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, rsb_blas_pname_t pname)</td></tr>
<tr class="separator:ga9926e5d108094c236a1d5fe4a8b62a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8db33945615cf1d67e742737b8c93099"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga8db33945615cf1d67e742737b8c93099">blas_usgp_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, rsb_blas_pname_t *pname, int *istat)</td></tr>
<tr class="separator:ga8db33945615cf1d67e742737b8c93099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5399e3334beff0aab3840752ac7e13df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga5399e3334beff0aab3840752ac7e13df">blas_ussp_</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *A, rsb_blas_pname_t *pname, int *istat)</td></tr>
<tr class="separator:ga5399e3334beff0aab3840752ac7e13df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8672dab1f86ae3d78a8a0e31568b28f5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A, rsb_blas_pname_t pname)</td></tr>
<tr class="separator:ga8672dab1f86ae3d78a8a0e31568b28f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga144b8e13c62a239a3097256af7c09fcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#ga144b8e13c62a239a3097256af7c09fcb">rsb_blas_file_mtx_load</a> (const <a class="el" href="rsb_8h.html#a10ec0af478bcccdab11545b106678ef6">rsb_char_t</a> *filename, <a class="el" href="rsb_8h.html#ac0f6a03345c8874f6e50f0ed033d984b">rsb_type_t</a> typecode)</td></tr>
<tr class="separator:ga144b8e13c62a239a3097256af7c09fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4d8c73e5d9faa85209bcc4e885d4ff1"><td class="memItemLeft" align="right" valign="top">struct rsb_mtx_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rsb__doc__sparse__blas.html#gac4d8c73e5d9faa85209bcc4e885d4ff1">rsb_blas_get_mtx</a> (<a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> A)</td></tr>
<tr class="separator:gac4d8c73e5d9faa85209bcc4e885d4ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>A Sparse BLAS interface (see <a href="http://www.netlib.org/blas/blast-forum/">http://www.netlib.org/blas/blast-forum/</a>) to <code>librsb</code>. Level 1 (vector-vector operations) is supported in a basic way. Level 2 (sparse matrix-dense vector operations) is supported fully. Level 3 (sparse matrix-dense matrix operations) is supported as a wrapper around Level 2. </p>
<p>We also implement a number of useful extra functions as custom extensions, giving access to other <code>librsb</code> functionality.</p>
<p>The usage pattern of this interface matches that of the Sparse BLAS standard, exception made for the necessity of initialization/finalization of <code>librsb</code>. The Sparse BLAS interface is also available for Fortran: see <a class="el" href="rsb__blas__sparse_8F90.html">rsb_blas_sparse.F90</a>.</p>
<p>The user should be aware of the following: </p><ul>
<li>Because this Sparse BLAS implementation is built around <code>librsb</code>, initialization with <a class="el" href="group__rsb__doc__rsb.html#gaf2b874d9f117ee6a6899634472b17946">rsb_lib_init()</a> and finalization with <a class="el" href="group__rsb__doc__rsb.html#ga86db30487afe975ed18a7aa6ee0db81d">rsb_lib_exit()</a> is necessary. Inclusion of the <code><a class="el" href="rsb_8h.html" title="This file declares the user interface functions and data structures for the librsb library (see The l...">rsb.h</a></code> header is necessary. </li>
<li><code>librsb</code> gives users freedom of in/out arbitrarily BLAS types support at configure/build time. Hence, while all the interface functions are always included the Sparse BLAS header file, they may return an error code. Be sure of having configured correctly the library at configure time (and see the <a class="el" href="blas__sparse_8h.html">blas_sparse.h</a> header file for types configured in the current build). </li>
<li>According to the standard, the complex type functions for C accept scalar values by reference rather than by copy; equivalent functions for other types do not do so, so this may cause confusion. Be careful. </li>
<li>Error checking is weak; so for instance, passing a function the handle of a matrix of mismatching type will not be detected as an error, although it's incorrect. </li>
<li>According to the standard, VBR and BCSR styled constructors are supported, although these are interfaces for <code>librsb's</code> own matrix representation. </li>
<li>Here functions for both Fortran and C are listed. The Fortran functions are declared and documented with the C notation. We may provide a better documentation in a future release. </li>
<li>Each identifier documented here suffixed by <code>_</code> (e.g.: <a class="el" href="group__rsb__doc__sparse__blas.html#ga93ef5ce40255281ae251ab5675cbbc00">blas_susdot_()</a>) can be used from Fortran with the name stripped by that suffix (so in this case, <code>blas_susdot</code>). We may provide a proper fix to this inconvenience in a subsequent release. </li>
<li>Each Fortran program using <code>librsb's</code> Sparse BLAS Implementation shall <code>use</code> modules <code><a class="el" href="namespaceblas__sparse.html">blas_sparse</a></code> and <code>rsb</code>. </li>
<li>Also Fortran programs have to call <a class="el" href="group__rsb__doc__rsb.html#gaf2b874d9f117ee6a6899634472b17946">rsb_lib_init()</a> and <a class="el" href="group__rsb__doc__rsb.html#ga86db30487afe975ed18a7aa6ee0db81d">rsb_lib_exit()</a> e.g.: <pre class="fragment">        USE blas_sparse             ! module implementing the Sparse BLAS on the top of librsb
        USE rsb                     ! rsb module
        ...
        INTEGER :: istat            ! integer variable
        ...
        istat = rsb_lib_init(RSB_NULL_INIT_OPTIONS) ! please note that this is not part of Sparse BLAS but it is needed by librsb
        if(istat.NE.0)STOP          ! a value different than zero signals an error
        ...
        ! code calling Sparse BLAS routines
        ...
        istat = rsb_lib_exit(RSB_NULL_EXIT_OPTIONS) ! please note that this is not part of Sparse BLAS but it is needed by librsb
        if(istat.NE.0)STOP          ! a value different than zero signals an error
        ...
</pre> </li>
<li>For Fortran, more procedures exist, although they are not documented here. According to the Sparse BLAS (<a href="http://www.netlib.org/blas/blast-forum/">http://www.netlib.org/blas/blast-forum/</a>), for almost each subroutine whose identifier prefixed with <code>blas_X</code> (with <code>X</code> being one of S,D,C,Z), a corresponding generic modern Fortran version exists. Please note how not all of the certain procedures identifier prefixes include the type character.</li>
</ul>
<p>E.g.: </p><div class="fragment"><div class="line">! the following code (<span class="charliteral">&#39;d&#39;</span> stays <span class="keywordflow">for</span> <span class="stringliteral">&#39;double precision&#39;</span>):</div><div class="line">CALL blas_duscr_begin(nr,nc,A,istat)</div><div class="line">CALL blas_ussp(A,<a class="code" href="blas__sparse_8h.html#a7da08ccc1c4c7f5ff40768d502a6e63baba96b7c19a0ccfe3be9d78cb27690487">blas_lower_symmetric</a>,istat)</div><div class="line">CALL blas_duscr_insert_entries(A,nnz,VA,IA,JA,istat)</div><div class="line">CALL blas_duscr_end(A,istat)</div><div class="line">CALL blas_dusmv(transT,alpha,A,X,incX,B,incB,istat) </div><div class="line">CALL blas_dusds(A,istat)</div><div class="line">! is equivalent to:</div><div class="line">CALL <a class="code" href="namespaceblas__sparse.html#acf14608f8b0375ca133b7f850bde3b50">duscr_begin</a>(nr,nc,A,istat) ! here, <span class="stringliteral">&#39;d&#39;</span> must be retained for avoiding ambiguity</div><div class="line">CALL <a class="code" href="namespaceblas__sparse.html#a469df92a4d25a9554fb1d79cdac1de84">ussp</a>(A,<a class="code" href="blas__sparse_8h.html#a7da08ccc1c4c7f5ff40768d502a6e63baba96b7c19a0ccfe3be9d78cb27690487">blas_lower_symmetric</a>,istat)</div><div class="line">CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)</div><div class="line">CALL <a class="code" href="namespaceblas__sparse.html#a48f1e1b82322910d45a1b2455421745f">uscr_end</a>(A,istat)</div><div class="line">CALL usmv(transT,alpha,A,X,incX,B,incB,istat) </div><div class="line">CALL <a class="code" href="namespaceblas__sparse.html#a8a3b6cd055048ab5e15b1b18be291f32">usds</a>(A,istat)</div></div><!-- fragment --> <h2 class="groupheader">Function Documentation</h2>
<a id="ga9512ccca0297deb504ef8a9c15eb32cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9512ccca0297deb504ef8a9c15eb32cf">&#9670;&nbsp;</a></span>BLAS_cusaxpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_cusaxpy </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a>&#160;</td>
          <td class="paramname"><em>index_base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse vector update: <img class="formulaInl" alt="$Y \leftarrow \alpha X + Y$" src="form_4.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements. </td></tr>
    <tr><td class="paramname">alpha</td><td>Will scale values of <img class="formulaInl" alt="$X$" src="form_3.png"/> before accumulating to <img class="formulaInl" alt="$Y$" src="form_2.png"/>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="gadbe35bc39022ca809f84f65982e8e40f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbe35bc39022ca809f84f65982e8e40f">&#9670;&nbsp;</a></span>blas_cusaxpy_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_cusaxpy_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *&#160;</td>
          <td class="paramname"><em>index_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse vector update: <img class="formulaInl" alt="$Y \leftarrow \alpha X + Y$" src="form_4.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements. </td></tr>
    <tr><td class="paramname">alpha</td><td>Will scale values of <img class="formulaInl" alt="$X$" src="form_3.png"/> before accumulating to <img class="formulaInl" alt="$Y$" src="form_2.png"/>.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="ga3483c364b4afec22621e46059b166247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3483c364b4afec22621e46059b166247">&#9670;&nbsp;</a></span>BLAS_cuscr_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> BLAS_cuscr_begin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates an empty matrix (A) and leaves it in build state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Is the count of rows. </td></tr>
    <tr><td class="paramname">n</td><td>Is the count of columns.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix handle in case of success, or -1 on error.</dd></dl>

</div>
</div>
<a id="gaf4d21720c592de22cfd4139517d9d255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4d21720c592de22cfd4139517d9d255">&#9670;&nbsp;</a></span>blas_cuscr_begin_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_cuscr_begin_ </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates an empty matrix (A) and leaves it in build state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Is the count of rows. </td></tr>
    <tr><td class="paramname">n</td><td>Is the count of columns.</td></tr>
    <tr><td class="paramname">A</td><td>A valid pointer to an empty matrix handle. </td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. Will assign a valid matrix handle to <img class="formulaInl" alt="$A$" src="form_21.png"/> in case of success, or set it to -1 on error.</dd></dl>

</div>
</div>
<a id="ga050218d0fa552a3e2c2d5452f876d9b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga050218d0fa552a3e2c2d5452f876d9b5">&#9670;&nbsp;</a></span>BLAS_cuscr_block_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> BLAS_cuscr_block_begin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates an empty matrix (A) and leaves it in build state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k,l</td><td>Are row and column dimensions when specifying a matrix as BCSR. </td></tr>
    <tr><td class="paramname">Mb</td><td>Block rows count. </td></tr>
    <tr><td class="paramname">Nb</td><td>Block columns count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix handle in case of success, or -1 on error.</dd></dl>

</div>
</div>
<a id="ga967bfc819ed66559e96ae55a6826d1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga967bfc819ed66559e96ae55a6826d1f8">&#9670;&nbsp;</a></span>blas_cuscr_block_begin_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_cuscr_block_begin_ </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates an empty matrix (A) and leaves it in build state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k,l</td><td>Are row and column dimensions when specifying a matrix as BCSR. </td></tr>
    <tr><td class="paramname">Mb</td><td>Block rows count. </td></tr>
    <tr><td class="paramname">Nb</td><td>Block columns count.</td></tr>
    <tr><td class="paramname">A</td><td>A valid pointer to an empty matrix handle. </td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. Will assign a valid matrix handle to <img class="formulaInl" alt="$A$" src="form_21.png"/> in case of success, or set it to -1 on error.</dd></dl>

</div>
</div>
<a id="gac2b5eccd5cf442b5e2e79201d62ca2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2b5eccd5cf442b5e2e79201d62ca2b5">&#9670;&nbsp;</a></span>BLAS_cuscr_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_cuscr_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes an assembled matrix out of a matrix in build state. After this, it is not possible anymore to insert nonzeroes, but computational routines. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="gaa78d3bef027e5a29ab5e5dd6188bcd75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa78d3bef027e5a29ab5e5dd6188bcd75">&#9670;&nbsp;</a></span>blas_cuscr_end_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_cuscr_end_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes an assembled matrix out of a matrix in build state. After this, it is not possible anymore to insert nonzeroes, but computational routines. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga42054351f49850f079733143b2af87fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42054351f49850f079733143b2af87fb">&#9670;&nbsp;</a></span>BLAS_cuscr_insert_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_cuscr_insert_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole block in a matrix, assuming it is in build state. The block size is assumed to be the one specified when calling the (type) corresponding matrix blocked <code>begin</code> function. If not called a blocked <code>begin</code> function, will assume 1x1 (that is, no) blocking. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">row_stride,col_stride</td><td>Row and column strides in accessing <code>val</code>. </td></tr>
    <tr><td class="paramname">i,j</td><td>Block row/column indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Signature of this routine for Fortran does not agree to the standard. This shall be corrected in a future release. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__rsb__doc__sparse__blas.html#ga050218d0fa552a3e2c2d5452f876d9b5">BLAS_cuscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga050218d0fa552a3e2c2d5452f876d9b5">BLAS_cuscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gac0ca32cd2c78c8553d6d6b324e06ef59">BLAS_duscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga5a261b2d1cc996c2a982ff8469faf286">BLAS_zuscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga3483c364b4afec22621e46059b166247">BLAS_cuscr_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gad9fe50c2e7a26e6ef83dfd3ea4cfcdd5">BLAS_suscr_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gac931dcb1129ee3016ab82602c3d14fee">BLAS_duscr_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga52b67393ad16e3d40e74fcdba88c7da4">BLAS_zuscr_begin</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga527ae15ee9e003d948494d9fcdad5dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga527ae15ee9e003d948494d9fcdad5dba">&#9670;&nbsp;</a></span>blas_cuscr_insert_block_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_cuscr_insert_block_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>row_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>col_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole block in a matrix, assuming it is in build state. The block size is assumed to be the one specified when calling the (type) corresponding matrix blocked <code>begin</code> function. If not called a blocked <code>begin</code> function, will assume 1x1 (that is, no) blocking. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">row_stride,col_stride</td><td>Row and column strides in accessing <code>val</code>. </td></tr>
    <tr><td class="paramname">i,j</td><td>Block row/column indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Signature of this routine for Fortran does not agree to the standard. This shall be corrected in a future release. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__rsb__doc__sparse__blas.html#ga050218d0fa552a3e2c2d5452f876d9b5">BLAS_cuscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga050218d0fa552a3e2c2d5452f876d9b5">BLAS_cuscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gac0ca32cd2c78c8553d6d6b324e06ef59">BLAS_duscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga5a261b2d1cc996c2a982ff8469faf286">BLAS_zuscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga3483c364b4afec22621e46059b166247">BLAS_cuscr_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gad9fe50c2e7a26e6ef83dfd3ea4cfcdd5">BLAS_suscr_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gac931dcb1129ee3016ab82602c3d14fee">BLAS_duscr_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga52b67393ad16e3d40e74fcdba88c7da4">BLAS_zuscr_begin</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gaf089aaac5d65a4e38130b25d5ba2ba27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf089aaac5d65a4e38130b25d5ba2ba27">&#9670;&nbsp;</a></span>BLAS_cuscr_insert_clique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_cuscr_insert_clique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>row_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>col_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>jndx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole clique in a matrix, assuming this is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">k,l</td><td>Clique rows and columns count. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">row_stride,col_stride</td><td>Row/columns stride in accessing the clique. </td></tr>
    <tr><td class="paramname">indx,jndx</td><td>Row/column indices arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Signature of this routine for Fortran does not agree to the standard. This shall be corrected in a future release.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga06acafbf28371b1ad8a75a85173261e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06acafbf28371b1ad8a75a85173261e6">&#9670;&nbsp;</a></span>blas_cuscr_insert_clique_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_cuscr_insert_clique_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>row_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>col_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>jndx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole clique in a matrix, assuming this is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">k,l</td><td>Clique rows and columns count. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">row_stride,col_stride</td><td>Row/columns stride in accessing the clique. </td></tr>
    <tr><td class="paramname">indx,jndx</td><td>Row/column indices arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Signature of this routine for Fortran does not agree to the standard. This shall be corrected in a future release.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga589495aa8acd4eac99ef9132bc4062c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga589495aa8acd4eac99ef9132bc4062c9">&#9670;&nbsp;</a></span>BLAS_cuscr_insert_col()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_cuscr_insert_col </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole column in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">j</td><td>Column index. </td></tr>
    <tr><td class="paramname">nnz</td><td>Number of nonzeroes to insert. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">indx</td><td>Row indices array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga1aadf4dc810ff6eb123a1bf9c859efe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1aadf4dc810ff6eb123a1bf9c859efe8">&#9670;&nbsp;</a></span>blas_cuscr_insert_col_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_cuscr_insert_col_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole column in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">j</td><td>Column index. </td></tr>
    <tr><td class="paramname">nnz</td><td>Number of nonzeroes to insert. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">indx</td><td>Row indices array.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga5af752a3fcb2898412f576eee7d9d618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5af752a3fcb2898412f576eee7d9d618">&#9670;&nbsp;</a></span>BLAS_cuscr_insert_entries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_cuscr_insert_entries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>jndx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts entries in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">nnz</td><td>Number of nonzeroes to insert. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">indx</td><td>Row indices array. </td></tr>
    <tr><td class="paramname">jndx</td><td>Column indices array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga3deb906fcd5f9b9221b5865541c57d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3deb906fcd5f9b9221b5865541c57d18">&#9670;&nbsp;</a></span>blas_cuscr_insert_entries_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_cuscr_insert_entries_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>jndx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts entries in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">nnz</td><td>Number of nonzeroes to insert. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">indx</td><td>Row indices array. </td></tr>
    <tr><td class="paramname">jndx</td><td>Column indices array.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gaa39564978ebda8a88f8d19e3e060bc4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa39564978ebda8a88f8d19e3e060bc4d">&#9670;&nbsp;</a></span>BLAS_cuscr_insert_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_cuscr_insert_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts an entry in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">i,j</td><td>Row and column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga6d735497bdd3bbafbb6168cb0fde5103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d735497bdd3bbafbb6168cb0fde5103">&#9670;&nbsp;</a></span>blas_cuscr_insert_entry_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_cuscr_insert_entry_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts an entry in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">i,j</td><td>Row and column indices.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga77929c94cee3278cc7594a3f1377f5f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77929c94cee3278cc7594a3f1377f5f8">&#9670;&nbsp;</a></span>BLAS_cuscr_insert_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_cuscr_insert_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole row in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">i</td><td>Row index. </td></tr>
    <tr><td class="paramname">nnz</td><td>Number of nonzeroes to insert. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">indx</td><td>Row index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="gad4acfbfdf33a5682ac657add0292711d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4acfbfdf33a5682ac657add0292711d">&#9670;&nbsp;</a></span>blas_cuscr_insert_row_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_cuscr_insert_row_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole row in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">i</td><td>Row index. </td></tr>
    <tr><td class="paramname">nnz</td><td>Number of nonzeroes to insert. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">indx</td><td>Row index.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga95174fcf3bfbef91ab6b3b85fc90b128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95174fcf3bfbef91ab6b3b85fc90b128">&#9670;&nbsp;</a></span>BLAS_cuscr_variable_block_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> BLAS_cuscr_variable_block_begin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates an empty matrix (A) and leaves it in build state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">K,L</td><td>Are arrays specifying row/column block sizes when specifying a matrix as VBR. </td></tr>
    <tr><td class="paramname">Mb</td><td>Block rows count. </td></tr>
    <tr><td class="paramname">Nb</td><td>Block columns count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix handle in case of success, or -1 on error.</dd></dl>

</div>
</div>
<a id="ga24a2dac4570e6021fdcc5c84b52fb5bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24a2dac4570e6021fdcc5c84b52fb5bb">&#9670;&nbsp;</a></span>blas_cuscr_variable_block_begin_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_cuscr_variable_block_begin_ </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates an empty matrix (A) and leaves it in build state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">K,L</td><td>Are arrays specifying row/column block sizes when specifying a matrix as VBR. </td></tr>
    <tr><td class="paramname">Mb</td><td>Block rows count. </td></tr>
    <tr><td class="paramname">Nb</td><td>Block columns count.</td></tr>
    <tr><td class="paramname">A</td><td>A valid pointer to an empty matrix handle. </td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. Will assign a valid matrix handle to <img class="formulaInl" alt="$A$" src="form_21.png"/> in case of success, or set it to -1 on error.</dd></dl>

</div>
</div>
<a id="ga4c01ce25e9923b35fc74edfdc269ddf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c01ce25e9923b35fc74edfdc269ddf9">&#9670;&nbsp;</a></span>BLAS_cusdot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_cusdot </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a125c156d54359fba48a6b9cf2a2d0a07">blas_conj_type</a>&#160;</td>
          <td class="paramname"><em>conj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a>&#160;</td>
          <td class="paramname"><em>index_base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse dot product. <img class="formulaInl" alt="$r \leftarrow X^T Y,$" src="form_0.png"/> <img class="formulaInl" alt="$r \leftarrow X^H Y$" src="form_1.png"/> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Sparse dot result array. </td></tr>
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements. </td></tr>
    <tr><td class="paramname">conj</td><td>If <a class="el" href="rsb__libspblas_8c.html#a125c156d54359fba48a6b9cf2a2d0a07a818f88453d90ea14a38c3f24ab9c47b1">blas_conj</a>, values of X will be considered conjugated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="ga10fc0f80f4e51078636cd5173510c3b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10fc0f80f4e51078636cd5173510c3b9">&#9670;&nbsp;</a></span>blas_cusdot_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_cusdot_ </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a125c156d54359fba48a6b9cf2a2d0a07">blas_conj_type</a> *&#160;</td>
          <td class="paramname"><em>conj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *&#160;</td>
          <td class="paramname"><em>index_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse dot product. <img class="formulaInl" alt="$r \leftarrow X^T Y,$" src="form_0.png"/> <img class="formulaInl" alt="$r \leftarrow X^H Y$" src="form_1.png"/> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Sparse dot result array. </td></tr>
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements. </td></tr>
    <tr><td class="paramname">conj</td><td>If <a class="el" href="rsb__libspblas_8c.html#a125c156d54359fba48a6b9cf2a2d0a07a818f88453d90ea14a38c3f24ab9c47b1">blas_conj</a>, values of X will be considered conjugated.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="gaf1aa846da09f16b6dd746b7d70dfe0db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1aa846da09f16b6dd746b7d70dfe0db">&#9670;&nbsp;</a></span>BLAS_cusga()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_cusga </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a>&#160;</td>
          <td class="paramname"><em>index_base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse gather. <img class="formulaInl" alt="$X \leftarrow Y |_x$" src="form_5.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements..</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="ga3232dc3a0844f917f4f6041990711bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3232dc3a0844f917f4f6041990711bea">&#9670;&nbsp;</a></span>blas_cusga_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_cusga_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *&#160;</td>
          <td class="paramname"><em>index_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse gather. <img class="formulaInl" alt="$X \leftarrow Y |_x$" src="form_5.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements..</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="ga4ec4b6dce3701c5803efa6b7455e1504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ec4b6dce3701c5803efa6b7455e1504">&#9670;&nbsp;</a></span>BLAS_cusget_diag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_cusget_diag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get matrix diagonal. <img class="formulaInl" alt="$d \leftarrow diag(A)$" src="form_22.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">d</td><td>Array for the diagonal entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga4865a8fda031074a0d91cf5c548584b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4865a8fda031074a0d91cf5c548584b9">&#9670;&nbsp;</a></span>blas_cusget_diag_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_cusget_diag_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get matrix diagonal. <img class="formulaInl" alt="$d \leftarrow diag(A)$" src="form_22.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">d</td><td>Array for the diagonal entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga984d3e91b376b8caed4a2b9711e761c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga984d3e91b376b8caed4a2b9711e761c5">&#9670;&nbsp;</a></span>BLAS_cusget_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_cusget_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a single matrix nonzero coefficient <img class="formulaInl" alt="$A_{i,j}$" src="form_23.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">i</td><td>Row index. </td></tr>
    <tr><td class="paramname">j</td><td>Column index. </td></tr>
    <tr><td class="paramname">v</td><td>Value pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga59f571fdb7f3c3919920c006bfff7bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59f571fdb7f3c3919920c006bfff7bee">&#9670;&nbsp;</a></span>blas_cusget_element_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_cusget_element_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a single matrix nonzero coefficient <img class="formulaInl" alt="$A_{i,j}$" src="form_23.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">i</td><td>Row index. </td></tr>
    <tr><td class="paramname">j</td><td>Column index. </td></tr>
    <tr><td class="paramname">v</td><td>Value pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga669fa319b6082b66dc786a4a72a9dbdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga669fa319b6082b66dc786a4a72a9dbdd">&#9670;&nbsp;</a></span>BLAS_cusget_infinity_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_cusget_infinity_norm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a>&#160;</td>
          <td class="paramname"><em>trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get infinity norm of matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">in</td><td>Infinity norm pointer. </td></tr>
    <tr><td class="paramname">trans</td><td>Transposition parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga403b439e35e4757f991771a3760ea699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga403b439e35e4757f991771a3760ea699">&#9670;&nbsp;</a></span>blas_cusget_infinity_norm_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_cusget_infinity_norm_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get infinity norm of matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">in</td><td>Infinity norm pointer. </td></tr>
    <tr><td class="paramname">trans</td><td>Transposition parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gafe27f3044269d37cadb569fc6796ac01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe27f3044269d37cadb569fc6796ac01">&#9670;&nbsp;</a></span>BLAS_cusget_matrix_nnz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_cusget_matrix_nnz </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get nnz count of matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">nnz</td><td>Output value pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga19e30bb70673342b4d6308bd9cf46884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19e30bb70673342b4d6308bd9cf46884">&#9670;&nbsp;</a></span>blas_cusget_matrix_nnz_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_cusget_matrix_nnz_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get nnz count of matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">nnz</td><td>Output value pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gacd5c5c70a203340db368b88296f21da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd5c5c70a203340db368b88296f21da5">&#9670;&nbsp;</a></span>BLAS_cusget_rows_nnz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_cusget_rows_nnz </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnzp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get nnz count of matrix row interval. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">fr</td><td>First row. </td></tr>
    <tr><td class="paramname">lr</td><td>Last row. </td></tr>
    <tr><td class="paramname">nnzp</td><td>Pointer to the nonzeroes variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="gaf474caab59f5a1c38954e1aabf0d1ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf474caab59f5a1c38954e1aabf0d1ff2">&#9670;&nbsp;</a></span>blas_cusget_rows_nnz_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_cusget_rows_nnz_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>lr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnzp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get nnz count of matrix row interval. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">fr</td><td>First row. </td></tr>
    <tr><td class="paramname">lr</td><td>Last row. </td></tr>
    <tr><td class="paramname">nnzp</td><td>Pointer to the nonzeroes variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gaa38bc05714f7a9c721cda9393f21723d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa38bc05714f7a9c721cda9393f21723d">&#9670;&nbsp;</a></span>BLAS_cusget_rows_sparse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_cusget_rows_sparse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>VA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>IA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>JA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get sparse rows of matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">VA</td><td>pointer to values. </td></tr>
    <tr><td class="paramname">IA</td><td>Row indices array. </td></tr>
    <tr><td class="paramname">JA</td><td>Column indices array. </td></tr>
    <tr><td class="paramname">nnz</td><td>Obtained nonzeroes. </td></tr>
    <tr><td class="paramname">fr</td><td>first row. </td></tr>
    <tr><td class="paramname">lr</td><td>Last row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga2f245b2d0ea2100c1eb100c60c0fe94d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f245b2d0ea2100c1eb100c60c0fe94d">&#9670;&nbsp;</a></span>blas_cusget_rows_sparse_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_cusget_rows_sparse_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>VA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>IA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>JA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>lr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get sparse rows of matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">VA</td><td>pointer to values. </td></tr>
    <tr><td class="paramname">IA</td><td>Row indices array. </td></tr>
    <tr><td class="paramname">JA</td><td>Column indices array. </td></tr>
    <tr><td class="paramname">nnz</td><td>Obtained nonzeroes. </td></tr>
    <tr><td class="paramname">fr</td><td>first row. </td></tr>
    <tr><td class="paramname">lr</td><td>Last row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gaffdbf96c998c35f21a97d017614789a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffdbf96c998c35f21a97d017614789a6">&#9670;&nbsp;</a></span>BLAS_cusgz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_cusgz </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a>&#160;</td>
          <td class="paramname"><em>index_base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse gather and zero. <img class="formulaInl" alt="$X \leftarrow Y |_x;Y|_x \leftarrow 0$" src="form_6.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements..</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="gac47b026c7bde968785c5d0e559fa086d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac47b026c7bde968785c5d0e559fa086d">&#9670;&nbsp;</a></span>blas_cusgz_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_cusgz_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *&#160;</td>
          <td class="paramname"><em>index_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse gather and zero. <img class="formulaInl" alt="$X \leftarrow Y |_x;Y|_x \leftarrow 0$" src="form_6.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements..</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="gae9a587087965874604ce9785f8660664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9a587087965874604ce9785f8660664">&#9670;&nbsp;</a></span>BLAS_cusmm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_cusmm </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a>&#160;</td>
          <td class="paramname"><em>transA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ldc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply by a dense matrix (aka multi-vector). Either of <img class="formulaInl" alt="$C \leftarrow \alpha AB+C,$" src="form_15.png"/> <img class="formulaInl" alt="$C \leftarrow \alpha A^T B+C,$" src="form_16.png"/> <img class="formulaInl" alt="$C \leftarrow \alpha A^H B+C$" src="form_17.png"/>, depending on the value of <code>transA</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>layour of the dense array. </td></tr>
    <tr><td class="paramname">transA</td><td>Transposition operator for matrix <em>A</em>. </td></tr>
    <tr><td class="paramname">nrhs</td><td>Number of right hand side columns. </td></tr>
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">b</td><td>Dense vector <em>b</em>. </td></tr>
    <tr><td class="paramname">ldb</td><td>Leading dimension of <em>b</em>. </td></tr>
    <tr><td class="paramname">c</td><td>Dense vector <em>c</em>. </td></tr>
    <tr><td class="paramname">ldc</td><td>Leading dimension of <em>c</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd></dd>
<dd>
</dd>
<dd>
By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ac88f907f61c86a61837a37274e2f97d4">blas_rsb_autotune_next_operation</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a> (at any time) the next multiplication routine call (either of <a class="el" href="group__rsb__doc__sparse__blas.html#gad018cf218c2c938bb5cf4577f1b53319">BLAS_dusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaf8193efe99bd255f8fcc4d72213c02d3">BLAS_susmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaba57464d66e3f29bc3177d480b0b6a54">BLAS_zusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacd371d9e8ab736cd4bd5e46973152bb5">BLAS_cusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga16a77093831bc32ccc056258d6f93445">BLAS_dusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacadd9208ad4a6a8d4ceab32ee173c6f4">BLAS_susmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga1d81f70e1fb15c3912006ed71a5cd471">BLAS_zusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gae9a587087965874604ce9785f8660664">BLAS_cusmm</a>) will invoke autotuning before carrying out the effective operation. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants. By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ae05ed12240987c33f90ee6cf012985a0">blas_rsb_spmv_autotuning_on</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a>, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply). This can be overridden only by setting the <code>RSB_NUM_THREADS</code> environment variable. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>On the topic of autotuning, see also <a class="el" href="group__rsb__doc__rsb.html#ga8c11024d248e2e686476fd9e89aa7c15">rsb_tune_spmm</a>. If <code>&ndash;enable-rsb-num-threads</code> has been specified at configure time, the <code>RSB_NUM_THREADS</code> environment variable will override the number of executing threads specified by <code>OMP_NUM_THREADS</code>. (See also <a class="el" href="group__rsb__doc__rsb.html#ggae0bada88731b01751401847d60110fb6ad9150d4d5672d1835185d6e2286d92f4">RSB_IO_WANT_EXECUTING_THREADS</a>).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="gaf359397dc85638f05255539befeda69c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf359397dc85638f05255539befeda69c">&#9670;&nbsp;</a></span>blas_cusmm_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_cusmm_ </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *&#160;</td>
          <td class="paramname"><em>transA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ldc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply by a dense matrix (aka multi-vector). Either of <img class="formulaInl" alt="$C \leftarrow \alpha AB+C,$" src="form_15.png"/> <img class="formulaInl" alt="$C \leftarrow \alpha A^T B+C,$" src="form_16.png"/> <img class="formulaInl" alt="$C \leftarrow \alpha A^H B+C$" src="form_17.png"/>, depending on the value of <code>transA</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>layour of the dense array. </td></tr>
    <tr><td class="paramname">transA</td><td>Transposition operator for matrix <em>A</em>. </td></tr>
    <tr><td class="paramname">nrhs</td><td>Number of right hand side columns. </td></tr>
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">b</td><td>Dense vector <em>b</em>. </td></tr>
    <tr><td class="paramname">ldb</td><td>Leading dimension of <em>b</em>. </td></tr>
    <tr><td class="paramname">c</td><td>Dense vector <em>c</em>. </td></tr>
    <tr><td class="paramname">ldc</td><td>Leading dimension of <em>c</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd></dd>
<dd>
</dd>
<dd>
By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ac88f907f61c86a61837a37274e2f97d4">blas_rsb_autotune_next_operation</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a> (at any time) the next multiplication routine call (either of <a class="el" href="group__rsb__doc__sparse__blas.html#gad018cf218c2c938bb5cf4577f1b53319">BLAS_dusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaf8193efe99bd255f8fcc4d72213c02d3">BLAS_susmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaba57464d66e3f29bc3177d480b0b6a54">BLAS_zusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacd371d9e8ab736cd4bd5e46973152bb5">BLAS_cusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga16a77093831bc32ccc056258d6f93445">BLAS_dusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacadd9208ad4a6a8d4ceab32ee173c6f4">BLAS_susmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga1d81f70e1fb15c3912006ed71a5cd471">BLAS_zusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gae9a587087965874604ce9785f8660664">BLAS_cusmm</a>) will invoke autotuning before carrying out the effective operation. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants. By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ae05ed12240987c33f90ee6cf012985a0">blas_rsb_spmv_autotuning_on</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a>, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply). This can be overridden only by setting the <code>RSB_NUM_THREADS</code> environment variable. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>On the topic of autotuning, see also <a class="el" href="group__rsb__doc__rsb.html#ga8c11024d248e2e686476fd9e89aa7c15">rsb_tune_spmm</a>. If <code>&ndash;enable-rsb-num-threads</code> has been specified at configure time, the <code>RSB_NUM_THREADS</code> environment variable will override the number of executing threads specified by <code>OMP_NUM_THREADS</code>. (See also <a class="el" href="group__rsb__doc__rsb.html#ggae0bada88731b01751401847d60110fb6ad9150d4d5672d1835185d6e2286d92f4">RSB_IO_WANT_EXECUTING_THREADS</a>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gacd371d9e8ab736cd4bd5e46973152bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd371d9e8ab736cd4bd5e46973152bb5">&#9670;&nbsp;</a></span>BLAS_cusmv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_cusmv </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a>&#160;</td>
          <td class="paramname"><em>transA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply by a dense vector. Either of <img class="formulaInl" alt="$Y \leftarrow \alpha A X + Y ,$" src="form_8.png"/> <img class="formulaInl" alt="$Y \leftarrow \alpha A^T X + Y,$" src="form_9.png"/> <img class="formulaInl" alt="$Y \leftarrow \alpha A^H X + Y$" src="form_10.png"/>, depending on the value of <code>transA</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transA</td><td>Transposition operator for matrix <em>A</em>. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">x</td><td>Dense vector <em>x</em>. </td></tr>
    <tr><td class="paramname">incx</td><td>Stride of <em>x</em>. </td></tr>
    <tr><td class="paramname">y</td><td>Dense vector <em>y</em>. </td></tr>
    <tr><td class="paramname">incy</td><td>Stride of <em>y</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd></dd>
<dd>
</dd>
<dd>
By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ac88f907f61c86a61837a37274e2f97d4">blas_rsb_autotune_next_operation</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a> (at any time) the next multiplication routine call (either of <a class="el" href="group__rsb__doc__sparse__blas.html#gad018cf218c2c938bb5cf4577f1b53319">BLAS_dusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaf8193efe99bd255f8fcc4d72213c02d3">BLAS_susmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaba57464d66e3f29bc3177d480b0b6a54">BLAS_zusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacd371d9e8ab736cd4bd5e46973152bb5">BLAS_cusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga16a77093831bc32ccc056258d6f93445">BLAS_dusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacadd9208ad4a6a8d4ceab32ee173c6f4">BLAS_susmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga1d81f70e1fb15c3912006ed71a5cd471">BLAS_zusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gae9a587087965874604ce9785f8660664">BLAS_cusmm</a>) will invoke autotuning before carrying out the effective operation. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants. By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ae05ed12240987c33f90ee6cf012985a0">blas_rsb_spmv_autotuning_on</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a>, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply). This can be overridden only by setting the <code>RSB_NUM_THREADS</code> environment variable. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>On the topic of autotuning, see also <a class="el" href="group__rsb__doc__rsb.html#ga8c11024d248e2e686476fd9e89aa7c15">rsb_tune_spmm</a>. If <code>&ndash;enable-rsb-num-threads</code> has been specified at configure time, the <code>RSB_NUM_THREADS</code> environment variable will override the number of executing threads specified by <code>OMP_NUM_THREADS</code>. (See also <a class="el" href="group__rsb__doc__rsb.html#ggae0bada88731b01751401847d60110fb6ad9150d4d5672d1835185d6e2286d92f4">RSB_IO_WANT_EXECUTING_THREADS</a>).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga7afc7a25cf8d4291b7821b5c3a6c16f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7afc7a25cf8d4291b7821b5c3a6c16f8">&#9670;&nbsp;</a></span>blas_cusmv_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_cusmv_ </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *&#160;</td>
          <td class="paramname"><em>transA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply by a dense vector. Either of <img class="formulaInl" alt="$Y \leftarrow \alpha A X + Y ,$" src="form_8.png"/> <img class="formulaInl" alt="$Y \leftarrow \alpha A^T X + Y,$" src="form_9.png"/> <img class="formulaInl" alt="$Y \leftarrow \alpha A^H X + Y$" src="form_10.png"/>, depending on the value of <code>transA</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transA</td><td>Transposition operator for matrix <em>A</em>. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">x</td><td>Dense vector <em>x</em>. </td></tr>
    <tr><td class="paramname">incx</td><td>Stride of <em>x</em>. </td></tr>
    <tr><td class="paramname">y</td><td>Dense vector <em>y</em>. </td></tr>
    <tr><td class="paramname">incy</td><td>Stride of <em>y</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd></dd>
<dd>
</dd>
<dd>
By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ac88f907f61c86a61837a37274e2f97d4">blas_rsb_autotune_next_operation</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a> (at any time) the next multiplication routine call (either of <a class="el" href="group__rsb__doc__sparse__blas.html#gad018cf218c2c938bb5cf4577f1b53319">BLAS_dusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaf8193efe99bd255f8fcc4d72213c02d3">BLAS_susmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaba57464d66e3f29bc3177d480b0b6a54">BLAS_zusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacd371d9e8ab736cd4bd5e46973152bb5">BLAS_cusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga16a77093831bc32ccc056258d6f93445">BLAS_dusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacadd9208ad4a6a8d4ceab32ee173c6f4">BLAS_susmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga1d81f70e1fb15c3912006ed71a5cd471">BLAS_zusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gae9a587087965874604ce9785f8660664">BLAS_cusmm</a>) will invoke autotuning before carrying out the effective operation. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants. By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ae05ed12240987c33f90ee6cf012985a0">blas_rsb_spmv_autotuning_on</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a>, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply). This can be overridden only by setting the <code>RSB_NUM_THREADS</code> environment variable. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>On the topic of autotuning, see also <a class="el" href="group__rsb__doc__rsb.html#ga8c11024d248e2e686476fd9e89aa7c15">rsb_tune_spmm</a>. If <code>&ndash;enable-rsb-num-threads</code> has been specified at configure time, the <code>RSB_NUM_THREADS</code> environment variable will override the number of executing threads specified by <code>OMP_NUM_THREADS</code>. (See also <a class="el" href="group__rsb__doc__rsb.html#ggae0bada88731b01751401847d60110fb6ad9150d4d5672d1835185d6e2286d92f4">RSB_IO_WANT_EXECUTING_THREADS</a>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga8a1339d836fe0bef40ee2ff2e0d23c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a1339d836fe0bef40ee2ff2e0d23c84">&#9670;&nbsp;</a></span>BLAS_cusrows_scale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_cusrows_scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a>&#160;</td>
          <td class="paramname"><em>trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale rows interval of matrix by specified factor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">d</td><td>Rows scaling vector. </td></tr>
    <tr><td class="paramname">trans</td><td>Transposition parameter (if transposed will scale columns). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga3161ba6800b4c19a825c6c649c04f10e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3161ba6800b4c19a825c6c649c04f10e">&#9670;&nbsp;</a></span>blas_cusrows_scale_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_cusrows_scale_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale rows interval of matrix by specified factor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">d</td><td>Rows scaling vector. </td></tr>
    <tr><td class="paramname">trans</td><td>Transposition parameter (if transposed will scale columns). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga41151f3f32daa645aa1ca4781aa19638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41151f3f32daa645aa1ca4781aa19638">&#9670;&nbsp;</a></span>BLAS_cussc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_cussc </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a>&#160;</td>
          <td class="paramname"><em>index_base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse scatter: <img class="formulaInl" alt="$Y |_x \leftarrow X$" src="form_7.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements..</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="ga3cab66955c8629f868c50218afb29ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cab66955c8629f868c50218afb29ee4">&#9670;&nbsp;</a></span>blas_cussc_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_cussc_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *&#160;</td>
          <td class="paramname"><em>index_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse scatter: <img class="formulaInl" alt="$Y |_x \leftarrow X$" src="form_7.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements..</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="ga0d1369eb0912f62315bdc8bfdce5b09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d1369eb0912f62315bdc8bfdce5b09b">&#9670;&nbsp;</a></span>BLAS_cusset_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_cusset_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a single (existing) matrix nonzero coefficient <img class="formulaInl" alt="$A_{i,j}$" src="form_23.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">i</td><td>Row index. </td></tr>
    <tr><td class="paramname">j</td><td>Column index. </td></tr>
    <tr><td class="paramname">v</td><td>Value pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga9e7eb89828c58961f655f8a64b09cda7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e7eb89828c58961f655f8a64b09cda7">&#9670;&nbsp;</a></span>blas_cusset_element_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_cusset_element_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a single (existing) matrix nonzero coefficient <img class="formulaInl" alt="$A_{i,j}$" src="form_23.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">i</td><td>Row index. </td></tr>
    <tr><td class="paramname">j</td><td>Column index. </td></tr>
    <tr><td class="paramname">v</td><td>Value pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gac3a9d2433be861bb29a10f361303a6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3a9d2433be861bb29a10f361303a6ff">&#9670;&nbsp;</a></span>BLAS_cusset_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_cusset_elements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ia</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ja</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nnz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set individual matrix nonzero coefficients values. The operation is pattern preserving, that is, nonzeroes must already exist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">ia</td><td>Row indices array. </td></tr>
    <tr><td class="paramname">ja</td><td>Column indices array. </td></tr>
    <tr><td class="paramname">va</td><td>Values array. </td></tr>
    <tr><td class="paramname">nnz</td><td>Length of the <code>ia</code>,ja,va arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality..</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga5fa110410ad828a27586b9f1dc68bc4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fa110410ad828a27586b9f1dc68bc4c">&#9670;&nbsp;</a></span>blas_cusset_elements_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_cusset_elements_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ia</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ja</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set individual matrix nonzero coefficients values. The operation is pattern preserving, that is, nonzeroes must already exist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">ia</td><td>Row indices array. </td></tr>
    <tr><td class="paramname">ja</td><td>Column indices array. </td></tr>
    <tr><td class="paramname">va</td><td>Values array. </td></tr>
    <tr><td class="paramname">nnz</td><td>Length of the <code>ia</code>,ja,va arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality..</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gaa4400d79fb5c85fdbcbc652a20f7cdc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4400d79fb5c85fdbcbc652a20f7cdc3">&#9670;&nbsp;</a></span>BLAS_cussm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_cussm </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a>&#160;</td>
          <td class="paramname"><em>transT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Triangular solve, by a dense matrix (aka multi-vector). Either of <img class="formulaInl" alt="$B \leftarrow \alpha T^{-1} B,$" src="form_18.png"/> <img class="formulaInl" alt="$B \leftarrow \alpha T^{-T} B,$" src="form_19.png"/> <img class="formulaInl" alt="$B \leftarrow \alpha T^{-H} B$" src="form_20.png"/>, depending on the value of <code>transT</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>layour of the dense array. </td></tr>
    <tr><td class="paramname">transT</td><td>Transposition operator for matrix <em>T</em>. </td></tr>
    <tr><td class="paramname">nrhs</td><td>Number of right hand side columns. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">T</td><td>A valid triangular matrix handle. </td></tr>
    <tr><td class="paramname">b</td><td>Dense vector <em>b</em>. </td></tr>
    <tr><td class="paramname">ldb</td><td>Leading dimension of <em>b</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="gadc0e3e469d5c619582251d0bab7c072d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc0e3e469d5c619582251d0bab7c072d">&#9670;&nbsp;</a></span>blas_cussm_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_cussm_ </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *&#160;</td>
          <td class="paramname"><em>transT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Triangular solve, by a dense matrix (aka multi-vector). Either of <img class="formulaInl" alt="$B \leftarrow \alpha T^{-1} B,$" src="form_18.png"/> <img class="formulaInl" alt="$B \leftarrow \alpha T^{-T} B,$" src="form_19.png"/> <img class="formulaInl" alt="$B \leftarrow \alpha T^{-H} B$" src="form_20.png"/>, depending on the value of <code>transT</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>layour of the dense array. </td></tr>
    <tr><td class="paramname">transT</td><td>Transposition operator for matrix <em>T</em>. </td></tr>
    <tr><td class="paramname">nrhs</td><td>Number of right hand side columns. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">T</td><td>A valid triangular matrix handle. </td></tr>
    <tr><td class="paramname">b</td><td>Dense vector <em>b</em>. </td></tr>
    <tr><td class="paramname">ldb</td><td>Leading dimension of <em>b</em>.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga6d075495d355608bff64aa5802789266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d075495d355608bff64aa5802789266">&#9670;&nbsp;</a></span>BLAS_cussv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_cussv </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a>&#160;</td>
          <td class="paramname"><em>transT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Triangular solve, by a dense vector. Either of <img class="formulaInl" alt="$X \leftarrow \alpha T^{-1}X,$" src="form_12.png"/> <img class="formulaInl" alt="$X \leftarrow \alpha T^{-T}X,$" src="form_13.png"/> <img class="formulaInl" alt="$X \leftarrow \alpha T^{-H}X$" src="form_14.png"/>, depending on the value of <code>transT</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transT</td><td>Transposition operator for matrix <em>T</em>. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">T</td><td>A valid triangular matrix handle. </td></tr>
    <tr><td class="paramname">x</td><td>Dense vector <em>x</em>. </td></tr>
    <tr><td class="paramname">incx</td><td>Stride of <em>x</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="gabc0c4d042a0b07a7e743ad09e593b7e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc0c4d042a0b07a7e743ad09e593b7e9">&#9670;&nbsp;</a></span>blas_cussv_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_cussv_ </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *&#160;</td>
          <td class="paramname"><em>transT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Triangular solve, by a dense vector. Either of <img class="formulaInl" alt="$X \leftarrow \alpha T^{-1}X,$" src="form_12.png"/> <img class="formulaInl" alt="$X \leftarrow \alpha T^{-T}X,$" src="form_13.png"/> <img class="formulaInl" alt="$X \leftarrow \alpha T^{-H}X$" src="form_14.png"/>, depending on the value of <code>transT</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transT</td><td>Transposition operator for matrix <em>T</em>. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">T</td><td>A valid triangular matrix handle. </td></tr>
    <tr><td class="paramname">x</td><td>Dense vector <em>x</em>. </td></tr>
    <tr><td class="paramname">incx</td><td>Stride of <em>x</em>.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gad881a3b5aaa54c05badefa59d9a46ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad881a3b5aaa54c05badefa59d9a46ca3">&#9670;&nbsp;</a></span>BLAS_dusaxpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_dusaxpy </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a>&#160;</td>
          <td class="paramname"><em>index_base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse vector update: <img class="formulaInl" alt="$Y \leftarrow \alpha X + Y$" src="form_4.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements. </td></tr>
    <tr><td class="paramname">alpha</td><td>Will scale values of <img class="formulaInl" alt="$X$" src="form_3.png"/> before accumulating to <img class="formulaInl" alt="$Y$" src="form_2.png"/>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="ga1745b7ce9014a8d32a6d954d6ce3bd87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1745b7ce9014a8d32a6d954d6ce3bd87">&#9670;&nbsp;</a></span>blas_dusaxpy_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_dusaxpy_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *&#160;</td>
          <td class="paramname"><em>index_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse vector update: <img class="formulaInl" alt="$Y \leftarrow \alpha X + Y$" src="form_4.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements. </td></tr>
    <tr><td class="paramname">alpha</td><td>Will scale values of <img class="formulaInl" alt="$X$" src="form_3.png"/> before accumulating to <img class="formulaInl" alt="$Y$" src="form_2.png"/>.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="gac931dcb1129ee3016ab82602c3d14fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac931dcb1129ee3016ab82602c3d14fee">&#9670;&nbsp;</a></span>BLAS_duscr_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> BLAS_duscr_begin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates an empty matrix (A) and leaves it in build state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Is the count of rows. </td></tr>
    <tr><td class="paramname">n</td><td>Is the count of columns.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix handle in case of success, or -1 on error.</dd></dl>

</div>
</div>
<a id="gad7d5969e9edee49441fc89d22715e60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7d5969e9edee49441fc89d22715e60d">&#9670;&nbsp;</a></span>blas_duscr_begin_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_duscr_begin_ </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates an empty matrix (A) and leaves it in build state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Is the count of rows. </td></tr>
    <tr><td class="paramname">n</td><td>Is the count of columns.</td></tr>
    <tr><td class="paramname">A</td><td>A valid pointer to an empty matrix handle. </td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. Will assign a valid matrix handle to <img class="formulaInl" alt="$A$" src="form_21.png"/> in case of success, or set it to -1 on error.</dd></dl>

</div>
</div>
<a id="gac0ca32cd2c78c8553d6d6b324e06ef59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0ca32cd2c78c8553d6d6b324e06ef59">&#9670;&nbsp;</a></span>BLAS_duscr_block_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> BLAS_duscr_block_begin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates an empty matrix (A) and leaves it in build state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k,l</td><td>Are row and column dimensions when specifying a matrix as BCSR. </td></tr>
    <tr><td class="paramname">Mb</td><td>Block rows count. </td></tr>
    <tr><td class="paramname">Nb</td><td>Block columns count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix handle in case of success, or -1 on error.</dd></dl>

</div>
</div>
<a id="ga864facf0316453a27af4b7024a11453b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga864facf0316453a27af4b7024a11453b">&#9670;&nbsp;</a></span>blas_duscr_block_begin_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_duscr_block_begin_ </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates an empty matrix (A) and leaves it in build state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k,l</td><td>Are row and column dimensions when specifying a matrix as BCSR. </td></tr>
    <tr><td class="paramname">Mb</td><td>Block rows count. </td></tr>
    <tr><td class="paramname">Nb</td><td>Block columns count.</td></tr>
    <tr><td class="paramname">A</td><td>A valid pointer to an empty matrix handle. </td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. Will assign a valid matrix handle to <img class="formulaInl" alt="$A$" src="form_21.png"/> in case of success, or set it to -1 on error.</dd></dl>

</div>
</div>
<a id="ga5d9ce97bf054b1e3750eaae5d4e6c335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d9ce97bf054b1e3750eaae5d4e6c335">&#9670;&nbsp;</a></span>BLAS_duscr_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_duscr_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes an assembled matrix out of a matrix in build state. After this, it is not possible anymore to insert nonzeroes, but computational routines. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga2120eb06b87f0e85d03a368e5bc55485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2120eb06b87f0e85d03a368e5bc55485">&#9670;&nbsp;</a></span>blas_duscr_end_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_duscr_end_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes an assembled matrix out of a matrix in build state. After this, it is not possible anymore to insert nonzeroes, but computational routines. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga5d35aa3e27cdbf8a50db5b47ff5e0892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d35aa3e27cdbf8a50db5b47ff5e0892">&#9670;&nbsp;</a></span>BLAS_duscr_insert_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_duscr_insert_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole block in a matrix, assuming it is in build state. The block size is assumed to be the one specified when calling the (type) corresponding matrix blocked <code>begin</code> function. If not called a blocked <code>begin</code> function, will assume 1x1 (that is, no) blocking. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">row_stride,col_stride</td><td>Row and column strides in accessing <code>val</code>. </td></tr>
    <tr><td class="paramname">i,j</td><td>Block row/column indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Signature of this routine for Fortran does not agree to the standard. This shall be corrected in a future release. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__rsb__doc__sparse__blas.html#ga050218d0fa552a3e2c2d5452f876d9b5">BLAS_cuscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga050218d0fa552a3e2c2d5452f876d9b5">BLAS_cuscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gac0ca32cd2c78c8553d6d6b324e06ef59">BLAS_duscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga5a261b2d1cc996c2a982ff8469faf286">BLAS_zuscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga3483c364b4afec22621e46059b166247">BLAS_cuscr_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gad9fe50c2e7a26e6ef83dfd3ea4cfcdd5">BLAS_suscr_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gac931dcb1129ee3016ab82602c3d14fee">BLAS_duscr_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga52b67393ad16e3d40e74fcdba88c7da4">BLAS_zuscr_begin</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga38012bbc4e99df72fb95409a4860ead7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38012bbc4e99df72fb95409a4860ead7">&#9670;&nbsp;</a></span>blas_duscr_insert_block_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_duscr_insert_block_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>row_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>col_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole block in a matrix, assuming it is in build state. The block size is assumed to be the one specified when calling the (type) corresponding matrix blocked <code>begin</code> function. If not called a blocked <code>begin</code> function, will assume 1x1 (that is, no) blocking. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">row_stride,col_stride</td><td>Row and column strides in accessing <code>val</code>. </td></tr>
    <tr><td class="paramname">i,j</td><td>Block row/column indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Signature of this routine for Fortran does not agree to the standard. This shall be corrected in a future release. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__rsb__doc__sparse__blas.html#ga050218d0fa552a3e2c2d5452f876d9b5">BLAS_cuscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga050218d0fa552a3e2c2d5452f876d9b5">BLAS_cuscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gac0ca32cd2c78c8553d6d6b324e06ef59">BLAS_duscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga5a261b2d1cc996c2a982ff8469faf286">BLAS_zuscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga3483c364b4afec22621e46059b166247">BLAS_cuscr_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gad9fe50c2e7a26e6ef83dfd3ea4cfcdd5">BLAS_suscr_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gac931dcb1129ee3016ab82602c3d14fee">BLAS_duscr_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga52b67393ad16e3d40e74fcdba88c7da4">BLAS_zuscr_begin</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga290547e34be3648b2fe6a7378e59a7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga290547e34be3648b2fe6a7378e59a7ec">&#9670;&nbsp;</a></span>BLAS_duscr_insert_clique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_duscr_insert_clique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>row_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>col_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>jndx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole clique in a matrix, assuming this is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">k,l</td><td>Clique rows and columns count. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">row_stride,col_stride</td><td>Row/columns stride in accessing the clique. </td></tr>
    <tr><td class="paramname">indx,jndx</td><td>Row/column indices arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Signature of this routine for Fortran does not agree to the standard. This shall be corrected in a future release.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga1f7870f8a1114b94444c721c933e8bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f7870f8a1114b94444c721c933e8bef">&#9670;&nbsp;</a></span>blas_duscr_insert_clique_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_duscr_insert_clique_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>row_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>col_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>jndx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole clique in a matrix, assuming this is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">k,l</td><td>Clique rows and columns count. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">row_stride,col_stride</td><td>Row/columns stride in accessing the clique. </td></tr>
    <tr><td class="paramname">indx,jndx</td><td>Row/column indices arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Signature of this routine for Fortran does not agree to the standard. This shall be corrected in a future release.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga8ee73d3b27bdc68e12c85ba281a337be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ee73d3b27bdc68e12c85ba281a337be">&#9670;&nbsp;</a></span>BLAS_duscr_insert_col()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_duscr_insert_col </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole column in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">j</td><td>Column index. </td></tr>
    <tr><td class="paramname">nnz</td><td>Number of nonzeroes to insert. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">indx</td><td>Row indices array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga5645393bb00d715d882e8e2d55c3f0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5645393bb00d715d882e8e2d55c3f0d1">&#9670;&nbsp;</a></span>blas_duscr_insert_col_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_duscr_insert_col_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole column in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">j</td><td>Column index. </td></tr>
    <tr><td class="paramname">nnz</td><td>Number of nonzeroes to insert. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">indx</td><td>Row indices array.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gae0683bc8f0af5dd3e53b964190f9e1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0683bc8f0af5dd3e53b964190f9e1b4">&#9670;&nbsp;</a></span>BLAS_duscr_insert_entries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_duscr_insert_entries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>jndx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts entries in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">nnz</td><td>Number of nonzeroes to insert. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">indx</td><td>Row indices array. </td></tr>
    <tr><td class="paramname">jndx</td><td>Column indices array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="gac2c1a4c7b2cebca56aedbad7a002e15f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2c1a4c7b2cebca56aedbad7a002e15f">&#9670;&nbsp;</a></span>blas_duscr_insert_entries_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_duscr_insert_entries_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>jndx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts entries in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">nnz</td><td>Number of nonzeroes to insert. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">indx</td><td>Row indices array. </td></tr>
    <tr><td class="paramname">jndx</td><td>Column indices array.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga346ff5263bf0b3a5d7dda94e2000130c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga346ff5263bf0b3a5d7dda94e2000130c">&#9670;&nbsp;</a></span>BLAS_duscr_insert_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_duscr_insert_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts an entry in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">i,j</td><td>Row and column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga29c2f202a144845cc1d32c8d65bd5c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29c2f202a144845cc1d32c8d65bd5c5f">&#9670;&nbsp;</a></span>blas_duscr_insert_entry_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_duscr_insert_entry_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts an entry in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">i,j</td><td>Row and column indices.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gac3472ca6b036771a68d6f5f01387e482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3472ca6b036771a68d6f5f01387e482">&#9670;&nbsp;</a></span>BLAS_duscr_insert_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_duscr_insert_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole row in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">i</td><td>Row index. </td></tr>
    <tr><td class="paramname">nnz</td><td>Number of nonzeroes to insert. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">indx</td><td>Row index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="gaa72e5450302fa424dcd6cfae0bad872d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa72e5450302fa424dcd6cfae0bad872d">&#9670;&nbsp;</a></span>blas_duscr_insert_row_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_duscr_insert_row_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole row in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">i</td><td>Row index. </td></tr>
    <tr><td class="paramname">nnz</td><td>Number of nonzeroes to insert. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">indx</td><td>Row index.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gae0c3c6dc5503e21afb8192efb0f66edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0c3c6dc5503e21afb8192efb0f66edd">&#9670;&nbsp;</a></span>BLAS_duscr_variable_block_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> BLAS_duscr_variable_block_begin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates an empty matrix (A) and leaves it in build state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">K,L</td><td>Are arrays specifying row/column block sizes when specifying a matrix as VBR. </td></tr>
    <tr><td class="paramname">Mb</td><td>Block rows count. </td></tr>
    <tr><td class="paramname">Nb</td><td>Block columns count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix handle in case of success, or -1 on error.</dd></dl>

</div>
</div>
<a id="ga12c7c1bdd46724147dbbd9b38dd2028e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12c7c1bdd46724147dbbd9b38dd2028e">&#9670;&nbsp;</a></span>blas_duscr_variable_block_begin_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_duscr_variable_block_begin_ </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates an empty matrix (A) and leaves it in build state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">K,L</td><td>Are arrays specifying row/column block sizes when specifying a matrix as VBR. </td></tr>
    <tr><td class="paramname">Mb</td><td>Block rows count. </td></tr>
    <tr><td class="paramname">Nb</td><td>Block columns count.</td></tr>
    <tr><td class="paramname">A</td><td>A valid pointer to an empty matrix handle. </td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. Will assign a valid matrix handle to <img class="formulaInl" alt="$A$" src="form_21.png"/> in case of success, or set it to -1 on error.</dd></dl>

</div>
</div>
<a id="ga2b636bea0fc01655c2e61cc83df49875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b636bea0fc01655c2e61cc83df49875">&#9670;&nbsp;</a></span>BLAS_dusdot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_dusdot </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a125c156d54359fba48a6b9cf2a2d0a07">blas_conj_type</a>&#160;</td>
          <td class="paramname"><em>conj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a>&#160;</td>
          <td class="paramname"><em>index_base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse dot product. <img class="formulaInl" alt="$r \leftarrow X^T Y,$" src="form_0.png"/> <img class="formulaInl" alt="$r \leftarrow X^H Y$" src="form_1.png"/> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Sparse dot result array. </td></tr>
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements. </td></tr>
    <tr><td class="paramname">conj</td><td>If <a class="el" href="rsb__libspblas_8c.html#a125c156d54359fba48a6b9cf2a2d0a07a818f88453d90ea14a38c3f24ab9c47b1">blas_conj</a>, values of X will be considered conjugated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="ga6af9e342a35e6b3a626da8abadf4d1bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6af9e342a35e6b3a626da8abadf4d1bb">&#9670;&nbsp;</a></span>blas_dusdot_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_dusdot_ </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a125c156d54359fba48a6b9cf2a2d0a07">blas_conj_type</a> *&#160;</td>
          <td class="paramname"><em>conj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *&#160;</td>
          <td class="paramname"><em>index_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse dot product. <img class="formulaInl" alt="$r \leftarrow X^T Y,$" src="form_0.png"/> <img class="formulaInl" alt="$r \leftarrow X^H Y$" src="form_1.png"/> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Sparse dot result array. </td></tr>
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements. </td></tr>
    <tr><td class="paramname">conj</td><td>If <a class="el" href="rsb__libspblas_8c.html#a125c156d54359fba48a6b9cf2a2d0a07a818f88453d90ea14a38c3f24ab9c47b1">blas_conj</a>, values of X will be considered conjugated.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="ga3fe2f6377727c483e79fc81cc40d0c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fe2f6377727c483e79fc81cc40d0c9c">&#9670;&nbsp;</a></span>BLAS_dusga()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_dusga </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a>&#160;</td>
          <td class="paramname"><em>index_base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse gather. <img class="formulaInl" alt="$X \leftarrow Y |_x$" src="form_5.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements..</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="gad9abd75bb1658d5e400aa15346af9a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9abd75bb1658d5e400aa15346af9a67">&#9670;&nbsp;</a></span>blas_dusga_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_dusga_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *&#160;</td>
          <td class="paramname"><em>index_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse gather. <img class="formulaInl" alt="$X \leftarrow Y |_x$" src="form_5.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements..</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="ga35b70a7c3083b791cf1b94cb20ef57be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35b70a7c3083b791cf1b94cb20ef57be">&#9670;&nbsp;</a></span>BLAS_dusget_diag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_dusget_diag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get matrix diagonal. <img class="formulaInl" alt="$d \leftarrow diag(A)$" src="form_22.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">d</td><td>Array for the diagonal entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga7cfde04c833adeb887db75f4b2e104dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cfde04c833adeb887db75f4b2e104dd">&#9670;&nbsp;</a></span>blas_dusget_diag_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_dusget_diag_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get matrix diagonal. <img class="formulaInl" alt="$d \leftarrow diag(A)$" src="form_22.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">d</td><td>Array for the diagonal entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga7cdfc09a860b29267539c4868f41ec51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cdfc09a860b29267539c4868f41ec51">&#9670;&nbsp;</a></span>BLAS_dusget_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_dusget_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a single matrix nonzero coefficient <img class="formulaInl" alt="$A_{i,j}$" src="form_23.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">i</td><td>Row index. </td></tr>
    <tr><td class="paramname">j</td><td>Column index. </td></tr>
    <tr><td class="paramname">v</td><td>Value pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga58daa61154a8bc683070a2082584e878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58daa61154a8bc683070a2082584e878">&#9670;&nbsp;</a></span>blas_dusget_element_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_dusget_element_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a single matrix nonzero coefficient <img class="formulaInl" alt="$A_{i,j}$" src="form_23.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">i</td><td>Row index. </td></tr>
    <tr><td class="paramname">j</td><td>Column index. </td></tr>
    <tr><td class="paramname">v</td><td>Value pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga497f00123d42a278c3b5332a5d0021f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga497f00123d42a278c3b5332a5d0021f6">&#9670;&nbsp;</a></span>BLAS_dusget_infinity_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_dusget_infinity_norm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a>&#160;</td>
          <td class="paramname"><em>trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get infinity norm of matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">in</td><td>Infinity norm pointer. </td></tr>
    <tr><td class="paramname">trans</td><td>Transposition parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="gad4e31e05708dac4fc74ab200cfc94f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4e31e05708dac4fc74ab200cfc94f80">&#9670;&nbsp;</a></span>blas_dusget_infinity_norm_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_dusget_infinity_norm_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get infinity norm of matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">in</td><td>Infinity norm pointer. </td></tr>
    <tr><td class="paramname">trans</td><td>Transposition parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga441bff94fdc50b9bf6e180d36f51c3ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga441bff94fdc50b9bf6e180d36f51c3ce">&#9670;&nbsp;</a></span>BLAS_dusget_matrix_nnz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_dusget_matrix_nnz </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get nnz count of matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">nnz</td><td>Output value pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga3a4bc573dc07849e7a72ecb2d2f0c31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a4bc573dc07849e7a72ecb2d2f0c31d">&#9670;&nbsp;</a></span>blas_dusget_matrix_nnz_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_dusget_matrix_nnz_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get nnz count of matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">nnz</td><td>Output value pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gafb047adeebbb38d542a650c0b935b307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb047adeebbb38d542a650c0b935b307">&#9670;&nbsp;</a></span>BLAS_dusget_rows_nnz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_dusget_rows_nnz </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnzp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get nnz count of matrix row interval. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">fr</td><td>First row. </td></tr>
    <tr><td class="paramname">lr</td><td>Last row. </td></tr>
    <tr><td class="paramname">nnzp</td><td>Pointer to the nonzeroes variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="gaa04899898ad27f1aaed04518988764c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa04899898ad27f1aaed04518988764c9">&#9670;&nbsp;</a></span>blas_dusget_rows_nnz_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_dusget_rows_nnz_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>lr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnzp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get nnz count of matrix row interval. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">fr</td><td>First row. </td></tr>
    <tr><td class="paramname">lr</td><td>Last row. </td></tr>
    <tr><td class="paramname">nnzp</td><td>Pointer to the nonzeroes variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga99093b2c9c92aa5b0805a136fcd0e2c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99093b2c9c92aa5b0805a136fcd0e2c3">&#9670;&nbsp;</a></span>BLAS_dusget_rows_sparse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_dusget_rows_sparse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>VA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>IA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>JA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get sparse rows of matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">VA</td><td>pointer to values. </td></tr>
    <tr><td class="paramname">IA</td><td>Row indices array. </td></tr>
    <tr><td class="paramname">JA</td><td>Column indices array. </td></tr>
    <tr><td class="paramname">nnz</td><td>Obtained nonzeroes. </td></tr>
    <tr><td class="paramname">fr</td><td>first row. </td></tr>
    <tr><td class="paramname">lr</td><td>Last row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga1be827257216ff2f84b1c9394f00ca60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1be827257216ff2f84b1c9394f00ca60">&#9670;&nbsp;</a></span>blas_dusget_rows_sparse_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_dusget_rows_sparse_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>VA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>IA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>JA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>lr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get sparse rows of matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">VA</td><td>pointer to values. </td></tr>
    <tr><td class="paramname">IA</td><td>Row indices array. </td></tr>
    <tr><td class="paramname">JA</td><td>Column indices array. </td></tr>
    <tr><td class="paramname">nnz</td><td>Obtained nonzeroes. </td></tr>
    <tr><td class="paramname">fr</td><td>first row. </td></tr>
    <tr><td class="paramname">lr</td><td>Last row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gacce24efbb85dacafbce4a726ec1e3a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacce24efbb85dacafbce4a726ec1e3a55">&#9670;&nbsp;</a></span>BLAS_dusgz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_dusgz </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a>&#160;</td>
          <td class="paramname"><em>index_base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse gather and zero. <img class="formulaInl" alt="$X \leftarrow Y |_x;Y|_x \leftarrow 0$" src="form_6.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements..</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="ga2e8dee47e7855a130b6896b020209b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e8dee47e7855a130b6896b020209b5e">&#9670;&nbsp;</a></span>blas_dusgz_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_dusgz_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *&#160;</td>
          <td class="paramname"><em>index_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse gather and zero. <img class="formulaInl" alt="$X \leftarrow Y |_x;Y|_x \leftarrow 0$" src="form_6.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements..</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="ga16a77093831bc32ccc056258d6f93445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16a77093831bc32ccc056258d6f93445">&#9670;&nbsp;</a></span>BLAS_dusmm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_dusmm </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a>&#160;</td>
          <td class="paramname"><em>transA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ldc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply by a dense matrix (aka multi-vector). Either of <img class="formulaInl" alt="$C \leftarrow \alpha AB+C,$" src="form_15.png"/> <img class="formulaInl" alt="$C \leftarrow \alpha A^T B+C,$" src="form_16.png"/> <img class="formulaInl" alt="$C \leftarrow \alpha A^H B+C$" src="form_17.png"/>, depending on the value of <code>transA</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>layour of the dense array. </td></tr>
    <tr><td class="paramname">transA</td><td>Transposition operator for matrix <em>A</em>. </td></tr>
    <tr><td class="paramname">nrhs</td><td>Number of right hand side columns. </td></tr>
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">b</td><td>Dense vector <em>b</em>. </td></tr>
    <tr><td class="paramname">ldb</td><td>Leading dimension of <em>b</em>. </td></tr>
    <tr><td class="paramname">c</td><td>Dense vector <em>c</em>. </td></tr>
    <tr><td class="paramname">ldc</td><td>Leading dimension of <em>c</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd></dd>
<dd>
</dd>
<dd>
By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ac88f907f61c86a61837a37274e2f97d4">blas_rsb_autotune_next_operation</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a> (at any time) the next multiplication routine call (either of <a class="el" href="group__rsb__doc__sparse__blas.html#gad018cf218c2c938bb5cf4577f1b53319">BLAS_dusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaf8193efe99bd255f8fcc4d72213c02d3">BLAS_susmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaba57464d66e3f29bc3177d480b0b6a54">BLAS_zusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacd371d9e8ab736cd4bd5e46973152bb5">BLAS_cusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga16a77093831bc32ccc056258d6f93445">BLAS_dusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacadd9208ad4a6a8d4ceab32ee173c6f4">BLAS_susmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga1d81f70e1fb15c3912006ed71a5cd471">BLAS_zusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gae9a587087965874604ce9785f8660664">BLAS_cusmm</a>) will invoke autotuning before carrying out the effective operation. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants. By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ae05ed12240987c33f90ee6cf012985a0">blas_rsb_spmv_autotuning_on</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a>, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply). This can be overridden only by setting the <code>RSB_NUM_THREADS</code> environment variable. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>On the topic of autotuning, see also <a class="el" href="group__rsb__doc__rsb.html#ga8c11024d248e2e686476fd9e89aa7c15">rsb_tune_spmm</a>. If <code>&ndash;enable-rsb-num-threads</code> has been specified at configure time, the <code>RSB_NUM_THREADS</code> environment variable will override the number of executing threads specified by <code>OMP_NUM_THREADS</code>. (See also <a class="el" href="group__rsb__doc__rsb.html#ggae0bada88731b01751401847d60110fb6ad9150d4d5672d1835185d6e2286d92f4">RSB_IO_WANT_EXECUTING_THREADS</a>).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga6399d807d81b53aca98fa6041d42b120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6399d807d81b53aca98fa6041d42b120">&#9670;&nbsp;</a></span>blas_dusmm_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_dusmm_ </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *&#160;</td>
          <td class="paramname"><em>transA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ldc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply by a dense matrix (aka multi-vector). Either of <img class="formulaInl" alt="$C \leftarrow \alpha AB+C,$" src="form_15.png"/> <img class="formulaInl" alt="$C \leftarrow \alpha A^T B+C,$" src="form_16.png"/> <img class="formulaInl" alt="$C \leftarrow \alpha A^H B+C$" src="form_17.png"/>, depending on the value of <code>transA</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>layour of the dense array. </td></tr>
    <tr><td class="paramname">transA</td><td>Transposition operator for matrix <em>A</em>. </td></tr>
    <tr><td class="paramname">nrhs</td><td>Number of right hand side columns. </td></tr>
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">b</td><td>Dense vector <em>b</em>. </td></tr>
    <tr><td class="paramname">ldb</td><td>Leading dimension of <em>b</em>. </td></tr>
    <tr><td class="paramname">c</td><td>Dense vector <em>c</em>. </td></tr>
    <tr><td class="paramname">ldc</td><td>Leading dimension of <em>c</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd></dd>
<dd>
</dd>
<dd>
By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ac88f907f61c86a61837a37274e2f97d4">blas_rsb_autotune_next_operation</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a> (at any time) the next multiplication routine call (either of <a class="el" href="group__rsb__doc__sparse__blas.html#gad018cf218c2c938bb5cf4577f1b53319">BLAS_dusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaf8193efe99bd255f8fcc4d72213c02d3">BLAS_susmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaba57464d66e3f29bc3177d480b0b6a54">BLAS_zusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacd371d9e8ab736cd4bd5e46973152bb5">BLAS_cusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga16a77093831bc32ccc056258d6f93445">BLAS_dusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacadd9208ad4a6a8d4ceab32ee173c6f4">BLAS_susmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga1d81f70e1fb15c3912006ed71a5cd471">BLAS_zusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gae9a587087965874604ce9785f8660664">BLAS_cusmm</a>) will invoke autotuning before carrying out the effective operation. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants. By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ae05ed12240987c33f90ee6cf012985a0">blas_rsb_spmv_autotuning_on</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a>, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply). This can be overridden only by setting the <code>RSB_NUM_THREADS</code> environment variable. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>On the topic of autotuning, see also <a class="el" href="group__rsb__doc__rsb.html#ga8c11024d248e2e686476fd9e89aa7c15">rsb_tune_spmm</a>. If <code>&ndash;enable-rsb-num-threads</code> has been specified at configure time, the <code>RSB_NUM_THREADS</code> environment variable will override the number of executing threads specified by <code>OMP_NUM_THREADS</code>. (See also <a class="el" href="group__rsb__doc__rsb.html#ggae0bada88731b01751401847d60110fb6ad9150d4d5672d1835185d6e2286d92f4">RSB_IO_WANT_EXECUTING_THREADS</a>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gad018cf218c2c938bb5cf4577f1b53319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad018cf218c2c938bb5cf4577f1b53319">&#9670;&nbsp;</a></span>BLAS_dusmv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_dusmv </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a>&#160;</td>
          <td class="paramname"><em>transA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply by a dense vector. Either of <img class="formulaInl" alt="$Y \leftarrow \alpha A X + Y ,$" src="form_8.png"/> <img class="formulaInl" alt="$Y \leftarrow \alpha A^T X + Y,$" src="form_9.png"/> <img class="formulaInl" alt="$Y \leftarrow \alpha A^H X + Y$" src="form_10.png"/>, depending on the value of <code>transA</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transA</td><td>Transposition operator for matrix <em>A</em>. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">x</td><td>Dense vector <em>x</em>. </td></tr>
    <tr><td class="paramname">incx</td><td>Stride of <em>x</em>. </td></tr>
    <tr><td class="paramname">y</td><td>Dense vector <em>y</em>. </td></tr>
    <tr><td class="paramname">incy</td><td>Stride of <em>y</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd></dd>
<dd>
</dd>
<dd>
By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ac88f907f61c86a61837a37274e2f97d4">blas_rsb_autotune_next_operation</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a> (at any time) the next multiplication routine call (either of <a class="el" href="group__rsb__doc__sparse__blas.html#gad018cf218c2c938bb5cf4577f1b53319">BLAS_dusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaf8193efe99bd255f8fcc4d72213c02d3">BLAS_susmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaba57464d66e3f29bc3177d480b0b6a54">BLAS_zusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacd371d9e8ab736cd4bd5e46973152bb5">BLAS_cusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga16a77093831bc32ccc056258d6f93445">BLAS_dusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacadd9208ad4a6a8d4ceab32ee173c6f4">BLAS_susmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga1d81f70e1fb15c3912006ed71a5cd471">BLAS_zusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gae9a587087965874604ce9785f8660664">BLAS_cusmm</a>) will invoke autotuning before carrying out the effective operation. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants. By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ae05ed12240987c33f90ee6cf012985a0">blas_rsb_spmv_autotuning_on</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a>, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply). This can be overridden only by setting the <code>RSB_NUM_THREADS</code> environment variable. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>On the topic of autotuning, see also <a class="el" href="group__rsb__doc__rsb.html#ga8c11024d248e2e686476fd9e89aa7c15">rsb_tune_spmm</a>. If <code>&ndash;enable-rsb-num-threads</code> has been specified at configure time, the <code>RSB_NUM_THREADS</code> environment variable will override the number of executing threads specified by <code>OMP_NUM_THREADS</code>. (See also <a class="el" href="group__rsb__doc__rsb.html#ggae0bada88731b01751401847d60110fb6ad9150d4d5672d1835185d6e2286d92f4">RSB_IO_WANT_EXECUTING_THREADS</a>).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga1c0ef8d9871085fa78215c5bef419b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c0ef8d9871085fa78215c5bef419b85">&#9670;&nbsp;</a></span>blas_dusmv_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_dusmv_ </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *&#160;</td>
          <td class="paramname"><em>transA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply by a dense vector. Either of <img class="formulaInl" alt="$Y \leftarrow \alpha A X + Y ,$" src="form_8.png"/> <img class="formulaInl" alt="$Y \leftarrow \alpha A^T X + Y,$" src="form_9.png"/> <img class="formulaInl" alt="$Y \leftarrow \alpha A^H X + Y$" src="form_10.png"/>, depending on the value of <code>transA</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transA</td><td>Transposition operator for matrix <em>A</em>. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">x</td><td>Dense vector <em>x</em>. </td></tr>
    <tr><td class="paramname">incx</td><td>Stride of <em>x</em>. </td></tr>
    <tr><td class="paramname">y</td><td>Dense vector <em>y</em>. </td></tr>
    <tr><td class="paramname">incy</td><td>Stride of <em>y</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd></dd>
<dd>
</dd>
<dd>
By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ac88f907f61c86a61837a37274e2f97d4">blas_rsb_autotune_next_operation</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a> (at any time) the next multiplication routine call (either of <a class="el" href="group__rsb__doc__sparse__blas.html#gad018cf218c2c938bb5cf4577f1b53319">BLAS_dusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaf8193efe99bd255f8fcc4d72213c02d3">BLAS_susmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaba57464d66e3f29bc3177d480b0b6a54">BLAS_zusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacd371d9e8ab736cd4bd5e46973152bb5">BLAS_cusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga16a77093831bc32ccc056258d6f93445">BLAS_dusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacadd9208ad4a6a8d4ceab32ee173c6f4">BLAS_susmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga1d81f70e1fb15c3912006ed71a5cd471">BLAS_zusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gae9a587087965874604ce9785f8660664">BLAS_cusmm</a>) will invoke autotuning before carrying out the effective operation. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants. By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ae05ed12240987c33f90ee6cf012985a0">blas_rsb_spmv_autotuning_on</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a>, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply). This can be overridden only by setting the <code>RSB_NUM_THREADS</code> environment variable. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>On the topic of autotuning, see also <a class="el" href="group__rsb__doc__rsb.html#ga8c11024d248e2e686476fd9e89aa7c15">rsb_tune_spmm</a>. If <code>&ndash;enable-rsb-num-threads</code> has been specified at configure time, the <code>RSB_NUM_THREADS</code> environment variable will override the number of executing threads specified by <code>OMP_NUM_THREADS</code>. (See also <a class="el" href="group__rsb__doc__rsb.html#ggae0bada88731b01751401847d60110fb6ad9150d4d5672d1835185d6e2286d92f4">RSB_IO_WANT_EXECUTING_THREADS</a>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga45dcbfbdd60a2af9cd996e5c9039e08a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45dcbfbdd60a2af9cd996e5c9039e08a">&#9670;&nbsp;</a></span>BLAS_dusrows_scale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_dusrows_scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a>&#160;</td>
          <td class="paramname"><em>trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale rows interval of matrix by specified factor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">d</td><td>Rows scaling vector. </td></tr>
    <tr><td class="paramname">trans</td><td>Transposition parameter (if transposed will scale columns). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga72462911e40886183e72b97575b6be78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72462911e40886183e72b97575b6be78">&#9670;&nbsp;</a></span>blas_dusrows_scale_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_dusrows_scale_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale rows interval of matrix by specified factor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">d</td><td>Rows scaling vector. </td></tr>
    <tr><td class="paramname">trans</td><td>Transposition parameter (if transposed will scale columns). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga1176f6368b5a5d44ced6fbd2bf19084a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1176f6368b5a5d44ced6fbd2bf19084a">&#9670;&nbsp;</a></span>BLAS_dussc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_dussc </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a>&#160;</td>
          <td class="paramname"><em>index_base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse scatter: <img class="formulaInl" alt="$Y |_x \leftarrow X$" src="form_7.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements..</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="ga43e60ab2bba8fc57b8cc63922e1dbf6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43e60ab2bba8fc57b8cc63922e1dbf6c">&#9670;&nbsp;</a></span>blas_dussc_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_dussc_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *&#160;</td>
          <td class="paramname"><em>index_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse scatter: <img class="formulaInl" alt="$Y |_x \leftarrow X$" src="form_7.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements..</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="ga7ac36c1131d0f75d0a1775a9c5d8da72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ac36c1131d0f75d0a1775a9c5d8da72">&#9670;&nbsp;</a></span>BLAS_dusset_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_dusset_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a single (existing) matrix nonzero coefficient <img class="formulaInl" alt="$A_{i,j}$" src="form_23.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">i</td><td>Row index. </td></tr>
    <tr><td class="paramname">j</td><td>Column index. </td></tr>
    <tr><td class="paramname">v</td><td>Value pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="gafe25bed88ace26d930f31a737e543197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe25bed88ace26d930f31a737e543197">&#9670;&nbsp;</a></span>blas_dusset_element_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_dusset_element_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a single (existing) matrix nonzero coefficient <img class="formulaInl" alt="$A_{i,j}$" src="form_23.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">i</td><td>Row index. </td></tr>
    <tr><td class="paramname">j</td><td>Column index. </td></tr>
    <tr><td class="paramname">v</td><td>Value pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga875c246c53ad28d02e064fe83fa71c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga875c246c53ad28d02e064fe83fa71c74">&#9670;&nbsp;</a></span>BLAS_dusset_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_dusset_elements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ia</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ja</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nnz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set individual matrix nonzero coefficients values. The operation is pattern preserving, that is, nonzeroes must already exist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">ia</td><td>Row indices array. </td></tr>
    <tr><td class="paramname">ja</td><td>Column indices array. </td></tr>
    <tr><td class="paramname">va</td><td>Values array. </td></tr>
    <tr><td class="paramname">nnz</td><td>Length of the <code>ia</code>,ja,va arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality..</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga01e480eb3f48f1322ecb9b07f3240051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01e480eb3f48f1322ecb9b07f3240051">&#9670;&nbsp;</a></span>blas_dusset_elements_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_dusset_elements_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ia</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ja</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set individual matrix nonzero coefficients values. The operation is pattern preserving, that is, nonzeroes must already exist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">ia</td><td>Row indices array. </td></tr>
    <tr><td class="paramname">ja</td><td>Column indices array. </td></tr>
    <tr><td class="paramname">va</td><td>Values array. </td></tr>
    <tr><td class="paramname">nnz</td><td>Length of the <code>ia</code>,ja,va arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality..</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga74e20c9ec236425337b84086f3d5573b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74e20c9ec236425337b84086f3d5573b">&#9670;&nbsp;</a></span>BLAS_dussm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_dussm </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a>&#160;</td>
          <td class="paramname"><em>transT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Triangular solve, by a dense matrix (aka multi-vector). Either of <img class="formulaInl" alt="$B \leftarrow \alpha T^{-1} B,$" src="form_18.png"/> <img class="formulaInl" alt="$B \leftarrow \alpha T^{-T} B,$" src="form_19.png"/> <img class="formulaInl" alt="$B \leftarrow \alpha T^{-H} B$" src="form_20.png"/>, depending on the value of <code>transT</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>layour of the dense array. </td></tr>
    <tr><td class="paramname">transT</td><td>Transposition operator for matrix <em>T</em>. </td></tr>
    <tr><td class="paramname">nrhs</td><td>Number of right hand side columns. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">T</td><td>A valid triangular matrix handle. </td></tr>
    <tr><td class="paramname">b</td><td>Dense vector <em>b</em>. </td></tr>
    <tr><td class="paramname">ldb</td><td>Leading dimension of <em>b</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga947b8c225bc826c966fff2fa7c1306c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga947b8c225bc826c966fff2fa7c1306c4">&#9670;&nbsp;</a></span>blas_dussm_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_dussm_ </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *&#160;</td>
          <td class="paramname"><em>transT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Triangular solve, by a dense matrix (aka multi-vector). Either of <img class="formulaInl" alt="$B \leftarrow \alpha T^{-1} B,$" src="form_18.png"/> <img class="formulaInl" alt="$B \leftarrow \alpha T^{-T} B,$" src="form_19.png"/> <img class="formulaInl" alt="$B \leftarrow \alpha T^{-H} B$" src="form_20.png"/>, depending on the value of <code>transT</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>layour of the dense array. </td></tr>
    <tr><td class="paramname">transT</td><td>Transposition operator for matrix <em>T</em>. </td></tr>
    <tr><td class="paramname">nrhs</td><td>Number of right hand side columns. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">T</td><td>A valid triangular matrix handle. </td></tr>
    <tr><td class="paramname">b</td><td>Dense vector <em>b</em>. </td></tr>
    <tr><td class="paramname">ldb</td><td>Leading dimension of <em>b</em>.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga017a5e4ea8e2f5c046dc720c1927ac0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga017a5e4ea8e2f5c046dc720c1927ac0d">&#9670;&nbsp;</a></span>BLAS_dussv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_dussv </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a>&#160;</td>
          <td class="paramname"><em>transT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Triangular solve, by a dense vector. Either of <img class="formulaInl" alt="$X \leftarrow \alpha T^{-1}X,$" src="form_12.png"/> <img class="formulaInl" alt="$X \leftarrow \alpha T^{-T}X,$" src="form_13.png"/> <img class="formulaInl" alt="$X \leftarrow \alpha T^{-H}X$" src="form_14.png"/>, depending on the value of <code>transT</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transT</td><td>Transposition operator for matrix <em>T</em>. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">T</td><td>A valid triangular matrix handle. </td></tr>
    <tr><td class="paramname">x</td><td>Dense vector <em>x</em>. </td></tr>
    <tr><td class="paramname">incx</td><td>Stride of <em>x</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga278c886eeedfd80922c9d498d77cecc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga278c886eeedfd80922c9d498d77cecc4">&#9670;&nbsp;</a></span>blas_dussv_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_dussv_ </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *&#160;</td>
          <td class="paramname"><em>transT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Triangular solve, by a dense vector. Either of <img class="formulaInl" alt="$X \leftarrow \alpha T^{-1}X,$" src="form_12.png"/> <img class="formulaInl" alt="$X \leftarrow \alpha T^{-T}X,$" src="form_13.png"/> <img class="formulaInl" alt="$X \leftarrow \alpha T^{-H}X$" src="form_14.png"/>, depending on the value of <code>transT</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transT</td><td>Transposition operator for matrix <em>T</em>. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">T</td><td>A valid triangular matrix handle. </td></tr>
    <tr><td class="paramname">x</td><td>Dense vector <em>x</em>. </td></tr>
    <tr><td class="paramname">incx</td><td>Stride of <em>x</em>.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga58dd46bdc43875a6e77975d29dc3f02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58dd46bdc43875a6e77975d29dc3f02c">&#9670;&nbsp;</a></span>BLAS_susaxpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_susaxpy </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a>&#160;</td>
          <td class="paramname"><em>index_base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse vector update: <img class="formulaInl" alt="$Y \leftarrow \alpha X + Y$" src="form_4.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements. </td></tr>
    <tr><td class="paramname">alpha</td><td>Will scale values of <img class="formulaInl" alt="$X$" src="form_3.png"/> before accumulating to <img class="formulaInl" alt="$Y$" src="form_2.png"/>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="ga54ab59491084aa891fa686b6fc411cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54ab59491084aa891fa686b6fc411cc3">&#9670;&nbsp;</a></span>blas_susaxpy_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_susaxpy_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *&#160;</td>
          <td class="paramname"><em>index_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse vector update: <img class="formulaInl" alt="$Y \leftarrow \alpha X + Y$" src="form_4.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements. </td></tr>
    <tr><td class="paramname">alpha</td><td>Will scale values of <img class="formulaInl" alt="$X$" src="form_3.png"/> before accumulating to <img class="formulaInl" alt="$Y$" src="form_2.png"/>.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="gad9fe50c2e7a26e6ef83dfd3ea4cfcdd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9fe50c2e7a26e6ef83dfd3ea4cfcdd5">&#9670;&nbsp;</a></span>BLAS_suscr_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> BLAS_suscr_begin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates an empty matrix (A) and leaves it in build state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Is the count of rows. </td></tr>
    <tr><td class="paramname">n</td><td>Is the count of columns.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix handle in case of success, or -1 on error.</dd></dl>

</div>
</div>
<a id="gad2f7ede753754c2474d5460a92bba99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2f7ede753754c2474d5460a92bba99e">&#9670;&nbsp;</a></span>blas_suscr_begin_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_suscr_begin_ </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates an empty matrix (A) and leaves it in build state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Is the count of rows. </td></tr>
    <tr><td class="paramname">n</td><td>Is the count of columns.</td></tr>
    <tr><td class="paramname">A</td><td>A valid pointer to an empty matrix handle. </td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. Will assign a valid matrix handle to <img class="formulaInl" alt="$A$" src="form_21.png"/> in case of success, or set it to -1 on error.</dd></dl>

</div>
</div>
<a id="ga11c5559450e186c2a86d714f564411f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11c5559450e186c2a86d714f564411f3">&#9670;&nbsp;</a></span>BLAS_suscr_block_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> BLAS_suscr_block_begin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates an empty matrix (A) and leaves it in build state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k,l</td><td>Are row and column dimensions when specifying a matrix as BCSR. </td></tr>
    <tr><td class="paramname">Mb</td><td>Block rows count. </td></tr>
    <tr><td class="paramname">Nb</td><td>Block columns count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix handle in case of success, or -1 on error.</dd></dl>

</div>
</div>
<a id="ga0067882e19affabebf581452a7c05252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0067882e19affabebf581452a7c05252">&#9670;&nbsp;</a></span>blas_suscr_block_begin_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_suscr_block_begin_ </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates an empty matrix (A) and leaves it in build state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k,l</td><td>Are row and column dimensions when specifying a matrix as BCSR. </td></tr>
    <tr><td class="paramname">Mb</td><td>Block rows count. </td></tr>
    <tr><td class="paramname">Nb</td><td>Block columns count.</td></tr>
    <tr><td class="paramname">A</td><td>A valid pointer to an empty matrix handle. </td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. Will assign a valid matrix handle to <img class="formulaInl" alt="$A$" src="form_21.png"/> in case of success, or set it to -1 on error.</dd></dl>

</div>
</div>
<a id="ga7176a90049256cb0e0fe45db66f57dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7176a90049256cb0e0fe45db66f57dd2">&#9670;&nbsp;</a></span>BLAS_suscr_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_suscr_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes an assembled matrix out of a matrix in build state. After this, it is not possible anymore to insert nonzeroes, but computational routines. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga5822f3be35eeb550c323de69ec9933d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5822f3be35eeb550c323de69ec9933d3">&#9670;&nbsp;</a></span>blas_suscr_end_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_suscr_end_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes an assembled matrix out of a matrix in build state. After this, it is not possible anymore to insert nonzeroes, but computational routines. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gaa682b478ac48e12d4a091977e8c45768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa682b478ac48e12d4a091977e8c45768">&#9670;&nbsp;</a></span>BLAS_suscr_insert_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_suscr_insert_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole block in a matrix, assuming it is in build state. The block size is assumed to be the one specified when calling the (type) corresponding matrix blocked <code>begin</code> function. If not called a blocked <code>begin</code> function, will assume 1x1 (that is, no) blocking. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">row_stride,col_stride</td><td>Row and column strides in accessing <code>val</code>. </td></tr>
    <tr><td class="paramname">i,j</td><td>Block row/column indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Signature of this routine for Fortran does not agree to the standard. This shall be corrected in a future release. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__rsb__doc__sparse__blas.html#ga050218d0fa552a3e2c2d5452f876d9b5">BLAS_cuscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga050218d0fa552a3e2c2d5452f876d9b5">BLAS_cuscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gac0ca32cd2c78c8553d6d6b324e06ef59">BLAS_duscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga5a261b2d1cc996c2a982ff8469faf286">BLAS_zuscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga3483c364b4afec22621e46059b166247">BLAS_cuscr_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gad9fe50c2e7a26e6ef83dfd3ea4cfcdd5">BLAS_suscr_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gac931dcb1129ee3016ab82602c3d14fee">BLAS_duscr_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga52b67393ad16e3d40e74fcdba88c7da4">BLAS_zuscr_begin</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga61080e2828351bd1585deb2713ed8a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61080e2828351bd1585deb2713ed8a29">&#9670;&nbsp;</a></span>blas_suscr_insert_block_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_suscr_insert_block_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>row_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>col_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole block in a matrix, assuming it is in build state. The block size is assumed to be the one specified when calling the (type) corresponding matrix blocked <code>begin</code> function. If not called a blocked <code>begin</code> function, will assume 1x1 (that is, no) blocking. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">row_stride,col_stride</td><td>Row and column strides in accessing <code>val</code>. </td></tr>
    <tr><td class="paramname">i,j</td><td>Block row/column indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Signature of this routine for Fortran does not agree to the standard. This shall be corrected in a future release. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__rsb__doc__sparse__blas.html#ga050218d0fa552a3e2c2d5452f876d9b5">BLAS_cuscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga050218d0fa552a3e2c2d5452f876d9b5">BLAS_cuscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gac0ca32cd2c78c8553d6d6b324e06ef59">BLAS_duscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga5a261b2d1cc996c2a982ff8469faf286">BLAS_zuscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga3483c364b4afec22621e46059b166247">BLAS_cuscr_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gad9fe50c2e7a26e6ef83dfd3ea4cfcdd5">BLAS_suscr_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gac931dcb1129ee3016ab82602c3d14fee">BLAS_duscr_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga52b67393ad16e3d40e74fcdba88c7da4">BLAS_zuscr_begin</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga6e567e79f675ed861c8f446d0e7a78f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e567e79f675ed861c8f446d0e7a78f5">&#9670;&nbsp;</a></span>BLAS_suscr_insert_clique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_suscr_insert_clique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>row_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>col_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>jndx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole clique in a matrix, assuming this is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">k,l</td><td>Clique rows and columns count. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">row_stride,col_stride</td><td>Row/columns stride in accessing the clique. </td></tr>
    <tr><td class="paramname">indx,jndx</td><td>Row/column indices arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Signature of this routine for Fortran does not agree to the standard. This shall be corrected in a future release.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="gafcee9667fc445e32012c960fca7e698d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcee9667fc445e32012c960fca7e698d">&#9670;&nbsp;</a></span>blas_suscr_insert_clique_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_suscr_insert_clique_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>row_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>col_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>jndx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole clique in a matrix, assuming this is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">k,l</td><td>Clique rows and columns count. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">row_stride,col_stride</td><td>Row/columns stride in accessing the clique. </td></tr>
    <tr><td class="paramname">indx,jndx</td><td>Row/column indices arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Signature of this routine for Fortran does not agree to the standard. This shall be corrected in a future release.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga547d271038794dfc797aecc70e294761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga547d271038794dfc797aecc70e294761">&#9670;&nbsp;</a></span>BLAS_suscr_insert_col()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_suscr_insert_col </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole column in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">j</td><td>Column index. </td></tr>
    <tr><td class="paramname">nnz</td><td>Number of nonzeroes to insert. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">indx</td><td>Row indices array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga2d8c691851acf099c25eff1a4c2885c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d8c691851acf099c25eff1a4c2885c1">&#9670;&nbsp;</a></span>blas_suscr_insert_col_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_suscr_insert_col_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole column in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">j</td><td>Column index. </td></tr>
    <tr><td class="paramname">nnz</td><td>Number of nonzeroes to insert. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">indx</td><td>Row indices array.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gac6158601459aabebc22795864a2a62ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6158601459aabebc22795864a2a62ba">&#9670;&nbsp;</a></span>BLAS_suscr_insert_entries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_suscr_insert_entries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>jndx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts entries in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">nnz</td><td>Number of nonzeroes to insert. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">indx</td><td>Row indices array. </td></tr>
    <tr><td class="paramname">jndx</td><td>Column indices array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga9119b49fd049bcaa310bccb36fcda664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9119b49fd049bcaa310bccb36fcda664">&#9670;&nbsp;</a></span>blas_suscr_insert_entries_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_suscr_insert_entries_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>jndx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts entries in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">nnz</td><td>Number of nonzeroes to insert. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">indx</td><td>Row indices array. </td></tr>
    <tr><td class="paramname">jndx</td><td>Column indices array.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga26e2c422895e5df8492bdb561cab4a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26e2c422895e5df8492bdb561cab4a54">&#9670;&nbsp;</a></span>BLAS_suscr_insert_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_suscr_insert_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts an entry in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">i,j</td><td>Row and column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga9b3085c739330bca518e8ef371f7d3b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b3085c739330bca518e8ef371f7d3b1">&#9670;&nbsp;</a></span>blas_suscr_insert_entry_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_suscr_insert_entry_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts an entry in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">i,j</td><td>Row and column indices.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga9b815fa125e3c84a6e6a6ead2c9ef87b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b815fa125e3c84a6e6a6ead2c9ef87b">&#9670;&nbsp;</a></span>BLAS_suscr_insert_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_suscr_insert_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole row in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">i</td><td>Row index. </td></tr>
    <tr><td class="paramname">nnz</td><td>Number of nonzeroes to insert. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">indx</td><td>Row index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga71080ddbf0e0e602c7bc36993a6c88ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71080ddbf0e0e602c7bc36993a6c88ca">&#9670;&nbsp;</a></span>blas_suscr_insert_row_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_suscr_insert_row_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole row in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">i</td><td>Row index. </td></tr>
    <tr><td class="paramname">nnz</td><td>Number of nonzeroes to insert. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">indx</td><td>Row index.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gae7e006a448094a70204be60f24cdf1a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7e006a448094a70204be60f24cdf1a3">&#9670;&nbsp;</a></span>BLAS_suscr_variable_block_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> BLAS_suscr_variable_block_begin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates an empty matrix (A) and leaves it in build state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">K,L</td><td>Are arrays specifying row/column block sizes when specifying a matrix as VBR. </td></tr>
    <tr><td class="paramname">Mb</td><td>Block rows count. </td></tr>
    <tr><td class="paramname">Nb</td><td>Block columns count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix handle in case of success, or -1 on error.</dd></dl>

</div>
</div>
<a id="gaab267e13449c999ad8a8e3e358f4b2ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab267e13449c999ad8a8e3e358f4b2ed">&#9670;&nbsp;</a></span>blas_suscr_variable_block_begin_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_suscr_variable_block_begin_ </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates an empty matrix (A) and leaves it in build state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">K,L</td><td>Are arrays specifying row/column block sizes when specifying a matrix as VBR. </td></tr>
    <tr><td class="paramname">Mb</td><td>Block rows count. </td></tr>
    <tr><td class="paramname">Nb</td><td>Block columns count.</td></tr>
    <tr><td class="paramname">A</td><td>A valid pointer to an empty matrix handle. </td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. Will assign a valid matrix handle to <img class="formulaInl" alt="$A$" src="form_21.png"/> in case of success, or set it to -1 on error.</dd></dl>

</div>
</div>
<a id="ga1f4e5a89c4961c95c4d4267b86540643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f4e5a89c4961c95c4d4267b86540643">&#9670;&nbsp;</a></span>BLAS_susdot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_susdot </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a125c156d54359fba48a6b9cf2a2d0a07">blas_conj_type</a>&#160;</td>
          <td class="paramname"><em>conj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a>&#160;</td>
          <td class="paramname"><em>index_base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse dot product. <img class="formulaInl" alt="$r \leftarrow X^T Y,$" src="form_0.png"/> <img class="formulaInl" alt="$r \leftarrow X^H Y$" src="form_1.png"/> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Sparse dot result array. </td></tr>
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements. </td></tr>
    <tr><td class="paramname">conj</td><td>If <a class="el" href="rsb__libspblas_8c.html#a125c156d54359fba48a6b9cf2a2d0a07a818f88453d90ea14a38c3f24ab9c47b1">blas_conj</a>, values of X will be considered conjugated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="ga93ef5ce40255281ae251ab5675cbbc00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93ef5ce40255281ae251ab5675cbbc00">&#9670;&nbsp;</a></span>blas_susdot_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_susdot_ </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a125c156d54359fba48a6b9cf2a2d0a07">blas_conj_type</a> *&#160;</td>
          <td class="paramname"><em>conj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *&#160;</td>
          <td class="paramname"><em>index_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse dot product. <img class="formulaInl" alt="$r \leftarrow X^T Y,$" src="form_0.png"/> <img class="formulaInl" alt="$r \leftarrow X^H Y$" src="form_1.png"/> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Sparse dot result array. </td></tr>
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements. </td></tr>
    <tr><td class="paramname">conj</td><td>If <a class="el" href="rsb__libspblas_8c.html#a125c156d54359fba48a6b9cf2a2d0a07a818f88453d90ea14a38c3f24ab9c47b1">blas_conj</a>, values of X will be considered conjugated.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="gae54815138a8c6d7c2db81a9b8207d44f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae54815138a8c6d7c2db81a9b8207d44f">&#9670;&nbsp;</a></span>BLAS_susga()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_susga </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a>&#160;</td>
          <td class="paramname"><em>index_base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse gather. <img class="formulaInl" alt="$X \leftarrow Y |_x$" src="form_5.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements..</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="ga1cfcf31ed26b3e9950d55a34d3c6ff61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cfcf31ed26b3e9950d55a34d3c6ff61">&#9670;&nbsp;</a></span>blas_susga_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_susga_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *&#160;</td>
          <td class="paramname"><em>index_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse gather. <img class="formulaInl" alt="$X \leftarrow Y |_x$" src="form_5.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements..</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="ga1113eda1c806ca3631fefde07624fbd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1113eda1c806ca3631fefde07624fbd6">&#9670;&nbsp;</a></span>BLAS_susget_diag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_susget_diag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get matrix diagonal. <img class="formulaInl" alt="$d \leftarrow diag(A)$" src="form_22.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">d</td><td>Array for the diagonal entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga0444e8a4b321bf1488fb496bdf3116d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0444e8a4b321bf1488fb496bdf3116d2">&#9670;&nbsp;</a></span>blas_susget_diag_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_susget_diag_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get matrix diagonal. <img class="formulaInl" alt="$d \leftarrow diag(A)$" src="form_22.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">d</td><td>Array for the diagonal entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gaa7d85107abe6104e71d522362f1cf445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7d85107abe6104e71d522362f1cf445">&#9670;&nbsp;</a></span>BLAS_susget_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_susget_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a single matrix nonzero coefficient <img class="formulaInl" alt="$A_{i,j}$" src="form_23.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">i</td><td>Row index. </td></tr>
    <tr><td class="paramname">j</td><td>Column index. </td></tr>
    <tr><td class="paramname">v</td><td>Value pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga982d5f992dca324bc313412cfb31626d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga982d5f992dca324bc313412cfb31626d">&#9670;&nbsp;</a></span>blas_susget_element_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_susget_element_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a single matrix nonzero coefficient <img class="formulaInl" alt="$A_{i,j}$" src="form_23.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">i</td><td>Row index. </td></tr>
    <tr><td class="paramname">j</td><td>Column index. </td></tr>
    <tr><td class="paramname">v</td><td>Value pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gab48e50e0680b905c6bf51747b14f9ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab48e50e0680b905c6bf51747b14f9ab8">&#9670;&nbsp;</a></span>BLAS_susget_infinity_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_susget_infinity_norm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a>&#160;</td>
          <td class="paramname"><em>trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get infinity norm of matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">in</td><td>Infinity norm pointer. </td></tr>
    <tr><td class="paramname">trans</td><td>Transposition parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="gae9733f7c93409180f6c67808f86782e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9733f7c93409180f6c67808f86782e2">&#9670;&nbsp;</a></span>blas_susget_infinity_norm_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_susget_infinity_norm_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get infinity norm of matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">in</td><td>Infinity norm pointer. </td></tr>
    <tr><td class="paramname">trans</td><td>Transposition parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gafc031d78d0274c81039c2448a403cd10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc031d78d0274c81039c2448a403cd10">&#9670;&nbsp;</a></span>BLAS_susget_matrix_nnz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_susget_matrix_nnz </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get nnz count of matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">nnz</td><td>Output value pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga039a9d4da3423ea71726242e1c1251e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga039a9d4da3423ea71726242e1c1251e7">&#9670;&nbsp;</a></span>blas_susget_matrix_nnz_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_susget_matrix_nnz_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get nnz count of matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">nnz</td><td>Output value pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gaadf5ca5826e15d500f60474e94601ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadf5ca5826e15d500f60474e94601ed2">&#9670;&nbsp;</a></span>BLAS_susget_rows_nnz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_susget_rows_nnz </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnzp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get nnz count of matrix row interval. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">fr</td><td>First row. </td></tr>
    <tr><td class="paramname">lr</td><td>Last row. </td></tr>
    <tr><td class="paramname">nnzp</td><td>Pointer to the nonzeroes variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="gaabcfab419d58bf9bef0085f96ab43488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabcfab419d58bf9bef0085f96ab43488">&#9670;&nbsp;</a></span>blas_susget_rows_nnz_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_susget_rows_nnz_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>lr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnzp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get nnz count of matrix row interval. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">fr</td><td>First row. </td></tr>
    <tr><td class="paramname">lr</td><td>Last row. </td></tr>
    <tr><td class="paramname">nnzp</td><td>Pointer to the nonzeroes variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga1f44678556f1aa33e9c74010d0811f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f44678556f1aa33e9c74010d0811f76">&#9670;&nbsp;</a></span>BLAS_susget_rows_sparse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_susget_rows_sparse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>VA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>IA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>JA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get sparse rows of matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">VA</td><td>pointer to values. </td></tr>
    <tr><td class="paramname">IA</td><td>Row indices array. </td></tr>
    <tr><td class="paramname">JA</td><td>Column indices array. </td></tr>
    <tr><td class="paramname">nnz</td><td>Obtained nonzeroes. </td></tr>
    <tr><td class="paramname">fr</td><td>first row. </td></tr>
    <tr><td class="paramname">lr</td><td>Last row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga271d33ae9fc0e16360bf744a25fc6d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga271d33ae9fc0e16360bf744a25fc6d99">&#9670;&nbsp;</a></span>blas_susget_rows_sparse_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_susget_rows_sparse_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>VA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>IA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>JA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>lr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get sparse rows of matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">VA</td><td>pointer to values. </td></tr>
    <tr><td class="paramname">IA</td><td>Row indices array. </td></tr>
    <tr><td class="paramname">JA</td><td>Column indices array. </td></tr>
    <tr><td class="paramname">nnz</td><td>Obtained nonzeroes. </td></tr>
    <tr><td class="paramname">fr</td><td>first row. </td></tr>
    <tr><td class="paramname">lr</td><td>Last row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga619fd446d5319f1fb864d76a9916954c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga619fd446d5319f1fb864d76a9916954c">&#9670;&nbsp;</a></span>BLAS_susgz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_susgz </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a>&#160;</td>
          <td class="paramname"><em>index_base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse gather and zero. <img class="formulaInl" alt="$X \leftarrow Y |_x;Y|_x \leftarrow 0$" src="form_6.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements..</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="ga7ab1864a44b0cde9740b7009892cc8ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ab1864a44b0cde9740b7009892cc8ca">&#9670;&nbsp;</a></span>blas_susgz_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_susgz_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *&#160;</td>
          <td class="paramname"><em>index_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse gather and zero. <img class="formulaInl" alt="$X \leftarrow Y |_x;Y|_x \leftarrow 0$" src="form_6.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements..</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="gacadd9208ad4a6a8d4ceab32ee173c6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacadd9208ad4a6a8d4ceab32ee173c6f4">&#9670;&nbsp;</a></span>BLAS_susmm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_susmm </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a>&#160;</td>
          <td class="paramname"><em>transA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ldc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply by a dense matrix (aka multi-vector). Either of <img class="formulaInl" alt="$C \leftarrow \alpha AB+C,$" src="form_15.png"/> <img class="formulaInl" alt="$C \leftarrow \alpha A^T B+C,$" src="form_16.png"/> <img class="formulaInl" alt="$C \leftarrow \alpha A^H B+C$" src="form_17.png"/>, depending on the value of <code>transA</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>layour of the dense array. </td></tr>
    <tr><td class="paramname">transA</td><td>Transposition operator for matrix <em>A</em>. </td></tr>
    <tr><td class="paramname">nrhs</td><td>Number of right hand side columns. </td></tr>
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">b</td><td>Dense vector <em>b</em>. </td></tr>
    <tr><td class="paramname">ldb</td><td>Leading dimension of <em>b</em>. </td></tr>
    <tr><td class="paramname">c</td><td>Dense vector <em>c</em>. </td></tr>
    <tr><td class="paramname">ldc</td><td>Leading dimension of <em>c</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd></dd>
<dd>
</dd>
<dd>
By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ac88f907f61c86a61837a37274e2f97d4">blas_rsb_autotune_next_operation</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a> (at any time) the next multiplication routine call (either of <a class="el" href="group__rsb__doc__sparse__blas.html#gad018cf218c2c938bb5cf4577f1b53319">BLAS_dusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaf8193efe99bd255f8fcc4d72213c02d3">BLAS_susmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaba57464d66e3f29bc3177d480b0b6a54">BLAS_zusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacd371d9e8ab736cd4bd5e46973152bb5">BLAS_cusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga16a77093831bc32ccc056258d6f93445">BLAS_dusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacadd9208ad4a6a8d4ceab32ee173c6f4">BLAS_susmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga1d81f70e1fb15c3912006ed71a5cd471">BLAS_zusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gae9a587087965874604ce9785f8660664">BLAS_cusmm</a>) will invoke autotuning before carrying out the effective operation. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants. By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ae05ed12240987c33f90ee6cf012985a0">blas_rsb_spmv_autotuning_on</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a>, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply). This can be overridden only by setting the <code>RSB_NUM_THREADS</code> environment variable. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>On the topic of autotuning, see also <a class="el" href="group__rsb__doc__rsb.html#ga8c11024d248e2e686476fd9e89aa7c15">rsb_tune_spmm</a>. If <code>&ndash;enable-rsb-num-threads</code> has been specified at configure time, the <code>RSB_NUM_THREADS</code> environment variable will override the number of executing threads specified by <code>OMP_NUM_THREADS</code>. (See also <a class="el" href="group__rsb__doc__rsb.html#ggae0bada88731b01751401847d60110fb6ad9150d4d5672d1835185d6e2286d92f4">RSB_IO_WANT_EXECUTING_THREADS</a>).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga43580b6e51c5d8f1e8f8fba0983e3f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43580b6e51c5d8f1e8f8fba0983e3f8f">&#9670;&nbsp;</a></span>blas_susmm_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_susmm_ </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *&#160;</td>
          <td class="paramname"><em>transA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ldc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply by a dense matrix (aka multi-vector). Either of <img class="formulaInl" alt="$C \leftarrow \alpha AB+C,$" src="form_15.png"/> <img class="formulaInl" alt="$C \leftarrow \alpha A^T B+C,$" src="form_16.png"/> <img class="formulaInl" alt="$C \leftarrow \alpha A^H B+C$" src="form_17.png"/>, depending on the value of <code>transA</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>layour of the dense array. </td></tr>
    <tr><td class="paramname">transA</td><td>Transposition operator for matrix <em>A</em>. </td></tr>
    <tr><td class="paramname">nrhs</td><td>Number of right hand side columns. </td></tr>
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">b</td><td>Dense vector <em>b</em>. </td></tr>
    <tr><td class="paramname">ldb</td><td>Leading dimension of <em>b</em>. </td></tr>
    <tr><td class="paramname">c</td><td>Dense vector <em>c</em>. </td></tr>
    <tr><td class="paramname">ldc</td><td>Leading dimension of <em>c</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd></dd>
<dd>
</dd>
<dd>
By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ac88f907f61c86a61837a37274e2f97d4">blas_rsb_autotune_next_operation</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a> (at any time) the next multiplication routine call (either of <a class="el" href="group__rsb__doc__sparse__blas.html#gad018cf218c2c938bb5cf4577f1b53319">BLAS_dusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaf8193efe99bd255f8fcc4d72213c02d3">BLAS_susmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaba57464d66e3f29bc3177d480b0b6a54">BLAS_zusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacd371d9e8ab736cd4bd5e46973152bb5">BLAS_cusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga16a77093831bc32ccc056258d6f93445">BLAS_dusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacadd9208ad4a6a8d4ceab32ee173c6f4">BLAS_susmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga1d81f70e1fb15c3912006ed71a5cd471">BLAS_zusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gae9a587087965874604ce9785f8660664">BLAS_cusmm</a>) will invoke autotuning before carrying out the effective operation. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants. By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ae05ed12240987c33f90ee6cf012985a0">blas_rsb_spmv_autotuning_on</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a>, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply). This can be overridden only by setting the <code>RSB_NUM_THREADS</code> environment variable. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>On the topic of autotuning, see also <a class="el" href="group__rsb__doc__rsb.html#ga8c11024d248e2e686476fd9e89aa7c15">rsb_tune_spmm</a>. If <code>&ndash;enable-rsb-num-threads</code> has been specified at configure time, the <code>RSB_NUM_THREADS</code> environment variable will override the number of executing threads specified by <code>OMP_NUM_THREADS</code>. (See also <a class="el" href="group__rsb__doc__rsb.html#ggae0bada88731b01751401847d60110fb6ad9150d4d5672d1835185d6e2286d92f4">RSB_IO_WANT_EXECUTING_THREADS</a>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gaf8193efe99bd255f8fcc4d72213c02d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8193efe99bd255f8fcc4d72213c02d3">&#9670;&nbsp;</a></span>BLAS_susmv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_susmv </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a>&#160;</td>
          <td class="paramname"><em>transA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply by a dense vector. Either of <img class="formulaInl" alt="$Y \leftarrow \alpha A X + Y ,$" src="form_8.png"/> <img class="formulaInl" alt="$Y \leftarrow \alpha A^T X + Y,$" src="form_9.png"/> <img class="formulaInl" alt="$Y \leftarrow \alpha A^H X + Y$" src="form_10.png"/>, depending on the value of <code>transA</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transA</td><td>Transposition operator for matrix <em>A</em>. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">x</td><td>Dense vector <em>x</em>. </td></tr>
    <tr><td class="paramname">incx</td><td>Stride of <em>x</em>. </td></tr>
    <tr><td class="paramname">y</td><td>Dense vector <em>y</em>. </td></tr>
    <tr><td class="paramname">incy</td><td>Stride of <em>y</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd></dd>
<dd>
</dd>
<dd>
By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ac88f907f61c86a61837a37274e2f97d4">blas_rsb_autotune_next_operation</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a> (at any time) the next multiplication routine call (either of <a class="el" href="group__rsb__doc__sparse__blas.html#gad018cf218c2c938bb5cf4577f1b53319">BLAS_dusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaf8193efe99bd255f8fcc4d72213c02d3">BLAS_susmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaba57464d66e3f29bc3177d480b0b6a54">BLAS_zusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacd371d9e8ab736cd4bd5e46973152bb5">BLAS_cusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga16a77093831bc32ccc056258d6f93445">BLAS_dusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacadd9208ad4a6a8d4ceab32ee173c6f4">BLAS_susmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga1d81f70e1fb15c3912006ed71a5cd471">BLAS_zusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gae9a587087965874604ce9785f8660664">BLAS_cusmm</a>) will invoke autotuning before carrying out the effective operation. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants. By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ae05ed12240987c33f90ee6cf012985a0">blas_rsb_spmv_autotuning_on</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a>, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply). This can be overridden only by setting the <code>RSB_NUM_THREADS</code> environment variable. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>On the topic of autotuning, see also <a class="el" href="group__rsb__doc__rsb.html#ga8c11024d248e2e686476fd9e89aa7c15">rsb_tune_spmm</a>. If <code>&ndash;enable-rsb-num-threads</code> has been specified at configure time, the <code>RSB_NUM_THREADS</code> environment variable will override the number of executing threads specified by <code>OMP_NUM_THREADS</code>. (See also <a class="el" href="group__rsb__doc__rsb.html#ggae0bada88731b01751401847d60110fb6ad9150d4d5672d1835185d6e2286d92f4">RSB_IO_WANT_EXECUTING_THREADS</a>).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="gae39adcc0126a57ae93a3a312a82d51ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae39adcc0126a57ae93a3a312a82d51ee">&#9670;&nbsp;</a></span>blas_susmv_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_susmv_ </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *&#160;</td>
          <td class="paramname"><em>transA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply by a dense vector. Either of <img class="formulaInl" alt="$Y \leftarrow \alpha A X + Y ,$" src="form_8.png"/> <img class="formulaInl" alt="$Y \leftarrow \alpha A^T X + Y,$" src="form_9.png"/> <img class="formulaInl" alt="$Y \leftarrow \alpha A^H X + Y$" src="form_10.png"/>, depending on the value of <code>transA</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transA</td><td>Transposition operator for matrix <em>A</em>. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">x</td><td>Dense vector <em>x</em>. </td></tr>
    <tr><td class="paramname">incx</td><td>Stride of <em>x</em>. </td></tr>
    <tr><td class="paramname">y</td><td>Dense vector <em>y</em>. </td></tr>
    <tr><td class="paramname">incy</td><td>Stride of <em>y</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd></dd>
<dd>
</dd>
<dd>
By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ac88f907f61c86a61837a37274e2f97d4">blas_rsb_autotune_next_operation</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a> (at any time) the next multiplication routine call (either of <a class="el" href="group__rsb__doc__sparse__blas.html#gad018cf218c2c938bb5cf4577f1b53319">BLAS_dusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaf8193efe99bd255f8fcc4d72213c02d3">BLAS_susmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaba57464d66e3f29bc3177d480b0b6a54">BLAS_zusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacd371d9e8ab736cd4bd5e46973152bb5">BLAS_cusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga16a77093831bc32ccc056258d6f93445">BLAS_dusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacadd9208ad4a6a8d4ceab32ee173c6f4">BLAS_susmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga1d81f70e1fb15c3912006ed71a5cd471">BLAS_zusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gae9a587087965874604ce9785f8660664">BLAS_cusmm</a>) will invoke autotuning before carrying out the effective operation. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants. By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ae05ed12240987c33f90ee6cf012985a0">blas_rsb_spmv_autotuning_on</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a>, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply). This can be overridden only by setting the <code>RSB_NUM_THREADS</code> environment variable. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>On the topic of autotuning, see also <a class="el" href="group__rsb__doc__rsb.html#ga8c11024d248e2e686476fd9e89aa7c15">rsb_tune_spmm</a>. If <code>&ndash;enable-rsb-num-threads</code> has been specified at configure time, the <code>RSB_NUM_THREADS</code> environment variable will override the number of executing threads specified by <code>OMP_NUM_THREADS</code>. (See also <a class="el" href="group__rsb__doc__rsb.html#ggae0bada88731b01751401847d60110fb6ad9150d4d5672d1835185d6e2286d92f4">RSB_IO_WANT_EXECUTING_THREADS</a>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga7aad66cf55b972f14329d6e914e2c152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7aad66cf55b972f14329d6e914e2c152">&#9670;&nbsp;</a></span>BLAS_susrows_scale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_susrows_scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a>&#160;</td>
          <td class="paramname"><em>trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale rows interval of matrix by specified factor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">d</td><td>Rows scaling vector. </td></tr>
    <tr><td class="paramname">trans</td><td>Transposition parameter (if transposed will scale columns). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga556ee3376cfe910182dc057d2ffd3e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga556ee3376cfe910182dc057d2ffd3e51">&#9670;&nbsp;</a></span>blas_susrows_scale_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_susrows_scale_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale rows interval of matrix by specified factor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">d</td><td>Rows scaling vector. </td></tr>
    <tr><td class="paramname">trans</td><td>Transposition parameter (if transposed will scale columns). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga628897ca7d06ad80f85dc73560979d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga628897ca7d06ad80f85dc73560979d0d">&#9670;&nbsp;</a></span>BLAS_sussc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_sussc </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a>&#160;</td>
          <td class="paramname"><em>index_base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse scatter: <img class="formulaInl" alt="$Y |_x \leftarrow X$" src="form_7.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements..</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="gaf25a3761107bfaefcceb78a4317cfb47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf25a3761107bfaefcceb78a4317cfb47">&#9670;&nbsp;</a></span>blas_sussc_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_sussc_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *&#160;</td>
          <td class="paramname"><em>index_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse scatter: <img class="formulaInl" alt="$Y |_x \leftarrow X$" src="form_7.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements..</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="ga75f22d2c0b4037375bc9dcbf604d69b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75f22d2c0b4037375bc9dcbf604d69b0">&#9670;&nbsp;</a></span>BLAS_susset_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_susset_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a single (existing) matrix nonzero coefficient <img class="formulaInl" alt="$A_{i,j}$" src="form_23.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">i</td><td>Row index. </td></tr>
    <tr><td class="paramname">j</td><td>Column index. </td></tr>
    <tr><td class="paramname">v</td><td>Value pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga722177d7ee3f45cf6ace9854902cf4a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga722177d7ee3f45cf6ace9854902cf4a8">&#9670;&nbsp;</a></span>blas_susset_element_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_susset_element_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a single (existing) matrix nonzero coefficient <img class="formulaInl" alt="$A_{i,j}$" src="form_23.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">i</td><td>Row index. </td></tr>
    <tr><td class="paramname">j</td><td>Column index. </td></tr>
    <tr><td class="paramname">v</td><td>Value pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gae011e8a07416ebf9b03487f921f0ad5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae011e8a07416ebf9b03487f921f0ad5f">&#9670;&nbsp;</a></span>BLAS_susset_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_susset_elements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ia</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ja</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nnz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set individual matrix nonzero coefficients values. The operation is pattern preserving, that is, nonzeroes must already exist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">ia</td><td>Row indices array. </td></tr>
    <tr><td class="paramname">ja</td><td>Column indices array. </td></tr>
    <tr><td class="paramname">va</td><td>Values array. </td></tr>
    <tr><td class="paramname">nnz</td><td>Length of the <code>ia</code>,ja,va arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality..</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="gaef2d023342cdd7dbe9eac06ad3ee2592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef2d023342cdd7dbe9eac06ad3ee2592">&#9670;&nbsp;</a></span>blas_susset_elements_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_susset_elements_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ia</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ja</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set individual matrix nonzero coefficients values. The operation is pattern preserving, that is, nonzeroes must already exist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">ia</td><td>Row indices array. </td></tr>
    <tr><td class="paramname">ja</td><td>Column indices array. </td></tr>
    <tr><td class="paramname">va</td><td>Values array. </td></tr>
    <tr><td class="paramname">nnz</td><td>Length of the <code>ia</code>,ja,va arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality..</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga6ee5de90a2a5f7c31d916bac83e11c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ee5de90a2a5f7c31d916bac83e11c0e">&#9670;&nbsp;</a></span>BLAS_sussm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_sussm </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a>&#160;</td>
          <td class="paramname"><em>transT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Triangular solve, by a dense matrix (aka multi-vector). Either of <img class="formulaInl" alt="$B \leftarrow \alpha T^{-1} B,$" src="form_18.png"/> <img class="formulaInl" alt="$B \leftarrow \alpha T^{-T} B,$" src="form_19.png"/> <img class="formulaInl" alt="$B \leftarrow \alpha T^{-H} B$" src="form_20.png"/>, depending on the value of <code>transT</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>layour of the dense array. </td></tr>
    <tr><td class="paramname">transT</td><td>Transposition operator for matrix <em>T</em>. </td></tr>
    <tr><td class="paramname">nrhs</td><td>Number of right hand side columns. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">T</td><td>A valid triangular matrix handle. </td></tr>
    <tr><td class="paramname">b</td><td>Dense vector <em>b</em>. </td></tr>
    <tr><td class="paramname">ldb</td><td>Leading dimension of <em>b</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga2485bec02ae7bfb424a328f569951d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2485bec02ae7bfb424a328f569951d06">&#9670;&nbsp;</a></span>blas_sussm_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_sussm_ </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *&#160;</td>
          <td class="paramname"><em>transT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Triangular solve, by a dense matrix (aka multi-vector). Either of <img class="formulaInl" alt="$B \leftarrow \alpha T^{-1} B,$" src="form_18.png"/> <img class="formulaInl" alt="$B \leftarrow \alpha T^{-T} B,$" src="form_19.png"/> <img class="formulaInl" alt="$B \leftarrow \alpha T^{-H} B$" src="form_20.png"/>, depending on the value of <code>transT</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>layour of the dense array. </td></tr>
    <tr><td class="paramname">transT</td><td>Transposition operator for matrix <em>T</em>. </td></tr>
    <tr><td class="paramname">nrhs</td><td>Number of right hand side columns. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">T</td><td>A valid triangular matrix handle. </td></tr>
    <tr><td class="paramname">b</td><td>Dense vector <em>b</em>. </td></tr>
    <tr><td class="paramname">ldb</td><td>Leading dimension of <em>b</em>.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga1227ee6871331ef29910b8fa4969e76a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1227ee6871331ef29910b8fa4969e76a">&#9670;&nbsp;</a></span>BLAS_sussv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_sussv </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a>&#160;</td>
          <td class="paramname"><em>transT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Triangular solve, by a dense vector. Either of <img class="formulaInl" alt="$X \leftarrow \alpha T^{-1}X,$" src="form_12.png"/> <img class="formulaInl" alt="$X \leftarrow \alpha T^{-T}X,$" src="form_13.png"/> <img class="formulaInl" alt="$X \leftarrow \alpha T^{-H}X$" src="form_14.png"/>, depending on the value of <code>transT</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transT</td><td>Transposition operator for matrix <em>T</em>. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">T</td><td>A valid triangular matrix handle. </td></tr>
    <tr><td class="paramname">x</td><td>Dense vector <em>x</em>. </td></tr>
    <tr><td class="paramname">incx</td><td>Stride of <em>x</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga94ffcec367e74167ae2dbbc2ac47a5a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94ffcec367e74167ae2dbbc2ac47a5a3">&#9670;&nbsp;</a></span>blas_sussv_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_sussv_ </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *&#160;</td>
          <td class="paramname"><em>transT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Triangular solve, by a dense vector. Either of <img class="formulaInl" alt="$X \leftarrow \alpha T^{-1}X,$" src="form_12.png"/> <img class="formulaInl" alt="$X \leftarrow \alpha T^{-T}X,$" src="form_13.png"/> <img class="formulaInl" alt="$X \leftarrow \alpha T^{-H}X$" src="form_14.png"/>, depending on the value of <code>transT</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transT</td><td>Transposition operator for matrix <em>T</em>. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">T</td><td>A valid triangular matrix handle. </td></tr>
    <tr><td class="paramname">x</td><td>Dense vector <em>x</em>. </td></tr>
    <tr><td class="paramname">incx</td><td>Stride of <em>x</em>.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga2ff68116b5ae79c37bf335096de973c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ff68116b5ae79c37bf335096de973c0">&#9670;&nbsp;</a></span>BLAS_uscr_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_uscr_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes an assembled matrix out of a matrix in build state. After this, it is not possible anymore to insert nonzeroes, but computational routines. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga60974067bf5367a9a3c6eaa9f6f8f4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60974067bf5367a9a3c6eaa9f6f8f4ab">&#9670;&nbsp;</a></span>blas_uscr_end_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_uscr_end_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes an assembled matrix out of a matrix in build state. After this, it is not possible anymore to insert nonzeroes, but computational routines. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga8b0cca8196f40f7b55084a978b40717f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b0cca8196f40f7b55084a978b40717f">&#9670;&nbsp;</a></span>BLAS_usds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_usds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys a matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="gae4db91cffaf71632bd41b7423c64b757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4db91cffaf71632bd41b7423c64b757">&#9670;&nbsp;</a></span>blas_usds_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_usds_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys a matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga9926e5d108094c236a1d5fe4a8b62a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9926e5d108094c236a1d5fe4a8b62a0d">&#9670;&nbsp;</a></span>BLAS_usgp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_usgp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rsb_blas_pname_t&#160;</td>
          <td class="paramname"><em>pname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a matrix property. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A is the matrix to apply the property. </td></tr>
    <tr><td class="paramname">pname</td><td>The desired matrix property. For valid matrix properties, see <a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729">blas_rsb_ext_type</a>, <a class="el" href="rsb__libspblas_8c.html#acc2b26a405868ca1bd8a18e0eb62e820">blas_uplo_type</a>, <a class="el" href="rsb__libspblas_8c.html#ad7b35ac9114bfe21e15d011bf878b164">blas_diag_type</a>, <a class="el" href="rsb__libspblas_8c.html#a125c156d54359fba48a6b9cf2a2d0a07">blas_conj_type</a>, <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a>, <a class="el" href="rsb__libspblas_8c.html#a7da08ccc1c4c7f5ff40768d502a6e63b">blas_symmetry_type</a>, <a class="el" href="rsb__libspblas_8c.html#a09d8be749e909b403b1563f0ca84aef8">blas_field_type</a>, <a class="el" href="rsb__libspblas_8c.html#a540f6a907f9f5e49d84a65c530e598c6">blas_size_type</a>, <a class="el" href="rsb__libspblas_8c.html#a3f95e19247de0359b56de195704e05a5">blas_sparsity_optimization_type</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga8db33945615cf1d67e742737b8c93099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8db33945615cf1d67e742737b8c93099">&#9670;&nbsp;</a></span>blas_usgp_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_usgp_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rsb_blas_pname_t *&#160;</td>
          <td class="paramname"><em>pname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a matrix property. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A is the matrix to apply the property. </td></tr>
    <tr><td class="paramname">pname</td><td>The desired matrix property. For valid matrix properties, see <a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729">blas_rsb_ext_type</a>, <a class="el" href="rsb__libspblas_8c.html#acc2b26a405868ca1bd8a18e0eb62e820">blas_uplo_type</a>, <a class="el" href="rsb__libspblas_8c.html#ad7b35ac9114bfe21e15d011bf878b164">blas_diag_type</a>, <a class="el" href="rsb__libspblas_8c.html#a125c156d54359fba48a6b9cf2a2d0a07">blas_conj_type</a>, <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a>, <a class="el" href="rsb__libspblas_8c.html#a7da08ccc1c4c7f5ff40768d502a6e63b">blas_symmetry_type</a>, <a class="el" href="rsb__libspblas_8c.html#a09d8be749e909b403b1563f0ca84aef8">blas_field_type</a>, <a class="el" href="rsb__libspblas_8c.html#a540f6a907f9f5e49d84a65c530e598c6">blas_size_type</a>, <a class="el" href="rsb__libspblas_8c.html#a3f95e19247de0359b56de195704e05a5">blas_sparsity_optimization_type</a>. </td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga8672dab1f86ae3d78a8a0e31568b28f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8672dab1f86ae3d78a8a0e31568b28f5">&#9670;&nbsp;</a></span>BLAS_ussp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_ussp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rsb_blas_pname_t&#160;</td>
          <td class="paramname"><em>pname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a matrix property. Should be called just after creation, before nonzeroes insertion. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A is the matrix to apply the property. </td></tr>
    <tr><td class="paramname">pname</td><td>The desired matrix property. For valid matrix properties, see <a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729">blas_rsb_ext_type</a>, <a class="el" href="rsb__libspblas_8c.html#acc2b26a405868ca1bd8a18e0eb62e820">blas_uplo_type</a>, <a class="el" href="rsb__libspblas_8c.html#ad7b35ac9114bfe21e15d011bf878b164">blas_diag_type</a>, <a class="el" href="rsb__libspblas_8c.html#a125c156d54359fba48a6b9cf2a2d0a07">blas_conj_type</a>, <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a>, <a class="el" href="rsb__libspblas_8c.html#a7da08ccc1c4c7f5ff40768d502a6e63b">blas_symmetry_type</a>, <a class="el" href="rsb__libspblas_8c.html#a09d8be749e909b403b1563f0ca84aef8">blas_field_type</a>, <a class="el" href="rsb__libspblas_8c.html#a540f6a907f9f5e49d84a65c530e598c6">blas_size_type</a>, <a class="el" href="rsb__libspblas_8c.html#a3f95e19247de0359b56de195704e05a5">blas_sparsity_optimization_type</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga5399e3334beff0aab3840752ac7e13df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5399e3334beff0aab3840752ac7e13df">&#9670;&nbsp;</a></span>blas_ussp_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_ussp_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rsb_blas_pname_t *&#160;</td>
          <td class="paramname"><em>pname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a matrix property. Should be called just after creation, before nonzeroes insertion. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A is the matrix to apply the property. </td></tr>
    <tr><td class="paramname">pname</td><td>The desired matrix property. For valid matrix properties, see <a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729">blas_rsb_ext_type</a>, <a class="el" href="rsb__libspblas_8c.html#acc2b26a405868ca1bd8a18e0eb62e820">blas_uplo_type</a>, <a class="el" href="rsb__libspblas_8c.html#ad7b35ac9114bfe21e15d011bf878b164">blas_diag_type</a>, <a class="el" href="rsb__libspblas_8c.html#a125c156d54359fba48a6b9cf2a2d0a07">blas_conj_type</a>, <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a>, <a class="el" href="rsb__libspblas_8c.html#a7da08ccc1c4c7f5ff40768d502a6e63b">blas_symmetry_type</a>, <a class="el" href="rsb__libspblas_8c.html#a09d8be749e909b403b1563f0ca84aef8">blas_field_type</a>, <a class="el" href="rsb__libspblas_8c.html#a540f6a907f9f5e49d84a65c530e598c6">blas_size_type</a>, <a class="el" href="rsb__libspblas_8c.html#a3f95e19247de0359b56de195704e05a5">blas_sparsity_optimization_type</a>. </td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gaa7973eedf292007ad12b1844b9b6a1fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7973eedf292007ad12b1844b9b6a1fc">&#9670;&nbsp;</a></span>BLAS_zusaxpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_zusaxpy </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a>&#160;</td>
          <td class="paramname"><em>index_base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse vector update: <img class="formulaInl" alt="$Y \leftarrow \alpha X + Y$" src="form_4.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements. </td></tr>
    <tr><td class="paramname">alpha</td><td>Will scale values of <img class="formulaInl" alt="$X$" src="form_3.png"/> before accumulating to <img class="formulaInl" alt="$Y$" src="form_2.png"/>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="gac310682d723e36eace264d745eb8b3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac310682d723e36eace264d745eb8b3d4">&#9670;&nbsp;</a></span>blas_zusaxpy_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_zusaxpy_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *&#160;</td>
          <td class="paramname"><em>index_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse vector update: <img class="formulaInl" alt="$Y \leftarrow \alpha X + Y$" src="form_4.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements. </td></tr>
    <tr><td class="paramname">alpha</td><td>Will scale values of <img class="formulaInl" alt="$X$" src="form_3.png"/> before accumulating to <img class="formulaInl" alt="$Y$" src="form_2.png"/>.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="ga52b67393ad16e3d40e74fcdba88c7da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52b67393ad16e3d40e74fcdba88c7da4">&#9670;&nbsp;</a></span>BLAS_zuscr_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> BLAS_zuscr_begin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates an empty matrix (A) and leaves it in build state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Is the count of rows. </td></tr>
    <tr><td class="paramname">n</td><td>Is the count of columns.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix handle in case of success, or -1 on error.</dd></dl>

</div>
</div>
<a id="gae0246836bd8d4b8697c6674998397f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0246836bd8d4b8697c6674998397f3a">&#9670;&nbsp;</a></span>blas_zuscr_begin_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_zuscr_begin_ </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates an empty matrix (A) and leaves it in build state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Is the count of rows. </td></tr>
    <tr><td class="paramname">n</td><td>Is the count of columns.</td></tr>
    <tr><td class="paramname">A</td><td>A valid pointer to an empty matrix handle. </td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. Will assign a valid matrix handle to <img class="formulaInl" alt="$A$" src="form_21.png"/> in case of success, or set it to -1 on error.</dd></dl>

</div>
</div>
<a id="ga5a261b2d1cc996c2a982ff8469faf286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a261b2d1cc996c2a982ff8469faf286">&#9670;&nbsp;</a></span>BLAS_zuscr_block_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> BLAS_zuscr_block_begin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates an empty matrix (A) and leaves it in build state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k,l</td><td>Are row and column dimensions when specifying a matrix as BCSR. </td></tr>
    <tr><td class="paramname">Mb</td><td>Block rows count. </td></tr>
    <tr><td class="paramname">Nb</td><td>Block columns count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix handle in case of success, or -1 on error.</dd></dl>

</div>
</div>
<a id="ga62c3bd7ba1a96f82055478d40af67370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62c3bd7ba1a96f82055478d40af67370">&#9670;&nbsp;</a></span>blas_zuscr_block_begin_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_zuscr_block_begin_ </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates an empty matrix (A) and leaves it in build state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k,l</td><td>Are row and column dimensions when specifying a matrix as BCSR. </td></tr>
    <tr><td class="paramname">Mb</td><td>Block rows count. </td></tr>
    <tr><td class="paramname">Nb</td><td>Block columns count.</td></tr>
    <tr><td class="paramname">A</td><td>A valid pointer to an empty matrix handle. </td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. Will assign a valid matrix handle to <img class="formulaInl" alt="$A$" src="form_21.png"/> in case of success, or set it to -1 on error.</dd></dl>

</div>
</div>
<a id="gad6315d71f6f7abf8b82c89c70d6abbf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6315d71f6f7abf8b82c89c70d6abbf3">&#9670;&nbsp;</a></span>BLAS_zuscr_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_zuscr_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes an assembled matrix out of a matrix in build state. After this, it is not possible anymore to insert nonzeroes, but computational routines. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga6c23466b531e84f472d5fa75228cb895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c23466b531e84f472d5fa75228cb895">&#9670;&nbsp;</a></span>blas_zuscr_end_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_zuscr_end_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes an assembled matrix out of a matrix in build state. After this, it is not possible anymore to insert nonzeroes, but computational routines. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga573ee2ea89db4a133b8729abbb1223f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga573ee2ea89db4a133b8729abbb1223f0">&#9670;&nbsp;</a></span>BLAS_zuscr_insert_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_zuscr_insert_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole block in a matrix, assuming it is in build state. The block size is assumed to be the one specified when calling the (type) corresponding matrix blocked <code>begin</code> function. If not called a blocked <code>begin</code> function, will assume 1x1 (that is, no) blocking. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">row_stride,col_stride</td><td>Row and column strides in accessing <code>val</code>. </td></tr>
    <tr><td class="paramname">i,j</td><td>Block row/column indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Signature of this routine for Fortran does not agree to the standard. This shall be corrected in a future release. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__rsb__doc__sparse__blas.html#ga050218d0fa552a3e2c2d5452f876d9b5">BLAS_cuscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga050218d0fa552a3e2c2d5452f876d9b5">BLAS_cuscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gac0ca32cd2c78c8553d6d6b324e06ef59">BLAS_duscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga5a261b2d1cc996c2a982ff8469faf286">BLAS_zuscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga3483c364b4afec22621e46059b166247">BLAS_cuscr_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gad9fe50c2e7a26e6ef83dfd3ea4cfcdd5">BLAS_suscr_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gac931dcb1129ee3016ab82602c3d14fee">BLAS_duscr_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga52b67393ad16e3d40e74fcdba88c7da4">BLAS_zuscr_begin</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="gac3837cd5c7b2e8ac11c6c0e5cff8914c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3837cd5c7b2e8ac11c6c0e5cff8914c">&#9670;&nbsp;</a></span>blas_zuscr_insert_block_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_zuscr_insert_block_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>row_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>col_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole block in a matrix, assuming it is in build state. The block size is assumed to be the one specified when calling the (type) corresponding matrix blocked <code>begin</code> function. If not called a blocked <code>begin</code> function, will assume 1x1 (that is, no) blocking. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">row_stride,col_stride</td><td>Row and column strides in accessing <code>val</code>. </td></tr>
    <tr><td class="paramname">i,j</td><td>Block row/column indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Signature of this routine for Fortran does not agree to the standard. This shall be corrected in a future release. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__rsb__doc__sparse__blas.html#ga050218d0fa552a3e2c2d5452f876d9b5">BLAS_cuscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga050218d0fa552a3e2c2d5452f876d9b5">BLAS_cuscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gac0ca32cd2c78c8553d6d6b324e06ef59">BLAS_duscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga5a261b2d1cc996c2a982ff8469faf286">BLAS_zuscr_block_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga3483c364b4afec22621e46059b166247">BLAS_cuscr_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gad9fe50c2e7a26e6ef83dfd3ea4cfcdd5">BLAS_suscr_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gac931dcb1129ee3016ab82602c3d14fee">BLAS_duscr_begin</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga52b67393ad16e3d40e74fcdba88c7da4">BLAS_zuscr_begin</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga52519d2caa1070b0c80ac3c6cb104d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52519d2caa1070b0c80ac3c6cb104d92">&#9670;&nbsp;</a></span>BLAS_zuscr_insert_clique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_zuscr_insert_clique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>row_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>col_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>jndx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole clique in a matrix, assuming this is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">k,l</td><td>Clique rows and columns count. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">row_stride,col_stride</td><td>Row/columns stride in accessing the clique. </td></tr>
    <tr><td class="paramname">indx,jndx</td><td>Row/column indices arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Signature of this routine for Fortran does not agree to the standard. This shall be corrected in a future release.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga8c3430083655b74988536d823e40c723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c3430083655b74988536d823e40c723">&#9670;&nbsp;</a></span>blas_zuscr_insert_clique_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_zuscr_insert_clique_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>row_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>col_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>jndx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole clique in a matrix, assuming this is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">k,l</td><td>Clique rows and columns count. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">row_stride,col_stride</td><td>Row/columns stride in accessing the clique. </td></tr>
    <tr><td class="paramname">indx,jndx</td><td>Row/column indices arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Signature of this routine for Fortran does not agree to the standard. This shall be corrected in a future release.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga00cfdd3669b146b25d42a32f104ff8a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00cfdd3669b146b25d42a32f104ff8a3">&#9670;&nbsp;</a></span>BLAS_zuscr_insert_col()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_zuscr_insert_col </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole column in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">j</td><td>Column index. </td></tr>
    <tr><td class="paramname">nnz</td><td>Number of nonzeroes to insert. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">indx</td><td>Row indices array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga10a2dc6a5399459c83282bda757f5096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10a2dc6a5399459c83282bda757f5096">&#9670;&nbsp;</a></span>blas_zuscr_insert_col_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_zuscr_insert_col_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole column in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">j</td><td>Column index. </td></tr>
    <tr><td class="paramname">nnz</td><td>Number of nonzeroes to insert. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">indx</td><td>Row indices array.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gaacc9c9e5c95df4ea6656ad93f1f09666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacc9c9e5c95df4ea6656ad93f1f09666">&#9670;&nbsp;</a></span>BLAS_zuscr_insert_entries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_zuscr_insert_entries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>jndx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts entries in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">nnz</td><td>Number of nonzeroes to insert. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">indx</td><td>Row indices array. </td></tr>
    <tr><td class="paramname">jndx</td><td>Column indices array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="gad9ad3afc16fc0181117004fd46ff78ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9ad3afc16fc0181117004fd46ff78ae">&#9670;&nbsp;</a></span>blas_zuscr_insert_entries_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_zuscr_insert_entries_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>jndx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts entries in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">nnz</td><td>Number of nonzeroes to insert. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">indx</td><td>Row indices array. </td></tr>
    <tr><td class="paramname">jndx</td><td>Column indices array.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga1ffe345c537b53ac5839da21b236d87c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ffe345c537b53ac5839da21b236d87c">&#9670;&nbsp;</a></span>BLAS_zuscr_insert_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_zuscr_insert_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts an entry in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">i,j</td><td>Row and column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="gaad6627231dc4230affa318726ff3f345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad6627231dc4230affa318726ff3f345">&#9670;&nbsp;</a></span>blas_zuscr_insert_entry_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_zuscr_insert_entry_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts an entry in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">i,j</td><td>Row and column indices.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gab52e13dc7c61fc48e593276f04cb2d30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab52e13dc7c61fc48e593276f04cb2d30">&#9670;&nbsp;</a></span>BLAS_zuscr_insert_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_zuscr_insert_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole row in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">i</td><td>Row index. </td></tr>
    <tr><td class="paramname">nnz</td><td>Number of nonzeroes to insert. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">indx</td><td>Row index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="gaf871e29bfce399dedbebe2aa9c7831df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf871e29bfce399dedbebe2aa9c7831df">&#9670;&nbsp;</a></span>blas_zuscr_insert_row_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_zuscr_insert_row_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a whole row in a matrix, assuming it is in build state. By default, duplicate entries will be summed together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">i</td><td>Row index. </td></tr>
    <tr><td class="paramname">nnz</td><td>Number of nonzeroes to insert. </td></tr>
    <tr><td class="paramname">val</td><td>Array of values. </td></tr>
    <tr><td class="paramname">indx</td><td>Row index.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gaa582b369a0233027349f8f844cce7622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa582b369a0233027349f8f844cce7622">&#9670;&nbsp;</a></span>BLAS_zuscr_variable_block_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> BLAS_zuscr_variable_block_begin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates an empty matrix (A) and leaves it in build state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">K,L</td><td>Are arrays specifying row/column block sizes when specifying a matrix as VBR. </td></tr>
    <tr><td class="paramname">Mb</td><td>Block rows count. </td></tr>
    <tr><td class="paramname">Nb</td><td>Block columns count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix handle in case of success, or -1 on error.</dd></dl>

</div>
</div>
<a id="gaa51253d1c144c8aa744b2e13742fec40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa51253d1c144c8aa744b2e13742fec40">&#9670;&nbsp;</a></span>blas_zuscr_variable_block_begin_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_zuscr_variable_block_begin_ </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates an empty matrix (A) and leaves it in build state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">K,L</td><td>Are arrays specifying row/column block sizes when specifying a matrix as VBR. </td></tr>
    <tr><td class="paramname">Mb</td><td>Block rows count. </td></tr>
    <tr><td class="paramname">Nb</td><td>Block columns count.</td></tr>
    <tr><td class="paramname">A</td><td>A valid pointer to an empty matrix handle. </td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. Will assign a valid matrix handle to <img class="formulaInl" alt="$A$" src="form_21.png"/> in case of success, or set it to -1 on error.</dd></dl>

</div>
</div>
<a id="ga205c79d7338c077fc229f9079212efce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga205c79d7338c077fc229f9079212efce">&#9670;&nbsp;</a></span>BLAS_zusdot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_zusdot </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a125c156d54359fba48a6b9cf2a2d0a07">blas_conj_type</a>&#160;</td>
          <td class="paramname"><em>conj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a>&#160;</td>
          <td class="paramname"><em>index_base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse dot product. <img class="formulaInl" alt="$r \leftarrow X^T Y,$" src="form_0.png"/> <img class="formulaInl" alt="$r \leftarrow X^H Y$" src="form_1.png"/> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Sparse dot result array. </td></tr>
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements. </td></tr>
    <tr><td class="paramname">conj</td><td>If <a class="el" href="rsb__libspblas_8c.html#a125c156d54359fba48a6b9cf2a2d0a07a818f88453d90ea14a38c3f24ab9c47b1">blas_conj</a>, values of X will be considered conjugated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="gab4b5dcd77e8ef3876dac25ddea14fde5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4b5dcd77e8ef3876dac25ddea14fde5">&#9670;&nbsp;</a></span>blas_zusdot_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_zusdot_ </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a125c156d54359fba48a6b9cf2a2d0a07">blas_conj_type</a> *&#160;</td>
          <td class="paramname"><em>conj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *&#160;</td>
          <td class="paramname"><em>index_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse dot product. <img class="formulaInl" alt="$r \leftarrow X^T Y,$" src="form_0.png"/> <img class="formulaInl" alt="$r \leftarrow X^H Y$" src="form_1.png"/> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Sparse dot result array. </td></tr>
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements. </td></tr>
    <tr><td class="paramname">conj</td><td>If <a class="el" href="rsb__libspblas_8c.html#a125c156d54359fba48a6b9cf2a2d0a07a818f88453d90ea14a38c3f24ab9c47b1">blas_conj</a>, values of X will be considered conjugated.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="ga55e6cbfb486c6ebcc7a14cf637587763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55e6cbfb486c6ebcc7a14cf637587763">&#9670;&nbsp;</a></span>BLAS_zusga()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_zusga </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a>&#160;</td>
          <td class="paramname"><em>index_base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse gather. <img class="formulaInl" alt="$X \leftarrow Y |_x$" src="form_5.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements..</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="ga6f7d5d7d6afbf3cc11625c4f3c886605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f7d5d7d6afbf3cc11625c4f3c886605">&#9670;&nbsp;</a></span>blas_zusga_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_zusga_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *&#160;</td>
          <td class="paramname"><em>index_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse gather. <img class="formulaInl" alt="$X \leftarrow Y |_x$" src="form_5.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements..</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="gad175937c05d3d05d3aa7fa35eb3028ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad175937c05d3d05d3aa7fa35eb3028ec">&#9670;&nbsp;</a></span>BLAS_zusget_diag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_zusget_diag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get matrix diagonal. <img class="formulaInl" alt="$d \leftarrow diag(A)$" src="form_22.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">d</td><td>Array for the diagonal entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga73feb9adc685f7ff1d66763b0801a0f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73feb9adc685f7ff1d66763b0801a0f9">&#9670;&nbsp;</a></span>blas_zusget_diag_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_zusget_diag_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get matrix diagonal. <img class="formulaInl" alt="$d \leftarrow diag(A)$" src="form_22.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">d</td><td>Array for the diagonal entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga231e3c8f71d0409926f7ee5673adfb62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga231e3c8f71d0409926f7ee5673adfb62">&#9670;&nbsp;</a></span>BLAS_zusget_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_zusget_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a single matrix nonzero coefficient <img class="formulaInl" alt="$A_{i,j}$" src="form_23.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">i</td><td>Row index. </td></tr>
    <tr><td class="paramname">j</td><td>Column index. </td></tr>
    <tr><td class="paramname">v</td><td>Value pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga779b26f7805485d4f1993eec9cef0ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga779b26f7805485d4f1993eec9cef0ed1">&#9670;&nbsp;</a></span>blas_zusget_element_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_zusget_element_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a single matrix nonzero coefficient <img class="formulaInl" alt="$A_{i,j}$" src="form_23.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">i</td><td>Row index. </td></tr>
    <tr><td class="paramname">j</td><td>Column index. </td></tr>
    <tr><td class="paramname">v</td><td>Value pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga3178002c71c71591a0c2cf460b9fbf9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3178002c71c71591a0c2cf460b9fbf9a">&#9670;&nbsp;</a></span>BLAS_zusget_infinity_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_zusget_infinity_norm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a>&#160;</td>
          <td class="paramname"><em>trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get infinity norm of matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">in</td><td>Infinity norm pointer. </td></tr>
    <tr><td class="paramname">trans</td><td>Transposition parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="gad8d8a4ec8eda9377e7407869ba813bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8d8a4ec8eda9377e7407869ba813bba">&#9670;&nbsp;</a></span>blas_zusget_infinity_norm_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_zusget_infinity_norm_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get infinity norm of matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">in</td><td>Infinity norm pointer. </td></tr>
    <tr><td class="paramname">trans</td><td>Transposition parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga85e15d7a3331e8ed4d702908477e2896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85e15d7a3331e8ed4d702908477e2896">&#9670;&nbsp;</a></span>BLAS_zusget_matrix_nnz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_zusget_matrix_nnz </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get nnz count of matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">nnz</td><td>Output value pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga9bdd048dea68ecbd8fd712349d4fbf13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bdd048dea68ecbd8fd712349d4fbf13">&#9670;&nbsp;</a></span>blas_zusget_matrix_nnz_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_zusget_matrix_nnz_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get nnz count of matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">nnz</td><td>Output value pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga5aafb42cc79b70119dd05d010a2ca844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5aafb42cc79b70119dd05d010a2ca844">&#9670;&nbsp;</a></span>BLAS_zusget_rows_nnz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_zusget_rows_nnz </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnzp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get nnz count of matrix row interval. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">fr</td><td>First row. </td></tr>
    <tr><td class="paramname">lr</td><td>Last row. </td></tr>
    <tr><td class="paramname">nnzp</td><td>Pointer to the nonzeroes variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="gaeeafa9dc10823580bdc76217a75fecba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeeafa9dc10823580bdc76217a75fecba">&#9670;&nbsp;</a></span>blas_zusget_rows_nnz_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_zusget_rows_nnz_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>lr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnzp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get nnz count of matrix row interval. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">fr</td><td>First row. </td></tr>
    <tr><td class="paramname">lr</td><td>Last row. </td></tr>
    <tr><td class="paramname">nnzp</td><td>Pointer to the nonzeroes variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga4948209c662695a0b5655dca77a94b2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4948209c662695a0b5655dca77a94b2d">&#9670;&nbsp;</a></span>BLAS_zusget_rows_sparse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_zusget_rows_sparse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>VA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>IA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>JA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get sparse rows of matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">VA</td><td>pointer to values. </td></tr>
    <tr><td class="paramname">IA</td><td>Row indices array. </td></tr>
    <tr><td class="paramname">JA</td><td>Column indices array. </td></tr>
    <tr><td class="paramname">nnz</td><td>Obtained nonzeroes. </td></tr>
    <tr><td class="paramname">fr</td><td>first row. </td></tr>
    <tr><td class="paramname">lr</td><td>Last row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga146c34966aa096df8fefdd400e119083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga146c34966aa096df8fefdd400e119083">&#9670;&nbsp;</a></span>blas_zusget_rows_sparse_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_zusget_rows_sparse_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>VA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>IA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>JA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>lr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get sparse rows of matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">VA</td><td>pointer to values. </td></tr>
    <tr><td class="paramname">IA</td><td>Row indices array. </td></tr>
    <tr><td class="paramname">JA</td><td>Column indices array. </td></tr>
    <tr><td class="paramname">nnz</td><td>Obtained nonzeroes. </td></tr>
    <tr><td class="paramname">fr</td><td>first row. </td></tr>
    <tr><td class="paramname">lr</td><td>Last row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga67e660789cd15fac6bd2be6977cc2aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67e660789cd15fac6bd2be6977cc2aba">&#9670;&nbsp;</a></span>BLAS_zusgz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_zusgz </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a>&#160;</td>
          <td class="paramname"><em>index_base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse gather and zero. <img class="formulaInl" alt="$X \leftarrow Y |_x;Y|_x \leftarrow 0$" src="form_6.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements..</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="ga7c68bde8c3dd1357ab033ae4982a5eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c68bde8c3dd1357ab033ae4982a5eec">&#9670;&nbsp;</a></span>blas_zusgz_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_zusgz_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *&#160;</td>
          <td class="paramname"><em>index_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse gather and zero. <img class="formulaInl" alt="$X \leftarrow Y |_x;Y|_x \leftarrow 0$" src="form_6.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements..</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="ga1d81f70e1fb15c3912006ed71a5cd471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d81f70e1fb15c3912006ed71a5cd471">&#9670;&nbsp;</a></span>BLAS_zusmm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_zusmm </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a>&#160;</td>
          <td class="paramname"><em>transA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ldc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply by a dense matrix (aka multi-vector). Either of <img class="formulaInl" alt="$C \leftarrow \alpha AB+C,$" src="form_15.png"/> <img class="formulaInl" alt="$C \leftarrow \alpha A^T B+C,$" src="form_16.png"/> <img class="formulaInl" alt="$C \leftarrow \alpha A^H B+C$" src="form_17.png"/>, depending on the value of <code>transA</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>layour of the dense array. </td></tr>
    <tr><td class="paramname">transA</td><td>Transposition operator for matrix <em>A</em>. </td></tr>
    <tr><td class="paramname">nrhs</td><td>Number of right hand side columns. </td></tr>
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">b</td><td>Dense vector <em>b</em>. </td></tr>
    <tr><td class="paramname">ldb</td><td>Leading dimension of <em>b</em>. </td></tr>
    <tr><td class="paramname">c</td><td>Dense vector <em>c</em>. </td></tr>
    <tr><td class="paramname">ldc</td><td>Leading dimension of <em>c</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd></dd>
<dd>
</dd>
<dd>
By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ac88f907f61c86a61837a37274e2f97d4">blas_rsb_autotune_next_operation</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a> (at any time) the next multiplication routine call (either of <a class="el" href="group__rsb__doc__sparse__blas.html#gad018cf218c2c938bb5cf4577f1b53319">BLAS_dusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaf8193efe99bd255f8fcc4d72213c02d3">BLAS_susmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaba57464d66e3f29bc3177d480b0b6a54">BLAS_zusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacd371d9e8ab736cd4bd5e46973152bb5">BLAS_cusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga16a77093831bc32ccc056258d6f93445">BLAS_dusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacadd9208ad4a6a8d4ceab32ee173c6f4">BLAS_susmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga1d81f70e1fb15c3912006ed71a5cd471">BLAS_zusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gae9a587087965874604ce9785f8660664">BLAS_cusmm</a>) will invoke autotuning before carrying out the effective operation. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants. By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ae05ed12240987c33f90ee6cf012985a0">blas_rsb_spmv_autotuning_on</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a>, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply). This can be overridden only by setting the <code>RSB_NUM_THREADS</code> environment variable. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>On the topic of autotuning, see also <a class="el" href="group__rsb__doc__rsb.html#ga8c11024d248e2e686476fd9e89aa7c15">rsb_tune_spmm</a>. If <code>&ndash;enable-rsb-num-threads</code> has been specified at configure time, the <code>RSB_NUM_THREADS</code> environment variable will override the number of executing threads specified by <code>OMP_NUM_THREADS</code>. (See also <a class="el" href="group__rsb__doc__rsb.html#ggae0bada88731b01751401847d60110fb6ad9150d4d5672d1835185d6e2286d92f4">RSB_IO_WANT_EXECUTING_THREADS</a>).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga099df6bc63ed6a0c2bf387992b58e151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga099df6bc63ed6a0c2bf387992b58e151">&#9670;&nbsp;</a></span>blas_zusmm_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_zusmm_ </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *&#160;</td>
          <td class="paramname"><em>transA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ldc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply by a dense matrix (aka multi-vector). Either of <img class="formulaInl" alt="$C \leftarrow \alpha AB+C,$" src="form_15.png"/> <img class="formulaInl" alt="$C \leftarrow \alpha A^T B+C,$" src="form_16.png"/> <img class="formulaInl" alt="$C \leftarrow \alpha A^H B+C$" src="form_17.png"/>, depending on the value of <code>transA</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>layour of the dense array. </td></tr>
    <tr><td class="paramname">transA</td><td>Transposition operator for matrix <em>A</em>. </td></tr>
    <tr><td class="paramname">nrhs</td><td>Number of right hand side columns. </td></tr>
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">b</td><td>Dense vector <em>b</em>. </td></tr>
    <tr><td class="paramname">ldb</td><td>Leading dimension of <em>b</em>. </td></tr>
    <tr><td class="paramname">c</td><td>Dense vector <em>c</em>. </td></tr>
    <tr><td class="paramname">ldc</td><td>Leading dimension of <em>c</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd></dd>
<dd>
</dd>
<dd>
By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ac88f907f61c86a61837a37274e2f97d4">blas_rsb_autotune_next_operation</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a> (at any time) the next multiplication routine call (either of <a class="el" href="group__rsb__doc__sparse__blas.html#gad018cf218c2c938bb5cf4577f1b53319">BLAS_dusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaf8193efe99bd255f8fcc4d72213c02d3">BLAS_susmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaba57464d66e3f29bc3177d480b0b6a54">BLAS_zusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacd371d9e8ab736cd4bd5e46973152bb5">BLAS_cusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga16a77093831bc32ccc056258d6f93445">BLAS_dusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacadd9208ad4a6a8d4ceab32ee173c6f4">BLAS_susmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga1d81f70e1fb15c3912006ed71a5cd471">BLAS_zusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gae9a587087965874604ce9785f8660664">BLAS_cusmm</a>) will invoke autotuning before carrying out the effective operation. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants. By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ae05ed12240987c33f90ee6cf012985a0">blas_rsb_spmv_autotuning_on</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a>, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply). This can be overridden only by setting the <code>RSB_NUM_THREADS</code> environment variable. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>On the topic of autotuning, see also <a class="el" href="group__rsb__doc__rsb.html#ga8c11024d248e2e686476fd9e89aa7c15">rsb_tune_spmm</a>. If <code>&ndash;enable-rsb-num-threads</code> has been specified at configure time, the <code>RSB_NUM_THREADS</code> environment variable will override the number of executing threads specified by <code>OMP_NUM_THREADS</code>. (See also <a class="el" href="group__rsb__doc__rsb.html#ggae0bada88731b01751401847d60110fb6ad9150d4d5672d1835185d6e2286d92f4">RSB_IO_WANT_EXECUTING_THREADS</a>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gaba57464d66e3f29bc3177d480b0b6a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba57464d66e3f29bc3177d480b0b6a54">&#9670;&nbsp;</a></span>BLAS_zusmv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_zusmv </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a>&#160;</td>
          <td class="paramname"><em>transA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply by a dense vector. Either of <img class="formulaInl" alt="$Y \leftarrow \alpha A X + Y ,$" src="form_8.png"/> <img class="formulaInl" alt="$Y \leftarrow \alpha A^T X + Y,$" src="form_9.png"/> <img class="formulaInl" alt="$Y \leftarrow \alpha A^H X + Y$" src="form_10.png"/>, depending on the value of <code>transA</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transA</td><td>Transposition operator for matrix <em>A</em>. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">x</td><td>Dense vector <em>x</em>. </td></tr>
    <tr><td class="paramname">incx</td><td>Stride of <em>x</em>. </td></tr>
    <tr><td class="paramname">y</td><td>Dense vector <em>y</em>. </td></tr>
    <tr><td class="paramname">incy</td><td>Stride of <em>y</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd></dd>
<dd>
</dd>
<dd>
By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ac88f907f61c86a61837a37274e2f97d4">blas_rsb_autotune_next_operation</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a> (at any time) the next multiplication routine call (either of <a class="el" href="group__rsb__doc__sparse__blas.html#gad018cf218c2c938bb5cf4577f1b53319">BLAS_dusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaf8193efe99bd255f8fcc4d72213c02d3">BLAS_susmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaba57464d66e3f29bc3177d480b0b6a54">BLAS_zusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacd371d9e8ab736cd4bd5e46973152bb5">BLAS_cusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga16a77093831bc32ccc056258d6f93445">BLAS_dusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacadd9208ad4a6a8d4ceab32ee173c6f4">BLAS_susmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga1d81f70e1fb15c3912006ed71a5cd471">BLAS_zusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gae9a587087965874604ce9785f8660664">BLAS_cusmm</a>) will invoke autotuning before carrying out the effective operation. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants. By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ae05ed12240987c33f90ee6cf012985a0">blas_rsb_spmv_autotuning_on</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a>, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply). This can be overridden only by setting the <code>RSB_NUM_THREADS</code> environment variable. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>On the topic of autotuning, see also <a class="el" href="group__rsb__doc__rsb.html#ga8c11024d248e2e686476fd9e89aa7c15">rsb_tune_spmm</a>. If <code>&ndash;enable-rsb-num-threads</code> has been specified at configure time, the <code>RSB_NUM_THREADS</code> environment variable will override the number of executing threads specified by <code>OMP_NUM_THREADS</code>. (See also <a class="el" href="group__rsb__doc__rsb.html#ggae0bada88731b01751401847d60110fb6ad9150d4d5672d1835185d6e2286d92f4">RSB_IO_WANT_EXECUTING_THREADS</a>).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga01239a7a368b66a4b3802b89b98e6054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01239a7a368b66a4b3802b89b98e6054">&#9670;&nbsp;</a></span>blas_zusmv_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_zusmv_ </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *&#160;</td>
          <td class="paramname"><em>transA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply by a dense vector. Either of <img class="formulaInl" alt="$Y \leftarrow \alpha A X + Y ,$" src="form_8.png"/> <img class="formulaInl" alt="$Y \leftarrow \alpha A^T X + Y,$" src="form_9.png"/> <img class="formulaInl" alt="$Y \leftarrow \alpha A^H X + Y$" src="form_10.png"/>, depending on the value of <code>transA</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transA</td><td>Transposition operator for matrix <em>A</em>. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">x</td><td>Dense vector <em>x</em>. </td></tr>
    <tr><td class="paramname">incx</td><td>Stride of <em>x</em>. </td></tr>
    <tr><td class="paramname">y</td><td>Dense vector <em>y</em>. </td></tr>
    <tr><td class="paramname">incy</td><td>Stride of <em>y</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd></dd>
<dd>
</dd>
<dd>
By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ac88f907f61c86a61837a37274e2f97d4">blas_rsb_autotune_next_operation</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a> (at any time) the next multiplication routine call (either of <a class="el" href="group__rsb__doc__sparse__blas.html#gad018cf218c2c938bb5cf4577f1b53319">BLAS_dusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaf8193efe99bd255f8fcc4d72213c02d3">BLAS_susmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gaba57464d66e3f29bc3177d480b0b6a54">BLAS_zusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacd371d9e8ab736cd4bd5e46973152bb5">BLAS_cusmv</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga16a77093831bc32ccc056258d6f93445">BLAS_dusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gacadd9208ad4a6a8d4ceab32ee173c6f4">BLAS_susmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#ga1d81f70e1fb15c3912006ed71a5cd471">BLAS_zusmm</a>, <a class="el" href="group__rsb__doc__sparse__blas.html#gae9a587087965874604ce9785f8660664">BLAS_cusmm</a>) will invoke autotuning before carrying out the effective operation. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants. By setting the <code><a class="el" href="rsb__libspblas_8c.html#aee94244609acd12511418bfbf0a77729ae05ed12240987c33f90ee6cf012985a0">blas_rsb_spmv_autotuning_on</a></code> property via <a class="el" href="group__rsb__doc__sparse__blas.html#ga8672dab1f86ae3d78a8a0e31568b28f5">BLAS_ussp</a>, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply). This can be overridden only by setting the <code>RSB_NUM_THREADS</code> environment variable. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>On the topic of autotuning, see also <a class="el" href="group__rsb__doc__rsb.html#ga8c11024d248e2e686476fd9e89aa7c15">rsb_tune_spmm</a>. If <code>&ndash;enable-rsb-num-threads</code> has been specified at configure time, the <code>RSB_NUM_THREADS</code> environment variable will override the number of executing threads specified by <code>OMP_NUM_THREADS</code>. (See also <a class="el" href="group__rsb__doc__rsb.html#ggae0bada88731b01751401847d60110fb6ad9150d4d5672d1835185d6e2286d92f4">RSB_IO_WANT_EXECUTING_THREADS</a>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gac90f64f4065b6b4f654eb139e0a0c62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac90f64f4065b6b4f654eb139e0a0c62d">&#9670;&nbsp;</a></span>BLAS_zusrows_scale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_zusrows_scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a>&#160;</td>
          <td class="paramname"><em>trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale rows interval of matrix by specified factor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">d</td><td>Rows scaling vector. </td></tr>
    <tr><td class="paramname">trans</td><td>Transposition parameter (if transposed will scale columns). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="gad776dac8b803704bd8629b026774dd7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad776dac8b803704bd8629b026774dd7b">&#9670;&nbsp;</a></span>blas_zusrows_scale_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_zusrows_scale_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale rows interval of matrix by specified factor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">d</td><td>Rows scaling vector. </td></tr>
    <tr><td class="paramname">trans</td><td>Transposition parameter (if transposed will scale columns). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga5d95d007f1dc092eab6126e606b70423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d95d007f1dc092eab6126e606b70423">&#9670;&nbsp;</a></span>BLAS_zussc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_zussc </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a>&#160;</td>
          <td class="paramname"><em>index_base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse scatter: <img class="formulaInl" alt="$Y |_x \leftarrow X$" src="form_7.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements..</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="ga6f6ec9614871760de418e56e3529c281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f6ec9614871760de418e56e3529c281">&#9670;&nbsp;</a></span>blas_zussc_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_zussc_ </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a3fe740ad5a139d723de260d638987e9e">blas_base_type</a> *&#160;</td>
          <td class="paramname"><em>index_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sparse scatter: <img class="formulaInl" alt="$Y |_x \leftarrow X$" src="form_7.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Array for <img class="formulaInl" alt="$Y$" src="form_2.png"/> vector. </td></tr>
    <tr><td class="paramname">x</td><td>Array for <img class="formulaInl" alt="$X$" src="form_3.png"/> vector. </td></tr>
    <tr><td class="paramname">nnz</td><td>Size of <img class="formulaInl" alt="$X$" src="form_3.png"/> <em>and</em> <em><img class="formulaInl" alt="$Y$" src="form_2.png"/></em> vectors. </td></tr>
    <tr><td class="paramname">indx</td><td>Is the array of indices at which sparse vector <img class="formulaInl" alt="$X$" src="form_3.png"/> will be accessed. </td></tr>
    <tr><td class="paramname">index_base</td><td>Specifies the contents of <code>indx</code>, either <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a> or <a class="el" href="rsb__libspblas_8c.html#a3fe740ad5a139d723de260d638987e9ea7afb2ddbf81bc727135963e14a2c62ad">blas_one_base</a>. </td></tr>
    <tr><td class="paramname">incy</td><td>The distance between consecutive <code>y</code> array elements..</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Sparse BLAS Level 1 has been implemented, although not with performance in mind.</dd></dl>

</div>
</div>
<a id="gae423e34d5a98eb240edb270e26742c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae423e34d5a98eb240edb270e26742c90">&#9670;&nbsp;</a></span>BLAS_zusset_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_zusset_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a single (existing) matrix nonzero coefficient <img class="formulaInl" alt="$A_{i,j}$" src="form_23.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">i</td><td>Row index. </td></tr>
    <tr><td class="paramname">j</td><td>Column index. </td></tr>
    <tr><td class="paramname">v</td><td>Value pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="gac91099519c242471405de4e4df28e5bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac91099519c242471405de4e4df28e5bf">&#9670;&nbsp;</a></span>blas_zusset_element_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_zusset_element_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a single (existing) matrix nonzero coefficient <img class="formulaInl" alt="$A_{i,j}$" src="form_23.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">i</td><td>Row index. </td></tr>
    <tr><td class="paramname">j</td><td>Column index. </td></tr>
    <tr><td class="paramname">v</td><td>Value pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gaf861d08ba8631e769fcb8f25264b8965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf861d08ba8631e769fcb8f25264b8965">&#9670;&nbsp;</a></span>BLAS_zusset_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_zusset_elements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ia</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ja</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nnz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set individual matrix nonzero coefficients values. The operation is pattern preserving, that is, nonzeroes must already exist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">ia</td><td>Row indices array. </td></tr>
    <tr><td class="paramname">ja</td><td>Column indices array. </td></tr>
    <tr><td class="paramname">va</td><td>Values array. </td></tr>
    <tr><td class="paramname">nnz</td><td>Length of the <code>ia</code>,ja,va arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality..</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga6d3dd01c5e3e4b568cf3ff7e6c807789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d3dd01c5e3e4b568cf3ff7e6c807789">&#9670;&nbsp;</a></span>blas_zusset_elements_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_zusset_elements_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ia</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ja</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set individual matrix nonzero coefficients values. The operation is pattern preserving, that is, nonzeroes must already exist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
    <tr><td class="paramname">ia</td><td>Row indices array. </td></tr>
    <tr><td class="paramname">ja</td><td>Column indices array. </td></tr>
    <tr><td class="paramname">va</td><td>Values array. </td></tr>
    <tr><td class="paramname">nnz</td><td>Length of the <code>ia</code>,ja,va arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality..</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="gac9c025e498f8ef44437bdc97b494005c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9c025e498f8ef44437bdc97b494005c">&#9670;&nbsp;</a></span>BLAS_zussm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_zussm </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a>&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a>&#160;</td>
          <td class="paramname"><em>transT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ldb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Triangular solve, by a dense matrix (aka multi-vector). Either of <img class="formulaInl" alt="$B \leftarrow \alpha T^{-1} B,$" src="form_18.png"/> <img class="formulaInl" alt="$B \leftarrow \alpha T^{-T} B,$" src="form_19.png"/> <img class="formulaInl" alt="$B \leftarrow \alpha T^{-H} B$" src="form_20.png"/>, depending on the value of <code>transT</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>layour of the dense array. </td></tr>
    <tr><td class="paramname">transT</td><td>Transposition operator for matrix <em>T</em>. </td></tr>
    <tr><td class="paramname">nrhs</td><td>Number of right hand side columns. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">T</td><td>A valid triangular matrix handle. </td></tr>
    <tr><td class="paramname">b</td><td>Dense vector <em>b</em>. </td></tr>
    <tr><td class="paramname">ldb</td><td>Leading dimension of <em>b</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga4a9b737504223977a5c6093b1424fb64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a9b737504223977a5c6093b1424fb64">&#9670;&nbsp;</a></span>blas_zussm_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_zussm_ </td>
          <td>(</td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a9e6ec9e515f9d9b7e47110ae5f6ea04e">blas_order_type</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *&#160;</td>
          <td class="paramname"><em>transT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Triangular solve, by a dense matrix (aka multi-vector). Either of <img class="formulaInl" alt="$B \leftarrow \alpha T^{-1} B,$" src="form_18.png"/> <img class="formulaInl" alt="$B \leftarrow \alpha T^{-T} B,$" src="form_19.png"/> <img class="formulaInl" alt="$B \leftarrow \alpha T^{-H} B$" src="form_20.png"/>, depending on the value of <code>transT</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>layour of the dense array. </td></tr>
    <tr><td class="paramname">transT</td><td>Transposition operator for matrix <em>T</em>. </td></tr>
    <tr><td class="paramname">nrhs</td><td>Number of right hand side columns. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">T</td><td>A valid triangular matrix handle. </td></tr>
    <tr><td class="paramname">b</td><td>Dense vector <em>b</em>. </td></tr>
    <tr><td class="paramname">ldb</td><td>Leading dimension of <em>b</em>.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga527f71f83a92aed1698c0f754caea84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga527f71f83a92aed1698c0f754caea84a">&#9670;&nbsp;</a></span>BLAS_zussv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BLAS_zussv </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a>&#160;</td>
          <td class="paramname"><em>transT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Triangular solve, by a dense vector. Either of <img class="formulaInl" alt="$X \leftarrow \alpha T^{-1}X,$" src="form_12.png"/> <img class="formulaInl" alt="$X \leftarrow \alpha T^{-T}X,$" src="form_13.png"/> <img class="formulaInl" alt="$X \leftarrow \alpha T^{-H}X$" src="form_14.png"/>, depending on the value of <code>transT</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transT</td><td>Transposition operator for matrix <em>T</em>. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">T</td><td>A valid triangular matrix handle. </td></tr>
    <tr><td class="paramname">x</td><td>Dense vector <em>x</em>. </td></tr>
    <tr><td class="paramname">incx</td><td>Stride of <em>x</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned; on error, -1.</dd></dl>

</div>
</div>
<a id="ga28cdd020e7f028658d63d03990135dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28cdd020e7f028658d63d03990135dc9">&#9670;&nbsp;</a></span>blas_zussv_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blas_zussv_ </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="blas__sparse_8h.html#a23e5e138364c80074ac014a3dfd346b7">blas_trans_type</a> *&#160;</td>
          <td class="paramname"><em>transT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> *&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>istat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Triangular solve, by a dense vector. Either of <img class="formulaInl" alt="$X \leftarrow \alpha T^{-1}X,$" src="form_12.png"/> <img class="formulaInl" alt="$X \leftarrow \alpha T^{-T}X,$" src="form_13.png"/> <img class="formulaInl" alt="$X \leftarrow \alpha T^{-H}X$" src="form_14.png"/>, depending on the value of <code>transT</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transT</td><td>Transposition operator for matrix <em>T</em>. </td></tr>
    <tr><td class="paramname">alpha</td><td>Value for <img class="formulaInl" alt="$ \alpha $" src="form_11.png"/>. </td></tr>
    <tr><td class="paramname">T</td><td>A valid triangular matrix handle. </td></tr>
    <tr><td class="paramname">x</td><td>Dense vector <em>x</em>. </td></tr>
    <tr><td class="paramname">incx</td><td>Stride of <em>x</em>.</td></tr>
    <tr><td class="paramname">istat</td><td>If non <code>NULL</code>, <code>*istat</code> will be set to the return code, either 0 (success) or -1 (failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This is a subroutine for Fortran, so it does not return any value.</dd></dl>

</div>
</div>
<a id="ga144b8e13c62a239a3097256af7c09fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga144b8e13c62a239a3097256af7c09fcb">&#9670;&nbsp;</a></span>rsb_blas_file_mtx_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> rsb_blas_file_mtx_load </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="rsb_8h.html#a10ec0af478bcccdab11545b106678ef6">rsb_char_t</a> *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rsb_8h.html#ac0f6a03345c8874f6e50f0ed033d984b">rsb_type_t</a>&#160;</td>
          <td class="paramname"><em>typecode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load Matrix Market matrix file of specified type to a matrix, and return Sparse BLAS handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The specified matrix file name (cannot be <code>NULL</code>). </td></tr>
    <tr><td class="paramname">typecode</td><td>A valid type code for the desired output matrix (see <a class="el" href="rsb__types_8h.html#matrix_type_symbols_section">matrix_type_symbols_section</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a valid matrix handle will be returned. On error, <a class="el" href="rsb__libspblas_8c.html#a7cb10fb1b47b79ef278d6f09d571bd06a51022d3d696b9aee38d51040a5b01da7">blas_invalid_handle</a> will be returned.</dd></dl>
<p><br />
 </p>

</div>
</div>
<a id="gac4d8c73e5d9faa85209bcc4e885d4ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4d8c73e5d9faa85209bcc4e885d4ff1">&#9670;&nbsp;</a></span>rsb_blas_get_mtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rsb_mtx_t* rsb_blas_get_mtx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a>&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a valid Sparse BLAS handle, returns a pointer to the inner rsb_mtx_t structure. Then, this can be used for many of the <a class="el" href="rsb_8h.html">rsb.h</a> functions. This is an experimental function, so we recommend to use it with functions not modifying the matrix (ones that take <code>const</code> <code>struct</code> <code>rsb_mtx_t*mtxAp</code>). You can use this function from either Fortran or C.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A valid matrix handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a valid pointer to the inner matrix structure (<code>struct</code> <code>rsb_mtx_t*</code>); on error, <code>NULL</code>.</dd></dl>
<p><br />
 An example using Fortran: </p><div class="fragment"><div class="line">...  </div><div class="line">USE <a class="code" href="namespaceblas__sparse.html">blas_sparse</a> </div><div class="line">USE <a class="code" href="namespacersb.html">rsb</a> </div><div class="line">IMPLICIT NONE </div><div class="line">TYPE(C_PTR),TARGET :: mtxAp = C_NULL_PTR ! matrix pointer </div><div class="line">INTEGER :: A ! <a class="code" href="blas__sparse_8h.html#a6f56456b01e0cc6b25b81201aa67c163">blas_sparse_matrix</a> handle </div><div class="line">INTEGER, TARGET :: istat = 0 </div><div class="line">... ! begin, populate and finalize A, e.g. <span class="keyword">using</span> <a class="code" href="group__rsb__doc__sparse__blas.html#gac931dcb1129ee3016ab82602c3d14fee">BLAS_duscr_begin</a>, <a class="code" href="group__rsb__doc__sparse__blas.html#gae0683bc8f0af5dd3e53b964190f9e1b4">BLAS_duscr_insert_entries</a>, <a class="code" href="group__rsb__doc__sparse__blas.html#ga2ff68116b5ae79c37bf335096de973c0">BLAS_uscr_end</a></div><div class="line">! <span class="keyword">get</span> pointer to <a class="code" href="namespacersb.html">rsb</a> structure: </div><div class="line">mtxAp = <a class="code" href="group__rsb__doc__sparse__blas.html#gac4d8c73e5d9faa85209bcc4e885d4ff1">rsb_blas_get_mtx</a>(A) </div><div class="line">! Now one can use it with any <a class="code" href="namespacersb.html">rsb</a>.h/<a class="code" href="namespacersb.html">rsb</a>.F90 <span class="keyword">function</span>, e.g.: </div><div class="line">istat = <a class="code" href="group__rsb__doc__rsb.html#gad911ac7528c95c874d02cb17e6b76c54">rsb_file_mtx_save</a>(mtxAp, C_NULL_PTR) ! write to stdout </div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__rsb__doc__rsb.html#gaac3c6c033733a8101b9ccf56f8fc7112">rsb_mtx_get_coo</a>, <a class="el" href="group__rsb__doc__rsb.html#ga4adca460f50bc1ad7d9ffdfda2273b87">rsb_mtx_get_csr</a>, <a class="el" href="group__rsb__doc__rsb.html#gaa01c4a69db732f99e8a960ee8c9afa23">rsb_mtx_get_rows_sparse</a>, <a class="el" href="group__rsb__doc__rsb.html#ga42a6919ecdd030d5f8abee28f4c77089">rsb_mtx_get_coo_block</a>, <a class="el" href="group__rsb__doc__rsb.html#gadaee12cc24dac7f8ebc68efd3d09c819">rsb_mtx_get_prec</a>, <a class="el" href="group__rsb__doc__rsb.html#ga6a645ce89fd167d72c92cdcfbcd8ed81">rsb_mtx_get_nrm</a>, <a class="el" href="group__rsb__doc__rsb.html#gad0b2352cea6b7512b466d1c51327fcf8">rsb_mtx_get_vec</a>, <a class="el" href="group__rsb__doc__rsb.html#gaa79f69918eafbd8f737b7866a00a0330">rsb_file_mtx_get_dims</a>, <a class="el" href="group__rsb__doc__rsb.html#gad8f1aa9ac5081edd789374e7bb82697f">rsb_mtx_get_vals</a>, </dd>
<dd>
<a class="el" href="group__rsb__doc__rsb.html#ga2d7533a97c97b215090d69c2d9235412">rsb_mtx_upd_vals</a>, <a class="el" href="group__rsb__doc__rsb.html#gab8069ad6d5a67bc8a726131891e98c46">rsb_mtx_set_vals</a>, </dd>
<dd>
<a class="el" href="group__rsb__doc__rsb.html#ga74d97612d4af70244c886b9eadd90a0e">rsb_spmsp_to_dense</a>, <a class="el" href="group__rsb__doc__rsb.html#ga30823d02e577e59da4ccff6baaeb8ea1">rsb_sppsp</a>, <a class="el" href="group__rsb__doc__rsb.html#ga8813ccbbb1065ac76bfe22c42feafa05">rsb_spmsp</a>, <a class="el" href="group__rsb__doc__rsb.html#gaf30a70ea183d30d216f700782fc01524">rsb_mtx_add_to_dense</a>, </dd>
<dd>
<a class="el" href="group__rsb__doc__rsb.html#gab0702d7080d1699162e4201bc70cc5ee">rsb_mtx_rndr</a>, <a class="el" href="group__rsb__doc__rsb.html#ga4b45a74b985f5cbd869bc9a540951771">rsb_file_mtx_rndr</a>, </dd>
<dd>
<a class="el" href="group__rsb__doc__rsb.html#gad9a3eacd54fb7043464006cd57866edf">rsb_mtx_get_info</a>, <a class="el" href="group__rsb__doc__rsb.html#ga2b7d51b9822f73d2fe7fcf5b9d0be1e9">rsb_mtx_get_info_str</a>, <a class="el" href="group__rsb__doc__rsb.html#gad911ac7528c95c874d02cb17e6b76c54">rsb_file_mtx_save</a>, <a class="el" href="group__rsb__doc__rsb.html#gad071e0373a08f74ee7ae910e9e4fd140">rsb_file_vec_load</a>, <a class="el" href="group__rsb__doc__rsb.html#ga00833b0cf57da8e430f9d0e2b5375bb3">rsb_file_mtx_load</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is an extension implemented by <code>librsb</code> and thus it is not part of the standard. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality.</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
