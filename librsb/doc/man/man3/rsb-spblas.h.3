.TH "rsb-spblas.h" 3 "Thu Apr 28 2022" "Version 1.3.0.1" "librsb" \" -*- nroff -*-
.ad l
.nh
.SH NAME
librsb - 
rsb-spblas.h \- A Sparse BLAS interface (see http://www.netlib.org/blas/blast-forum/) to \fClibrsb\fP\&. Level 1 (vector-vector operations) is supported in a basic way\&. Level 2 (sparse matrix-dense vector operations) is supported fully\&. Level 3 (sparse matrix-dense matrix operations) is supported as a wrapper around Level 2\&.  
.SH DESCRIPTION

.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBBLAS_susdot\fP (const enum \fBblas_conj_type\fP conj, const int nnz, const float *x, const int *indx, const float *y, const int incy, float *r, const enum \fBblas_base_type\fP index_base)"
.br
.ti -1c
.RI "void \fBblas_susdot_\fP (const enum \fBblas_conj_type\fP *conj, const int *nnz, const float *x, const int *indx, const float *y, const int *incy, float *r, const enum \fBblas_base_type\fP *index_base, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_dusdot\fP (const enum \fBblas_conj_type\fP conj, const int nnz, const double *x, const int *indx, const double *y, const int incy, double *r, const enum \fBblas_base_type\fP index_base)"
.br
.ti -1c
.RI "void \fBblas_dusdot_\fP (const enum \fBblas_conj_type\fP *conj, const int *nnz, const double *x, const int *indx, const double *y, const int *incy, double *r, const enum \fBblas_base_type\fP *index_base, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_cusdot\fP (const enum \fBblas_conj_type\fP conj, const int nnz, const void *x, const int *indx, const void *y, const int incy, void *r, const enum \fBblas_base_type\fP index_base)"
.br
.ti -1c
.RI "void \fBblas_cusdot_\fP (const enum \fBblas_conj_type\fP *conj, const int *nnz, const void *x, const int *indx, const void *y, const int *incy, void *r, const enum \fBblas_base_type\fP *index_base, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_zusdot\fP (const enum \fBblas_conj_type\fP conj, const int nnz, const void *x, const int *indx, const void *y, const int incy, void *r, const enum \fBblas_base_type\fP index_base)"
.br
.ti -1c
.RI "void \fBblas_zusdot_\fP (const enum \fBblas_conj_type\fP *conj, const int *nnz, const void *x, const int *indx, const void *y, const int *incy, void *r, const enum \fBblas_base_type\fP *index_base, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_susaxpy\fP (const int nnz, float alpha, const float *x, const int *indx, float *y, const int incy, const enum \fBblas_base_type\fP index_base)"
.br
.ti -1c
.RI "void \fBblas_susaxpy_\fP (const int *nnz, float *alpha, const float *x, const int *indx, float *y, const int *incy, const enum \fBblas_base_type\fP *index_base, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_dusaxpy\fP (const int nnz, double alpha, const double *x, const int *indx, double *y, const int incy, const enum \fBblas_base_type\fP index_base)"
.br
.ti -1c
.RI "void \fBblas_dusaxpy_\fP (const int *nnz, double *alpha, const double *x, const int *indx, double *y, const int *incy, const enum \fBblas_base_type\fP *index_base, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_cusaxpy\fP (const int nnz, const void *alpha, const void *x, const int *indx, void *y, const int incy, const enum \fBblas_base_type\fP index_base)"
.br
.ti -1c
.RI "void \fBblas_cusaxpy_\fP (const int *nnz, const void *alpha, const void *x, const int *indx, void *y, const int *incy, const enum \fBblas_base_type\fP *index_base, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_zusaxpy\fP (const int nnz, const void *alpha, const void *x, const int *indx, void *y, const int incy, const enum \fBblas_base_type\fP index_base)"
.br
.ti -1c
.RI "void \fBblas_zusaxpy_\fP (const int *nnz, const void *alpha, const void *x, const int *indx, void *y, const int *incy, const enum \fBblas_base_type\fP *index_base, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_susga\fP (const int nnz, const float *y, const int incy, float *x, const int *indx, const enum \fBblas_base_type\fP index_base)"
.br
.ti -1c
.RI "void \fBblas_susga_\fP (const int *nnz, const float *y, const int *incy, float *x, const int *indx, const enum \fBblas_base_type\fP *index_base, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_dusga\fP (const int nnz, const double *y, const int incy, double *x, const int *indx, const enum \fBblas_base_type\fP index_base)"
.br
.ti -1c
.RI "void \fBblas_dusga_\fP (const int *nnz, const double *y, const int *incy, double *x, const int *indx, const enum \fBblas_base_type\fP *index_base, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_cusga\fP (const int nnz, const void *y, const int incy, void *x, const int *indx, const enum \fBblas_base_type\fP index_base)"
.br
.ti -1c
.RI "void \fBblas_cusga_\fP (const int *nnz, const void *y, const int *incy, void *x, const int *indx, const enum \fBblas_base_type\fP *index_base, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_zusga\fP (const int nnz, const void *y, const int incy, void *x, const int *indx, const enum \fBblas_base_type\fP index_base)"
.br
.ti -1c
.RI "void \fBblas_zusga_\fP (const int *nnz, const void *y, const int *incy, void *x, const int *indx, const enum \fBblas_base_type\fP *index_base, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_susgz\fP (const int nnz, float *y, const int incy, float *x, const int *indx, const enum \fBblas_base_type\fP index_base)"
.br
.ti -1c
.RI "void \fBblas_susgz_\fP (const int *nnz, float *y, const int *incy, float *x, const int *indx, const enum \fBblas_base_type\fP *index_base, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_dusgz\fP (const int nnz, double *y, const int incy, double *x, const int *indx, const enum \fBblas_base_type\fP index_base)"
.br
.ti -1c
.RI "void \fBblas_dusgz_\fP (const int *nnz, double *y, const int *incy, double *x, const int *indx, const enum \fBblas_base_type\fP *index_base, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_cusgz\fP (const int nnz, void *y, const int incy, void *x, const int *indx, const enum \fBblas_base_type\fP index_base)"
.br
.ti -1c
.RI "void \fBblas_cusgz_\fP (const int *nnz, void *y, const int *incy, void *x, const int *indx, const enum \fBblas_base_type\fP *index_base, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_zusgz\fP (const int nnz, void *y, const int incy, void *x, const int *indx, const enum \fBblas_base_type\fP index_base)"
.br
.ti -1c
.RI "void \fBblas_zusgz_\fP (const int *nnz, void *y, const int *incy, void *x, const int *indx, const enum \fBblas_base_type\fP *index_base, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_sussc\fP (const int nnz, const float *x, float *y, const int incy, const int *indx, const enum \fBblas_base_type\fP index_base)"
.br
.ti -1c
.RI "void \fBblas_sussc_\fP (const int *nnz, const float *x, float *y, const int *incy, const int *indx, const enum \fBblas_base_type\fP *index_base, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_dussc\fP (const int nnz, const double *x, double *y, const int incy, const int *indx, const enum \fBblas_base_type\fP index_base)"
.br
.ti -1c
.RI "void \fBblas_dussc_\fP (const int *nnz, const double *x, double *y, const int *incy, const int *indx, const enum \fBblas_base_type\fP *index_base, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_cussc\fP (const int nnz, const void *x, void *y, const int incy, const int *indx, const enum \fBblas_base_type\fP index_base)"
.br
.ti -1c
.RI "void \fBblas_cussc_\fP (const int *nnz, const void *x, void *y, const int *incy, const int *indx, const enum \fBblas_base_type\fP *index_base, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_zussc\fP (const int nnz, const void *x, void *y, const int incy, const int *indx, const enum \fBblas_base_type\fP index_base)"
.br
.ti -1c
.RI "void \fBblas_zussc_\fP (const int *nnz, const void *x, void *y, const int *incy, const int *indx, const enum \fBblas_base_type\fP *index_base, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_susmv\fP (const enum \fBblas_trans_type\fP transA, float alpha, const \fBblas_sparse_matrix\fP A, const float *x, const int incx, float *y, const int incy)"
.br
.ti -1c
.RI "void \fBblas_susmv_\fP (const enum \fBblas_trans_type\fP *transA, float *alpha, const \fBblas_sparse_matrix\fP *A, const float *x, const int *incx, float *y, const int *incy, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_dusmv\fP (const enum \fBblas_trans_type\fP transA, double alpha, const \fBblas_sparse_matrix\fP A, const double *x, const int incx, double *y, const int incy)"
.br
.ti -1c
.RI "void \fBblas_dusmv_\fP (const enum \fBblas_trans_type\fP *transA, double *alpha, const \fBblas_sparse_matrix\fP *A, const double *x, const int *incx, double *y, const int *incy, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_cusmv\fP (const enum \fBblas_trans_type\fP transA, const void *alpha, const \fBblas_sparse_matrix\fP A, const void *x, const int incx, void *y, const int incy)"
.br
.ti -1c
.RI "void \fBblas_cusmv_\fP (const enum \fBblas_trans_type\fP *transA, const void *alpha, const \fBblas_sparse_matrix\fP *A, const void *x, const int *incx, void *y, const int *incy, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_zusmv\fP (const enum \fBblas_trans_type\fP transA, const void *alpha, const \fBblas_sparse_matrix\fP A, const void *x, const int incx, void *y, const int incy)"
.br
.ti -1c
.RI "void \fBblas_zusmv_\fP (const enum \fBblas_trans_type\fP *transA, const void *alpha, const \fBblas_sparse_matrix\fP *A, const void *x, const int *incx, void *y, const int *incy, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_sussv\fP (enum \fBblas_trans_type\fP transT, float alpha, const \fBblas_sparse_matrix\fP T, float *x, const int incx)"
.br
.ti -1c
.RI "void \fBblas_sussv_\fP (enum \fBblas_trans_type\fP *transT, float *alpha, const \fBblas_sparse_matrix\fP *T, float *x, const int *incx, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_dussv\fP (enum \fBblas_trans_type\fP transT, double alpha, const \fBblas_sparse_matrix\fP T, double *x, const int incx)"
.br
.ti -1c
.RI "void \fBblas_dussv_\fP (enum \fBblas_trans_type\fP *transT, double *alpha, const \fBblas_sparse_matrix\fP *T, double *x, const int *incx, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_cussv\fP (enum \fBblas_trans_type\fP transT, const void *alpha, const \fBblas_sparse_matrix\fP T, void *x, const int incx)"
.br
.ti -1c
.RI "void \fBblas_cussv_\fP (enum \fBblas_trans_type\fP *transT, const void *alpha, const \fBblas_sparse_matrix\fP *T, void *x, const int *incx, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_zussv\fP (enum \fBblas_trans_type\fP transT, const void *alpha, const \fBblas_sparse_matrix\fP T, void *x, const int incx)"
.br
.ti -1c
.RI "void \fBblas_zussv_\fP (enum \fBblas_trans_type\fP *transT, const void *alpha, const \fBblas_sparse_matrix\fP *T, void *x, const int *incx, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_susmm\fP (const enum \fBblas_order_type\fP order, const enum \fBblas_trans_type\fP transA, const int nrhs, float alpha, const \fBblas_sparse_matrix\fP A, const float *b, const int ldb, float *c, const int ldc)"
.br
.ti -1c
.RI "void \fBblas_susmm_\fP (const enum \fBblas_order_type\fP *order, const enum \fBblas_trans_type\fP *transA, const int *nrhs, float *alpha, const \fBblas_sparse_matrix\fP *A, const float *b, const int *ldb, float *c, const int *ldc, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_dusmm\fP (const enum \fBblas_order_type\fP order, const enum \fBblas_trans_type\fP transA, const int nrhs, double alpha, const \fBblas_sparse_matrix\fP A, const double *b, const int ldb, double *c, const int ldc)"
.br
.ti -1c
.RI "void \fBblas_dusmm_\fP (const enum \fBblas_order_type\fP *order, const enum \fBblas_trans_type\fP *transA, const int *nrhs, double *alpha, const \fBblas_sparse_matrix\fP *A, const double *b, const int *ldb, double *c, const int *ldc, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_cusmm\fP (const enum \fBblas_order_type\fP order, const enum \fBblas_trans_type\fP transA, const int nrhs, const void *alpha, const \fBblas_sparse_matrix\fP A, const void *b, const int ldb, void *c, const int ldc)"
.br
.ti -1c
.RI "void \fBblas_cusmm_\fP (const enum \fBblas_order_type\fP *order, const enum \fBblas_trans_type\fP *transA, const int *nrhs, const void *alpha, const \fBblas_sparse_matrix\fP *A, const void *b, const int *ldb, void *c, const int *ldc, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_zusmm\fP (const enum \fBblas_order_type\fP order, const enum \fBblas_trans_type\fP transA, const int nrhs, const void *alpha, const \fBblas_sparse_matrix\fP A, const void *b, const int ldb, void *c, const int ldc)"
.br
.ti -1c
.RI "void \fBblas_zusmm_\fP (const enum \fBblas_order_type\fP *order, const enum \fBblas_trans_type\fP *transA, const int *nrhs, const void *alpha, const \fBblas_sparse_matrix\fP *A, const void *b, const int *ldb, void *c, const int *ldc, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_sussm\fP (const enum \fBblas_order_type\fP order, const enum \fBblas_trans_type\fP transT, const int nrhs, float alpha, const \fBblas_sparse_matrix\fP T, float *b, const int ldb)"
.br
.ti -1c
.RI "void \fBblas_sussm_\fP (const enum \fBblas_order_type\fP *order, const enum \fBblas_trans_type\fP *transT, const int *nrhs, float *alpha, const \fBblas_sparse_matrix\fP *T, float *b, const int *ldb, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_dussm\fP (const enum \fBblas_order_type\fP order, const enum \fBblas_trans_type\fP transT, const int nrhs, double alpha, const \fBblas_sparse_matrix\fP T, double *b, const int ldb)"
.br
.ti -1c
.RI "void \fBblas_dussm_\fP (const enum \fBblas_order_type\fP *order, const enum \fBblas_trans_type\fP *transT, const int *nrhs, double *alpha, const \fBblas_sparse_matrix\fP *T, double *b, const int *ldb, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_cussm\fP (const enum \fBblas_order_type\fP order, const enum \fBblas_trans_type\fP transT, const int nrhs, const void *alpha, const \fBblas_sparse_matrix\fP T, void *b, const int ldb)"
.br
.ti -1c
.RI "void \fBblas_cussm_\fP (const enum \fBblas_order_type\fP *order, const enum \fBblas_trans_type\fP *transT, const int *nrhs, const void *alpha, const \fBblas_sparse_matrix\fP *T, void *b, const int *ldb, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_zussm\fP (const enum \fBblas_order_type\fP order, const enum \fBblas_trans_type\fP transT, const int nrhs, const void *alpha, const \fBblas_sparse_matrix\fP T, void *b, const int ldb)"
.br
.ti -1c
.RI "void \fBblas_zussm_\fP (const enum \fBblas_order_type\fP *order, const enum \fBblas_trans_type\fP *transT, const int *nrhs, const void *alpha, const \fBblas_sparse_matrix\fP *T, void *b, const int *ldb, int *istat)"
.br
.ti -1c
.RI "\fBblas_sparse_matrix\fP \fBBLAS_suscr_begin\fP (int m, int n)"
.br
.ti -1c
.RI "void \fBblas_suscr_begin_\fP (int *m, int *n, \fBblas_sparse_matrix\fP *A, int *istat)"
.br
.ti -1c
.RI "\fBblas_sparse_matrix\fP \fBBLAS_duscr_begin\fP (int m, int n)"
.br
.ti -1c
.RI "void \fBblas_duscr_begin_\fP (int *m, int *n, \fBblas_sparse_matrix\fP *A, int *istat)"
.br
.ti -1c
.RI "\fBblas_sparse_matrix\fP \fBBLAS_cuscr_begin\fP (int m, int n)"
.br
.ti -1c
.RI "void \fBblas_cuscr_begin_\fP (int *m, int *n, \fBblas_sparse_matrix\fP *A, int *istat)"
.br
.ti -1c
.RI "\fBblas_sparse_matrix\fP \fBBLAS_zuscr_begin\fP (int m, int n)"
.br
.ti -1c
.RI "void \fBblas_zuscr_begin_\fP (int *m, int *n, \fBblas_sparse_matrix\fP *A, int *istat)"
.br
.ti -1c
.RI "\fBblas_sparse_matrix\fP \fBBLAS_suscr_block_begin\fP (int Mb, int Nb, int k, int l)"
.br
.ti -1c
.RI "void \fBblas_suscr_block_begin_\fP (int *Mb, int *Nb, int *k, int *l, \fBblas_sparse_matrix\fP *A, int *istat)"
.br
.ti -1c
.RI "\fBblas_sparse_matrix\fP \fBBLAS_duscr_block_begin\fP (int Mb, int Nb, int k, int l)"
.br
.ti -1c
.RI "void \fBblas_duscr_block_begin_\fP (int *Mb, int *Nb, int *k, int *l, \fBblas_sparse_matrix\fP *A, int *istat)"
.br
.ti -1c
.RI "\fBblas_sparse_matrix\fP \fBBLAS_cuscr_block_begin\fP (int Mb, int Nb, int k, int l)"
.br
.ti -1c
.RI "void \fBblas_cuscr_block_begin_\fP (int *Mb, int *Nb, int *k, int *l, \fBblas_sparse_matrix\fP *A, int *istat)"
.br
.ti -1c
.RI "\fBblas_sparse_matrix\fP \fBBLAS_zuscr_block_begin\fP (int Mb, int Nb, int k, int l)"
.br
.ti -1c
.RI "void \fBblas_zuscr_block_begin_\fP (int *Mb, int *Nb, int *k, int *l, \fBblas_sparse_matrix\fP *A, int *istat)"
.br
.ti -1c
.RI "\fBblas_sparse_matrix\fP \fBBLAS_suscr_variable_block_begin\fP (int Mb, int Nb, const int *K, const int *L)"
.br
.ti -1c
.RI "void \fBblas_suscr_variable_block_begin_\fP (int *Mb, int *Nb, const int *K, const int *L, \fBblas_sparse_matrix\fP *A, int *istat)"
.br
.ti -1c
.RI "\fBblas_sparse_matrix\fP \fBBLAS_duscr_variable_block_begin\fP (int Mb, int Nb, const int *K, const int *L)"
.br
.ti -1c
.RI "void \fBblas_duscr_variable_block_begin_\fP (int *Mb, int *Nb, const int *K, const int *L, \fBblas_sparse_matrix\fP *A, int *istat)"
.br
.ti -1c
.RI "\fBblas_sparse_matrix\fP \fBBLAS_cuscr_variable_block_begin\fP (int Mb, int Nb, const int *K, const int *L)"
.br
.ti -1c
.RI "void \fBblas_cuscr_variable_block_begin_\fP (int *Mb, int *Nb, const int *K, const int *L, \fBblas_sparse_matrix\fP *A, int *istat)"
.br
.ti -1c
.RI "\fBblas_sparse_matrix\fP \fBBLAS_zuscr_variable_block_begin\fP (int Mb, int Nb, const int *K, const int *L)"
.br
.ti -1c
.RI "void \fBblas_zuscr_variable_block_begin_\fP (int *Mb, int *Nb, const int *K, const int *L, \fBblas_sparse_matrix\fP *A, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_suscr_end\fP (\fBblas_sparse_matrix\fP A)"
.br
.ti -1c
.RI "void \fBblas_suscr_end_\fP (\fBblas_sparse_matrix\fP *A, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_duscr_end\fP (\fBblas_sparse_matrix\fP A)"
.br
.ti -1c
.RI "void \fBblas_duscr_end_\fP (\fBblas_sparse_matrix\fP *A, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_cuscr_end\fP (\fBblas_sparse_matrix\fP A)"
.br
.ti -1c
.RI "void \fBblas_cuscr_end_\fP (\fBblas_sparse_matrix\fP *A, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_zuscr_end\fP (\fBblas_sparse_matrix\fP A)"
.br
.ti -1c
.RI "void \fBblas_zuscr_end_\fP (\fBblas_sparse_matrix\fP *A, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_suscr_insert_entry\fP (\fBblas_sparse_matrix\fP A, float val, int i, int j)"
.br
.ti -1c
.RI "void \fBblas_suscr_insert_entry_\fP (\fBblas_sparse_matrix\fP *A, float *val, int *i, int *j, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_duscr_insert_entry\fP (\fBblas_sparse_matrix\fP A, double val, int i, int j)"
.br
.ti -1c
.RI "void \fBblas_duscr_insert_entry_\fP (\fBblas_sparse_matrix\fP *A, double *val, int *i, int *j, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_cuscr_insert_entry\fP (\fBblas_sparse_matrix\fP A, const void *val, int i, int j)"
.br
.ti -1c
.RI "void \fBblas_cuscr_insert_entry_\fP (\fBblas_sparse_matrix\fP *A, const void *val, int *i, int *j, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_zuscr_insert_entry\fP (\fBblas_sparse_matrix\fP A, const void *val, int i, int j)"
.br
.ti -1c
.RI "void \fBblas_zuscr_insert_entry_\fP (\fBblas_sparse_matrix\fP *A, const void *val, int *i, int *j, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_suscr_insert_entries\fP (\fBblas_sparse_matrix\fP A, int nnz, const float *val, const int *indx, const int *jndx)"
.br
.ti -1c
.RI "void \fBblas_suscr_insert_entries_\fP (\fBblas_sparse_matrix\fP *A, int *nnz, const float *val, const int *indx, const int *jndx, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_duscr_insert_entries\fP (\fBblas_sparse_matrix\fP A, int nnz, const double *val, const int *indx, const int *jndx)"
.br
.ti -1c
.RI "void \fBblas_duscr_insert_entries_\fP (\fBblas_sparse_matrix\fP *A, int *nnz, const double *val, const int *indx, const int *jndx, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_cuscr_insert_entries\fP (\fBblas_sparse_matrix\fP A, int nnz, const void *val, const int *indx, const int *jndx)"
.br
.ti -1c
.RI "void \fBblas_cuscr_insert_entries_\fP (\fBblas_sparse_matrix\fP *A, int *nnz, const void *val, const int *indx, const int *jndx, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_zuscr_insert_entries\fP (\fBblas_sparse_matrix\fP A, int nnz, const void *val, const int *indx, const int *jndx)"
.br
.ti -1c
.RI "void \fBblas_zuscr_insert_entries_\fP (\fBblas_sparse_matrix\fP *A, int *nnz, const void *val, const int *indx, const int *jndx, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_suscr_insert_col\fP (\fBblas_sparse_matrix\fP A, int j, int nnz, const float *val, const int *indx)"
.br
.ti -1c
.RI "void \fBblas_suscr_insert_col_\fP (\fBblas_sparse_matrix\fP *A, int *j, int *nnz, const float *val, const int *indx, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_duscr_insert_col\fP (\fBblas_sparse_matrix\fP A, int j, int nnz, const double *val, const int *indx)"
.br
.ti -1c
.RI "void \fBblas_duscr_insert_col_\fP (\fBblas_sparse_matrix\fP *A, int *j, int *nnz, const double *val, const int *indx, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_cuscr_insert_col\fP (\fBblas_sparse_matrix\fP A, int j, int nnz, const void *val, const int *indx)"
.br
.ti -1c
.RI "void \fBblas_cuscr_insert_col_\fP (\fBblas_sparse_matrix\fP *A, int *j, int *nnz, const void *val, const int *indx, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_zuscr_insert_col\fP (\fBblas_sparse_matrix\fP A, int j, int nnz, const void *val, const int *indx)"
.br
.ti -1c
.RI "void \fBblas_zuscr_insert_col_\fP (\fBblas_sparse_matrix\fP *A, int *j, int *nnz, const void *val, const int *indx, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_suscr_insert_row\fP (\fBblas_sparse_matrix\fP A, int i, int nnz, const float *val, const int *indx)"
.br
.ti -1c
.RI "void \fBblas_suscr_insert_row_\fP (\fBblas_sparse_matrix\fP *A, int *i, int *nnz, const float *val, const int *indx, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_duscr_insert_row\fP (\fBblas_sparse_matrix\fP A, int i, int nnz, const double *val, const int *indx)"
.br
.ti -1c
.RI "void \fBblas_duscr_insert_row_\fP (\fBblas_sparse_matrix\fP *A, int *i, int *nnz, const double *val, const int *indx, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_cuscr_insert_row\fP (\fBblas_sparse_matrix\fP A, int i, int nnz, const void *val, const int *indx)"
.br
.ti -1c
.RI "void \fBblas_cuscr_insert_row_\fP (\fBblas_sparse_matrix\fP *A, int *i, int *nnz, const void *val, const int *indx, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_zuscr_insert_row\fP (\fBblas_sparse_matrix\fP A, int i, int nnz, const void *val, const int *indx)"
.br
.ti -1c
.RI "void \fBblas_zuscr_insert_row_\fP (\fBblas_sparse_matrix\fP *A, int *i, int *nnz, const void *val, const int *indx, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_suscr_insert_clique\fP (\fBblas_sparse_matrix\fP A, const int k, const int l, const float *val, const int row_stride, const int col_stride, const int *indx, const int *jndx)"
.br
.ti -1c
.RI "void \fBblas_suscr_insert_clique_\fP (\fBblas_sparse_matrix\fP *A, const int *k, const int *l, const float *val, const int *row_stride, const int *col_stride, const int *indx, const int *jndx, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_duscr_insert_clique\fP (\fBblas_sparse_matrix\fP A, const int k, const int l, const double *val, const int row_stride, const int col_stride, const int *indx, const int *jndx)"
.br
.ti -1c
.RI "void \fBblas_duscr_insert_clique_\fP (\fBblas_sparse_matrix\fP *A, const int *k, const int *l, const double *val, const int *row_stride, const int *col_stride, const int *indx, const int *jndx, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_cuscr_insert_clique\fP (\fBblas_sparse_matrix\fP A, const int k, const int l, const void *val, const int row_stride, const int col_stride, const int *indx, const int *jndx)"
.br
.ti -1c
.RI "void \fBblas_cuscr_insert_clique_\fP (\fBblas_sparse_matrix\fP *A, const int *k, const int *l, const void *val, const int *row_stride, const int *col_stride, const int *indx, const int *jndx, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_zuscr_insert_clique\fP (\fBblas_sparse_matrix\fP A, const int k, const int l, const void *val, const int row_stride, const int col_stride, const int *indx, const int *jndx)"
.br
.ti -1c
.RI "void \fBblas_zuscr_insert_clique_\fP (\fBblas_sparse_matrix\fP *A, const int *k, const int *l, const void *val, const int *row_stride, const int *col_stride, const int *indx, const int *jndx, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_suscr_insert_block\fP (\fBblas_sparse_matrix\fP A, const float *val, int row_stride, int col_stride, int i, int j)"
.br
.ti -1c
.RI "void \fBblas_suscr_insert_block_\fP (\fBblas_sparse_matrix\fP *A, const float *val, int *row_stride, int *col_stride, int *i, int *j, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_duscr_insert_block\fP (\fBblas_sparse_matrix\fP A, const double *val, int row_stride, int col_stride, int i, int j)"
.br
.ti -1c
.RI "void \fBblas_duscr_insert_block_\fP (\fBblas_sparse_matrix\fP *A, const double *val, int *row_stride, int *col_stride, int *i, int *j, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_cuscr_insert_block\fP (\fBblas_sparse_matrix\fP A, const void *val, int row_stride, int col_stride, int i, int j)"
.br
.ti -1c
.RI "void \fBblas_cuscr_insert_block_\fP (\fBblas_sparse_matrix\fP *A, const void *val, int *row_stride, int *col_stride, int *i, int *j, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_zuscr_insert_block\fP (\fBblas_sparse_matrix\fP A, const void *val, int row_stride, int col_stride, int i, int j)"
.br
.ti -1c
.RI "void \fBblas_zuscr_insert_block_\fP (\fBblas_sparse_matrix\fP *A, const void *val, int *row_stride, int *col_stride, int *i, int *j, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_uscr_end\fP (\fBblas_sparse_matrix\fP A)"
.br
.ti -1c
.RI "void \fBblas_uscr_end_\fP (\fBblas_sparse_matrix\fP *A, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_usds\fP (\fBblas_sparse_matrix\fP A)"
.br
.ti -1c
.RI "void \fBblas_usds_\fP (\fBblas_sparse_matrix\fP *A, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_susrows_scale\fP (\fBblas_sparse_matrix\fP A, const float *d, const enum \fBblas_trans_type\fP trans)"
.br
.ti -1c
.RI "void \fBblas_susrows_scale_\fP (\fBblas_sparse_matrix\fP *A, const float *d, const enum \fBblas_trans_type\fP *trans, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_dusrows_scale\fP (\fBblas_sparse_matrix\fP A, const double *d, const enum \fBblas_trans_type\fP trans)"
.br
.ti -1c
.RI "void \fBblas_dusrows_scale_\fP (\fBblas_sparse_matrix\fP *A, const double *d, const enum \fBblas_trans_type\fP *trans, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_cusrows_scale\fP (\fBblas_sparse_matrix\fP A, const void *d, const enum \fBblas_trans_type\fP trans)"
.br
.ti -1c
.RI "void \fBblas_cusrows_scale_\fP (\fBblas_sparse_matrix\fP *A, const void *d, const enum \fBblas_trans_type\fP *trans, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_zusrows_scale\fP (\fBblas_sparse_matrix\fP A, const void *d, const enum \fBblas_trans_type\fP trans)"
.br
.ti -1c
.RI "void \fBblas_zusrows_scale_\fP (\fBblas_sparse_matrix\fP *A, const void *d, const enum \fBblas_trans_type\fP *trans, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_susget_diag\fP (\fBblas_sparse_matrix\fP A, float *d)"
.br
.ti -1c
.RI "void \fBblas_susget_diag_\fP (\fBblas_sparse_matrix\fP *A, float *d, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_dusget_diag\fP (\fBblas_sparse_matrix\fP A, double *d)"
.br
.ti -1c
.RI "void \fBblas_dusget_diag_\fP (\fBblas_sparse_matrix\fP *A, double *d, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_cusget_diag\fP (\fBblas_sparse_matrix\fP A, void *d)"
.br
.ti -1c
.RI "void \fBblas_cusget_diag_\fP (\fBblas_sparse_matrix\fP *A, void *d, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_zusget_diag\fP (\fBblas_sparse_matrix\fP A, void *d)"
.br
.ti -1c
.RI "void \fBblas_zusget_diag_\fP (\fBblas_sparse_matrix\fP *A, void *d, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_susget_rows_nnz\fP (\fBblas_sparse_matrix\fP A, const int fr, const int lr, int *nnzp)"
.br
.ti -1c
.RI "void \fBblas_susget_rows_nnz_\fP (\fBblas_sparse_matrix\fP *A, const int *fr, const int *lr, int *nnzp, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_dusget_rows_nnz\fP (\fBblas_sparse_matrix\fP A, const int fr, const int lr, int *nnzp)"
.br
.ti -1c
.RI "void \fBblas_dusget_rows_nnz_\fP (\fBblas_sparse_matrix\fP *A, const int *fr, const int *lr, int *nnzp, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_cusget_rows_nnz\fP (\fBblas_sparse_matrix\fP A, const int fr, const int lr, int *nnzp)"
.br
.ti -1c
.RI "void \fBblas_cusget_rows_nnz_\fP (\fBblas_sparse_matrix\fP *A, const int *fr, const int *lr, int *nnzp, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_zusget_rows_nnz\fP (\fBblas_sparse_matrix\fP A, const int fr, const int lr, int *nnzp)"
.br
.ti -1c
.RI "void \fBblas_zusget_rows_nnz_\fP (\fBblas_sparse_matrix\fP *A, const int *fr, const int *lr, int *nnzp, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_susget_rows_sparse\fP (\fBblas_sparse_matrix\fP A, float *VA, int *IA, int *JA, int *nnz, const int fr, const int lr)"
.br
.ti -1c
.RI "void \fBblas_susget_rows_sparse_\fP (\fBblas_sparse_matrix\fP *A, float *VA, int *IA, int *JA, int *nnz, const int *fr, const int *lr, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_dusget_rows_sparse\fP (\fBblas_sparse_matrix\fP A, double *VA, int *IA, int *JA, int *nnz, const int fr, const int lr)"
.br
.ti -1c
.RI "void \fBblas_dusget_rows_sparse_\fP (\fBblas_sparse_matrix\fP *A, double *VA, int *IA, int *JA, int *nnz, const int *fr, const int *lr, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_cusget_rows_sparse\fP (\fBblas_sparse_matrix\fP A, void *VA, int *IA, int *JA, int *nnz, const int fr, const int lr)"
.br
.ti -1c
.RI "void \fBblas_cusget_rows_sparse_\fP (\fBblas_sparse_matrix\fP *A, void *VA, int *IA, int *JA, int *nnz, const int *fr, const int *lr, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_zusget_rows_sparse\fP (\fBblas_sparse_matrix\fP A, void *VA, int *IA, int *JA, int *nnz, const int fr, const int lr)"
.br
.ti -1c
.RI "void \fBblas_zusget_rows_sparse_\fP (\fBblas_sparse_matrix\fP *A, void *VA, int *IA, int *JA, int *nnz, const int *fr, const int *lr, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_susget_matrix_nnz\fP (\fBblas_sparse_matrix\fP A, int *nnz)"
.br
.ti -1c
.RI "void \fBblas_susget_matrix_nnz_\fP (\fBblas_sparse_matrix\fP *A, int *nnz, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_dusget_matrix_nnz\fP (\fBblas_sparse_matrix\fP A, int *nnz)"
.br
.ti -1c
.RI "void \fBblas_dusget_matrix_nnz_\fP (\fBblas_sparse_matrix\fP *A, int *nnz, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_cusget_matrix_nnz\fP (\fBblas_sparse_matrix\fP A, int *nnz)"
.br
.ti -1c
.RI "void \fBblas_cusget_matrix_nnz_\fP (\fBblas_sparse_matrix\fP *A, int *nnz, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_zusget_matrix_nnz\fP (\fBblas_sparse_matrix\fP A, int *nnz)"
.br
.ti -1c
.RI "void \fBblas_zusget_matrix_nnz_\fP (\fBblas_sparse_matrix\fP *A, int *nnz, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_susget_infinity_norm\fP (\fBblas_sparse_matrix\fP A, float *in, const enum \fBblas_trans_type\fP trans)"
.br
.ti -1c
.RI "void \fBblas_susget_infinity_norm_\fP (\fBblas_sparse_matrix\fP *A, float *in, const enum \fBblas_trans_type\fP *trans, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_dusget_infinity_norm\fP (\fBblas_sparse_matrix\fP A, double *in, const enum \fBblas_trans_type\fP trans)"
.br
.ti -1c
.RI "void \fBblas_dusget_infinity_norm_\fP (\fBblas_sparse_matrix\fP *A, double *in, const enum \fBblas_trans_type\fP *trans, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_cusget_infinity_norm\fP (\fBblas_sparse_matrix\fP A, void *in, const enum \fBblas_trans_type\fP trans)"
.br
.ti -1c
.RI "void \fBblas_cusget_infinity_norm_\fP (\fBblas_sparse_matrix\fP *A, void *in, const enum \fBblas_trans_type\fP *trans, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_zusget_infinity_norm\fP (\fBblas_sparse_matrix\fP A, void *in, const enum \fBblas_trans_type\fP trans)"
.br
.ti -1c
.RI "void \fBblas_zusget_infinity_norm_\fP (\fBblas_sparse_matrix\fP *A, void *in, const enum \fBblas_trans_type\fP *trans, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_susset_elements\fP (\fBblas_sparse_matrix\fP A, const int *ia, const int *ja, const float *va, const int nnz)"
.br
.ti -1c
.RI "void \fBblas_susset_elements_\fP (\fBblas_sparse_matrix\fP *A, const int *ia, const int *ja, const float *va, const int *nnz, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_dusset_elements\fP (\fBblas_sparse_matrix\fP A, const int *ia, const int *ja, const double *va, const int nnz)"
.br
.ti -1c
.RI "void \fBblas_dusset_elements_\fP (\fBblas_sparse_matrix\fP *A, const int *ia, const int *ja, const double *va, const int *nnz, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_cusset_elements\fP (\fBblas_sparse_matrix\fP A, const int *ia, const int *ja, const void *va, const int nnz)"
.br
.ti -1c
.RI "void \fBblas_cusset_elements_\fP (\fBblas_sparse_matrix\fP *A, const int *ia, const int *ja, const void *va, const int *nnz, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_zusset_elements\fP (\fBblas_sparse_matrix\fP A, const int *ia, const int *ja, const void *va, const int nnz)"
.br
.ti -1c
.RI "void \fBblas_zusset_elements_\fP (\fBblas_sparse_matrix\fP *A, const int *ia, const int *ja, const void *va, const int *nnz, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_susset_element\fP (\fBblas_sparse_matrix\fP A, const int i, const int j, float *v)"
.br
.ti -1c
.RI "void \fBblas_susset_element_\fP (\fBblas_sparse_matrix\fP *A, const int *i, const int *j, float *v, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_dusset_element\fP (\fBblas_sparse_matrix\fP A, const int i, const int j, double *v)"
.br
.ti -1c
.RI "void \fBblas_dusset_element_\fP (\fBblas_sparse_matrix\fP *A, const int *i, const int *j, double *v, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_cusset_element\fP (\fBblas_sparse_matrix\fP A, const int i, const int j, void *v)"
.br
.ti -1c
.RI "void \fBblas_cusset_element_\fP (\fBblas_sparse_matrix\fP *A, const int *i, const int *j, void *v, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_zusset_element\fP (\fBblas_sparse_matrix\fP A, const int i, const int j, void *v)"
.br
.ti -1c
.RI "void \fBblas_zusset_element_\fP (\fBblas_sparse_matrix\fP *A, const int *i, const int *j, void *v, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_susget_element\fP (\fBblas_sparse_matrix\fP A, const int i, const int j, float *v)"
.br
.ti -1c
.RI "void \fBblas_susget_element_\fP (\fBblas_sparse_matrix\fP *A, const int *i, const int *j, float *v, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_dusget_element\fP (\fBblas_sparse_matrix\fP A, const int i, const int j, double *v)"
.br
.ti -1c
.RI "void \fBblas_dusget_element_\fP (\fBblas_sparse_matrix\fP *A, const int *i, const int *j, double *v, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_cusget_element\fP (\fBblas_sparse_matrix\fP A, const int i, const int j, void *v)"
.br
.ti -1c
.RI "void \fBblas_cusget_element_\fP (\fBblas_sparse_matrix\fP *A, const int *i, const int *j, void *v, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_zusget_element\fP (\fBblas_sparse_matrix\fP A, const int i, const int j, void *v)"
.br
.ti -1c
.RI "void \fBblas_zusget_element_\fP (\fBblas_sparse_matrix\fP *A, const int *i, const int *j, void *v, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_usgp\fP (\fBblas_sparse_matrix\fP A, rsb_blas_pname_t pname)"
.br
.ti -1c
.RI "void \fBblas_usgp_\fP (\fBblas_sparse_matrix\fP *A, rsb_blas_pname_t *pname, int *istat)"
.br
.ti -1c
.RI "void \fBblas_ussp_\fP (\fBblas_sparse_matrix\fP *A, rsb_blas_pname_t *pname, int *istat)"
.br
.ti -1c
.RI "int \fBBLAS_ussp\fP (\fBblas_sparse_matrix\fP A, rsb_blas_pname_t pname)"
.br
.ti -1c
.RI "\fBblas_sparse_matrix\fP \fBrsb_blas_file_mtx_load\fP (const \fBrsb_char_t\fP *filename, \fBrsb_type_t\fP typecode)"
.br
.ti -1c
.RI "struct rsb_mtx_t * \fBrsb_blas_get_mtx\fP (\fBblas_sparse_matrix\fP A)"
.br
.in -1c
.SH "Detailed Description"
.PP 
A Sparse BLAS interface (see http://www.netlib.org/blas/blast-forum/) to \fClibrsb\fP\&. Level 1 (vector-vector operations) is supported in a basic way\&. Level 2 (sparse matrix-dense vector operations) is supported fully\&. Level 3 (sparse matrix-dense matrix operations) is supported as a wrapper around Level 2\&. 

We also implement a number of useful extra functions as custom extensions, giving access to other \fClibrsb\fP functionality\&.
.PP
The usage pattern of this interface matches that of the Sparse BLAS standard, exception made for the necessity of initialization/finalization of \fClibrsb\fP\&. The Sparse BLAS interface is also available for Fortran: see \fBrsb_blas_sparse\&.F90\fP\&.
.PP
The user should be aware of the following: 
.PD 0

.IP "\(bu" 2
Because this Sparse BLAS implementation is built around \fClibrsb\fP, initialization with \fBrsb_lib_init()\fP and finalization with \fBrsb_lib_exit()\fP is necessary\&. Inclusion of the \fC\fBrsb\&.h\fP\fP header is necessary\&. 
.IP "\(bu" 2
\fClibrsb\fP gives users freedom of in/out arbitrarily BLAS types support at configure/build time\&. Hence, while all the interface functions are always included the Sparse BLAS header file, they may return an error code\&. Be sure of having configured correctly the library at configure time (and see the \fBblas_sparse\&.h\fP header file for types configured in the current build)\&. 
.IP "\(bu" 2
According to the standard, the complex type functions for C accept scalar values by reference rather than by copy; equivalent functions for other types do not do so, so this may cause confusion\&. Be careful\&. 
.IP "\(bu" 2
Error checking is weak; so for instance, passing a function the handle of a matrix of mismatching type will not be detected as an error, although it's incorrect\&. 
.IP "\(bu" 2
According to the standard, VBR and BCSR styled constructors are supported, although these are interfaces for \fClibrsb's\fP own matrix representation\&. 
.IP "\(bu" 2
Here functions for both Fortran and C are listed\&. The Fortran functions are declared and documented with the C notation\&. We may provide a better documentation in a future release\&. 
.IP "\(bu" 2
Each identifier documented here suffixed by \fC_\fP (e\&.g\&.: \fBblas_susdot_()\fP) can be used from Fortran with the name stripped by that suffix (so in this case, \fCblas_susdot\fP)\&. We may provide a proper fix to this inconvenience in a subsequent release\&. 
.IP "\(bu" 2
Each Fortran program using \fClibrsb's\fP Sparse BLAS Implementation shall \fCuse\fP modules \fC\fBblas_sparse\fP\fP and \fCrsb\fP\&. 
.IP "\(bu" 2
Also Fortran programs have to call \fBrsb_lib_init()\fP and \fBrsb_lib_exit()\fP e\&.g\&.: 
.PP
.nf
        USE blas_sparse             ! module implementing the Sparse BLAS on the top of librsb
        USE rsb                     ! rsb module
        ...
        INTEGER :: istat            ! integer variable
        ...
        istat = rsb_lib_init(RSB_NULL_INIT_OPTIONS) ! please note that this is not part of Sparse BLAS but it is needed by librsb
        if(istat.NE.0)STOP          ! a value different than zero signals an error
        ...
        ! code calling Sparse BLAS routines
        ...
        istat = rsb_lib_exit(RSB_NULL_EXIT_OPTIONS) ! please note that this is not part of Sparse BLAS but it is needed by librsb
        if(istat.NE.0)STOP          ! a value different than zero signals an error
        ...

.fi
.PP
 
.IP "\(bu" 2
For Fortran, more procedures exist, although they are not documented here\&. According to the Sparse BLAS (http://www.netlib.org/blas/blast-forum/), for almost each subroutine whose identifier prefixed with \fCblas_X\fP (with \fCX\fP being one of S,D,C,Z), a corresponding generic modern Fortran version exists\&. Please note how not all of the certain procedures identifier prefixes include the type character\&.
.PP
E\&.g\&.: 
.PP
.nf
! the following code ('d' stays for 'double precision'):
CALL blas_duscr_begin(nr,nc,A,istat)
CALL blas_ussp(A,blas_lower_symmetric,istat)
CALL blas_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
CALL blas_duscr_end(A,istat)
CALL blas_dusmv(transT,alpha,A,X,incX,B,incB,istat) 
CALL blas_dusds(A,istat)
! is equivalent to:
CALL duscr_begin(nr,nc,A,istat) ! here, 'd' must be retained for avoiding ambiguity
CALL ussp(A,blas_lower_symmetric,istat)
CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
CALL uscr_end(A,istat)
CALL usmv(transT,alpha,A,X,incX,B,incB,istat) 
CALL usds(A,istat)

.fi
.PP
 
.SH "Function Documentation"
.PP 
.SS "int BLAS_cusaxpy (const int nnz, const void * alpha, const void * x, const int * indx, void * y, const int incy, const enum \fBblas_base_type\fP index_base)"
Sparse vector update: $Y <- alpha X + Y$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&. 
.br
\fIalpha\fP Will scale values of $X$ before accumulating to $Y$\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "void blas_cusaxpy_ (const int * nnz, const void * alpha, const void * x, const int * indx, void * y, const int * incy, const enum \fBblas_base_type\fP * index_base, int * istat)"
Sparse vector update: $Y <- alpha X + Y$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&. 
.br
\fIalpha\fP Will scale values of $X$ before accumulating to $Y$\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "\fBblas_sparse_matrix\fP BLAS_cuscr_begin (int m, int n)"
Allocates an empty matrix (A) and leaves it in build state\&. 
.PP
\fBParameters:\fP
.RS 4
\fIm\fP Is the count of rows\&. 
.br
\fIn\fP Is the count of columns\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A matrix handle in case of success, or -1 on error\&.
.RE
.PP

.SS "void blas_cuscr_begin_ (int * m, int * n, \fBblas_sparse_matrix\fP * A, int * istat)"
Allocates an empty matrix (A) and leaves it in build state\&. 
.PP
\fBParameters:\fP
.RS 4
\fIm\fP Is the count of rows\&. 
.br
\fIn\fP Is the count of columns\&.
.br
\fIA\fP A valid pointer to an empty matrix handle\&. 
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. Will assign a valid matrix handle to $A$ in case of success, or set it to -1 on error\&.
.RE
.PP

.SS "\fBblas_sparse_matrix\fP BLAS_cuscr_block_begin (int Mb, int Nb, int k, int l)"
Allocates an empty matrix (A) and leaves it in build state\&. 
.PP
\fBParameters:\fP
.RS 4
\fIk,l\fP Are row and column dimensions when specifying a matrix as BCSR\&. 
.br
\fIMb\fP Block rows count\&. 
.br
\fINb\fP Block columns count\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A matrix handle in case of success, or -1 on error\&.
.RE
.PP

.SS "void blas_cuscr_block_begin_ (int * Mb, int * Nb, int * k, int * l, \fBblas_sparse_matrix\fP * A, int * istat)"
Allocates an empty matrix (A) and leaves it in build state\&. 
.PP
\fBParameters:\fP
.RS 4
\fIk,l\fP Are row and column dimensions when specifying a matrix as BCSR\&. 
.br
\fIMb\fP Block rows count\&. 
.br
\fINb\fP Block columns count\&.
.br
\fIA\fP A valid pointer to an empty matrix handle\&. 
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. Will assign a valid matrix handle to $A$ in case of success, or set it to -1 on error\&.
.RE
.PP

.SS "int BLAS_cuscr_end (\fBblas_sparse_matrix\fP A)"
Makes an assembled matrix out of a matrix in build state\&. After this, it is not possible anymore to insert nonzeroes, but computational routines\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_cuscr_end_ (\fBblas_sparse_matrix\fP * A, int * istat)"
Makes an assembled matrix out of a matrix in build state\&. After this, it is not possible anymore to insert nonzeroes, but computational routines\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_cuscr_insert_block (\fBblas_sparse_matrix\fP A, const void * val, int row_stride, int col_stride, int i, int j)"
Inserts a whole block in a matrix, assuming it is in build state\&. The block size is assumed to be the one specified when calling the (type) corresponding matrix blocked \fCbegin\fP function\&. If not called a blocked \fCbegin\fP function, will assume 1x1 (that is, no) blocking\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIrow_stride,col_stride\fP Row and column strides in accessing \fCval\fP\&. 
.br
\fIi,j\fP Block row/column indices\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Signature of this routine for Fortran does not agree to the standard\&. This shall be corrected in a future release\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBBLAS_cuscr_block_begin\fP, \fBBLAS_cuscr_block_begin\fP, \fBBLAS_duscr_block_begin\fP, \fBBLAS_zuscr_block_begin\fP, \fBBLAS_cuscr_begin\fP, \fBBLAS_suscr_begin\fP, \fBBLAS_duscr_begin\fP, \fBBLAS_zuscr_begin\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_cuscr_insert_block_ (\fBblas_sparse_matrix\fP * A, const void * val, int * row_stride, int * col_stride, int * i, int * j, int * istat)"
Inserts a whole block in a matrix, assuming it is in build state\&. The block size is assumed to be the one specified when calling the (type) corresponding matrix blocked \fCbegin\fP function\&. If not called a blocked \fCbegin\fP function, will assume 1x1 (that is, no) blocking\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIrow_stride,col_stride\fP Row and column strides in accessing \fCval\fP\&. 
.br
\fIi,j\fP Block row/column indices\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Signature of this routine for Fortran does not agree to the standard\&. This shall be corrected in a future release\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBBLAS_cuscr_block_begin\fP, \fBBLAS_cuscr_block_begin\fP, \fBBLAS_duscr_block_begin\fP, \fBBLAS_zuscr_block_begin\fP, \fBBLAS_cuscr_begin\fP, \fBBLAS_suscr_begin\fP, \fBBLAS_duscr_begin\fP, \fBBLAS_zuscr_begin\fP\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_cuscr_insert_clique (\fBblas_sparse_matrix\fP A, const int k, const int l, const void * val, const int row_stride, const int col_stride, const int * indx, const int * jndx)"
Inserts a whole clique in a matrix, assuming this is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIk,l\fP Clique rows and columns count\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIrow_stride,col_stride\fP Row/columns stride in accessing the clique\&. 
.br
\fIindx,jndx\fP Row/column indices arrays\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Signature of this routine for Fortran does not agree to the standard\&. This shall be corrected in a future release\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_cuscr_insert_clique_ (\fBblas_sparse_matrix\fP * A, const int * k, const int * l, const void * val, const int * row_stride, const int * col_stride, const int * indx, const int * jndx, int * istat)"
Inserts a whole clique in a matrix, assuming this is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIk,l\fP Clique rows and columns count\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIrow_stride,col_stride\fP Row/columns stride in accessing the clique\&. 
.br
\fIindx,jndx\fP Row/column indices arrays\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Signature of this routine for Fortran does not agree to the standard\&. This shall be corrected in a future release\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_cuscr_insert_col (\fBblas_sparse_matrix\fP A, int j, int nnz, const void * val, const int * indx)"
Inserts a whole column in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIj\fP Column index\&. 
.br
\fInnz\fP Number of nonzeroes to insert\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIindx\fP Row indices array\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_cuscr_insert_col_ (\fBblas_sparse_matrix\fP * A, int * j, int * nnz, const void * val, const int * indx, int * istat)"
Inserts a whole column in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIj\fP Column index\&. 
.br
\fInnz\fP Number of nonzeroes to insert\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIindx\fP Row indices array\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_cuscr_insert_entries (\fBblas_sparse_matrix\fP A, int nnz, const void * val, const int * indx, const int * jndx)"
Inserts entries in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fInnz\fP Number of nonzeroes to insert\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIindx\fP Row indices array\&. 
.br
\fIjndx\fP Column indices array\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_cuscr_insert_entries_ (\fBblas_sparse_matrix\fP * A, int * nnz, const void * val, const int * indx, const int * jndx, int * istat)"
Inserts entries in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fInnz\fP Number of nonzeroes to insert\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIindx\fP Row indices array\&. 
.br
\fIjndx\fP Column indices array\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_cuscr_insert_entry (\fBblas_sparse_matrix\fP A, const void * val, int i, int j)"
Inserts an entry in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIi,j\fP Row and column indices\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_cuscr_insert_entry_ (\fBblas_sparse_matrix\fP * A, const void * val, int * i, int * j, int * istat)"
Inserts an entry in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIi,j\fP Row and column indices\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_cuscr_insert_row (\fBblas_sparse_matrix\fP A, int i, int nnz, const void * val, const int * indx)"
Inserts a whole row in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIi\fP Row index\&. 
.br
\fInnz\fP Number of nonzeroes to insert\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIindx\fP Row index\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_cuscr_insert_row_ (\fBblas_sparse_matrix\fP * A, int * i, int * nnz, const void * val, const int * indx, int * istat)"
Inserts a whole row in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIi\fP Row index\&. 
.br
\fInnz\fP Number of nonzeroes to insert\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIindx\fP Row index\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "\fBblas_sparse_matrix\fP BLAS_cuscr_variable_block_begin (int Mb, int Nb, const int * K, const int * L)"
Allocates an empty matrix (A) and leaves it in build state\&. 
.PP
\fBParameters:\fP
.RS 4
\fIK,L\fP Are arrays specifying row/column block sizes when specifying a matrix as VBR\&. 
.br
\fIMb\fP Block rows count\&. 
.br
\fINb\fP Block columns count\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A matrix handle in case of success, or -1 on error\&.
.RE
.PP

.SS "void blas_cuscr_variable_block_begin_ (int * Mb, int * Nb, const int * K, const int * L, \fBblas_sparse_matrix\fP * A, int * istat)"
Allocates an empty matrix (A) and leaves it in build state\&. 
.PP
\fBParameters:\fP
.RS 4
\fIK,L\fP Are arrays specifying row/column block sizes when specifying a matrix as VBR\&. 
.br
\fIMb\fP Block rows count\&. 
.br
\fINb\fP Block columns count\&.
.br
\fIA\fP A valid pointer to an empty matrix handle\&. 
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. Will assign a valid matrix handle to $A$ in case of success, or set it to -1 on error\&.
.RE
.PP

.SS "int BLAS_cusdot (const enum \fBblas_conj_type\fP conj, const int nnz, const void * x, const int * indx, const void * y, const int incy, void * r, const enum \fBblas_base_type\fP index_base)"
Sparse dot product\&. $r <- X^T Y,$ $r <- X^H Y$ 
.PP
\fBParameters:\fP
.RS 4
\fIr\fP Sparse dot result array\&. 
.br
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&. 
.br
\fIconj\fP If \fBblas_conj\fP, values of X will be considered conjugated\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "void blas_cusdot_ (const enum \fBblas_conj_type\fP * conj, const int * nnz, const void * x, const int * indx, const void * y, const int * incy, void * r, const enum \fBblas_base_type\fP * index_base, int * istat)"
Sparse dot product\&. $r <- X^T Y,$ $r <- X^H Y$ 
.PP
\fBParameters:\fP
.RS 4
\fIr\fP Sparse dot result array\&. 
.br
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&. 
.br
\fIconj\fP If \fBblas_conj\fP, values of X will be considered conjugated\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "int BLAS_cusga (const int nnz, const void * y, const int incy, void * x, const int * indx, const enum \fBblas_base_type\fP index_base)"
Sparse gather\&. $X <- Y |_x$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&.\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "void blas_cusga_ (const int * nnz, const void * y, const int * incy, void * x, const int * indx, const enum \fBblas_base_type\fP * index_base, int * istat)"
Sparse gather\&. $X <- Y |_x$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&.\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "int BLAS_cusget_diag (\fBblas_sparse_matrix\fP A, void * d)"
Get matrix diagonal\&. $d <- diag(A)$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fId\fP Array for the diagonal entries\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_cusget_diag_ (\fBblas_sparse_matrix\fP * A, void * d, int * istat)"
Get matrix diagonal\&. $d <- diag(A)$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fId\fP Array for the diagonal entries\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_cusget_element (\fBblas_sparse_matrix\fP A, const int i, const int j, void * v)"
Get a single matrix nonzero coefficient $A_{i,j}$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIi\fP Row index\&. 
.br
\fIj\fP Column index\&. 
.br
\fIv\fP Value pointer\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_cusget_element_ (\fBblas_sparse_matrix\fP * A, const int * i, const int * j, void * v, int * istat)"
Get a single matrix nonzero coefficient $A_{i,j}$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIi\fP Row index\&. 
.br
\fIj\fP Column index\&. 
.br
\fIv\fP Value pointer\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_cusget_infinity_norm (\fBblas_sparse_matrix\fP A, void * in, const enum \fBblas_trans_type\fP trans)"
Get infinity norm of matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIin\fP Infinity norm pointer\&. 
.br
\fItrans\fP Transposition parameter\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_cusget_infinity_norm_ (\fBblas_sparse_matrix\fP * A, void * in, const enum \fBblas_trans_type\fP * trans, int * istat)"
Get infinity norm of matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIin\fP Infinity norm pointer\&. 
.br
\fItrans\fP Transposition parameter\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_cusget_matrix_nnz (\fBblas_sparse_matrix\fP A, int * nnz)"
Get nnz count of matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fInnz\fP Output value pointer\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_cusget_matrix_nnz_ (\fBblas_sparse_matrix\fP * A, int * nnz, int * istat)"
Get nnz count of matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fInnz\fP Output value pointer\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_cusget_rows_nnz (\fBblas_sparse_matrix\fP A, const int fr, const int lr, int * nnzp)"
Get nnz count of matrix row interval\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIfr\fP First row\&. 
.br
\fIlr\fP Last row\&. 
.br
\fInnzp\fP Pointer to the nonzeroes variable\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_cusget_rows_nnz_ (\fBblas_sparse_matrix\fP * A, const int * fr, const int * lr, int * nnzp, int * istat)"
Get nnz count of matrix row interval\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIfr\fP First row\&. 
.br
\fIlr\fP Last row\&. 
.br
\fInnzp\fP Pointer to the nonzeroes variable\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_cusget_rows_sparse (\fBblas_sparse_matrix\fP A, void * VA, int * IA, int * JA, int * nnz, const int fr, const int lr)"
Get sparse rows of matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIVA\fP pointer to values\&. 
.br
\fIIA\fP Row indices array\&. 
.br
\fIJA\fP Column indices array\&. 
.br
\fInnz\fP Obtained nonzeroes\&. 
.br
\fIfr\fP first row\&. 
.br
\fIlr\fP Last row\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_cusget_rows_sparse_ (\fBblas_sparse_matrix\fP * A, void * VA, int * IA, int * JA, int * nnz, const int * fr, const int * lr, int * istat)"
Get sparse rows of matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIVA\fP pointer to values\&. 
.br
\fIIA\fP Row indices array\&. 
.br
\fIJA\fP Column indices array\&. 
.br
\fInnz\fP Obtained nonzeroes\&. 
.br
\fIfr\fP first row\&. 
.br
\fIlr\fP Last row\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_cusgz (const int nnz, void * y, const int incy, void * x, const int * indx, const enum \fBblas_base_type\fP index_base)"
Sparse gather and zero\&. $X <- Y |_x;Y|_x <- 0$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&.\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "void blas_cusgz_ (const int * nnz, void * y, const int * incy, void * x, const int * indx, const enum \fBblas_base_type\fP * index_base, int * istat)"
Sparse gather and zero\&. $X <- Y |_x;Y|_x <- 0$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&.\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "int BLAS_cusmm (const enum \fBblas_order_type\fP order, const enum \fBblas_trans_type\fP transA, const int nrhs, const void * alpha, const \fBblas_sparse_matrix\fP A, const void * b, const int ldb, void * c, const int ldc)"
Multiply by a dense matrix (aka multi-vector)\&. Either of $C <- alpha AB+C,$ $C <- alpha A^T B+C,$ $C <- alpha A^H B+C$, depending on the value of \fCtransA\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIorder\fP layour of the dense array\&. 
.br
\fItransA\fP Transposition operator for matrix \fIA\fP\&. 
.br
\fInrhs\fP Number of right hand side columns\&. 
.br
\fIA\fP A valid matrix handle\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIb\fP Dense vector \fIb\fP\&. 
.br
\fIldb\fP Leading dimension of \fIb\fP\&. 
.br
\fIc\fP Dense vector \fIc\fP\&. 
.br
\fIldc\fP Leading dimension of \fIc\fP\&. 
.RE
.PP
\fBNote:\fP
.RS 4
.PP
.PP
By setting the \fC\fBblas_rsb_autotune_next_operation\fP\fP property via \fBBLAS_ussp\fP (at any time) the next multiplication routine call (either of \fBBLAS_dusmv\fP, \fBBLAS_susmv\fP, \fBBLAS_zusmv\fP, \fBBLAS_cusmv\fP, \fBBLAS_dusmm\fP, \fBBLAS_susmm\fP, \fBBLAS_zusmm\fP, \fBBLAS_cusmm\fP) will invoke autotuning before carrying out the effective operation\&. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants\&. By setting the \fC\fBblas_rsb_spmv_autotuning_on\fP\fP property via \fBBLAS_ussp\fP, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply)\&. This can be overridden only by setting the \fCRSB_NUM_THREADS\fP environment variable\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
On the topic of autotuning, see also \fBrsb_tune_spmm\fP\&. If \fC--enable-rsb-num-threads\fP has been specified at configure time, the \fCRSB_NUM_THREADS\fP environment variable will override the number of executing threads specified by \fCOMP_NUM_THREADS\fP\&. (See also \fBRSB_IO_WANT_EXECUTING_THREADS\fP)\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_cusmm_ (const enum \fBblas_order_type\fP * order, const enum \fBblas_trans_type\fP * transA, const int * nrhs, const void * alpha, const \fBblas_sparse_matrix\fP * A, const void * b, const int * ldb, void * c, const int * ldc, int * istat)"
Multiply by a dense matrix (aka multi-vector)\&. Either of $C <- alpha AB+C,$ $C <- alpha A^T B+C,$ $C <- alpha A^H B+C$, depending on the value of \fCtransA\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIorder\fP layour of the dense array\&. 
.br
\fItransA\fP Transposition operator for matrix \fIA\fP\&. 
.br
\fInrhs\fP Number of right hand side columns\&. 
.br
\fIA\fP A valid matrix handle\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIb\fP Dense vector \fIb\fP\&. 
.br
\fIldb\fP Leading dimension of \fIb\fP\&. 
.br
\fIc\fP Dense vector \fIc\fP\&. 
.br
\fIldc\fP Leading dimension of \fIc\fP\&. 
.RE
.PP
\fBNote:\fP
.RS 4
.PP
.PP
By setting the \fC\fBblas_rsb_autotune_next_operation\fP\fP property via \fBBLAS_ussp\fP (at any time) the next multiplication routine call (either of \fBBLAS_dusmv\fP, \fBBLAS_susmv\fP, \fBBLAS_zusmv\fP, \fBBLAS_cusmv\fP, \fBBLAS_dusmm\fP, \fBBLAS_susmm\fP, \fBBLAS_zusmm\fP, \fBBLAS_cusmm\fP) will invoke autotuning before carrying out the effective operation\&. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants\&. By setting the \fC\fBblas_rsb_spmv_autotuning_on\fP\fP property via \fBBLAS_ussp\fP, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply)\&. This can be overridden only by setting the \fCRSB_NUM_THREADS\fP environment variable\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
On the topic of autotuning, see also \fBrsb_tune_spmm\fP\&. If \fC--enable-rsb-num-threads\fP has been specified at configure time, the \fCRSB_NUM_THREADS\fP environment variable will override the number of executing threads specified by \fCOMP_NUM_THREADS\fP\&. (See also \fBRSB_IO_WANT_EXECUTING_THREADS\fP)\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_cusmv (const enum \fBblas_trans_type\fP transA, const void * alpha, const \fBblas_sparse_matrix\fP A, const void * x, const int incx, void * y, const int incy)"
Multiply by a dense vector\&. Either of $Y <- alpha A X + Y ,$ $Y <- alpha A^T X + Y,$ $Y <- alpha A^H X + Y$, depending on the value of \fCtransA\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fItransA\fP Transposition operator for matrix \fIA\fP\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIA\fP A valid matrix handle\&. 
.br
\fIx\fP Dense vector \fIx\fP\&. 
.br
\fIincx\fP Stride of \fIx\fP\&. 
.br
\fIy\fP Dense vector \fIy\fP\&. 
.br
\fIincy\fP Stride of \fIy\fP\&. 
.RE
.PP
\fBNote:\fP
.RS 4
.PP
.PP
By setting the \fC\fBblas_rsb_autotune_next_operation\fP\fP property via \fBBLAS_ussp\fP (at any time) the next multiplication routine call (either of \fBBLAS_dusmv\fP, \fBBLAS_susmv\fP, \fBBLAS_zusmv\fP, \fBBLAS_cusmv\fP, \fBBLAS_dusmm\fP, \fBBLAS_susmm\fP, \fBBLAS_zusmm\fP, \fBBLAS_cusmm\fP) will invoke autotuning before carrying out the effective operation\&. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants\&. By setting the \fC\fBblas_rsb_spmv_autotuning_on\fP\fP property via \fBBLAS_ussp\fP, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply)\&. This can be overridden only by setting the \fCRSB_NUM_THREADS\fP environment variable\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
On the topic of autotuning, see also \fBrsb_tune_spmm\fP\&. If \fC--enable-rsb-num-threads\fP has been specified at configure time, the \fCRSB_NUM_THREADS\fP environment variable will override the number of executing threads specified by \fCOMP_NUM_THREADS\fP\&. (See also \fBRSB_IO_WANT_EXECUTING_THREADS\fP)\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_cusmv_ (const enum \fBblas_trans_type\fP * transA, const void * alpha, const \fBblas_sparse_matrix\fP * A, const void * x, const int * incx, void * y, const int * incy, int * istat)"
Multiply by a dense vector\&. Either of $Y <- alpha A X + Y ,$ $Y <- alpha A^T X + Y,$ $Y <- alpha A^H X + Y$, depending on the value of \fCtransA\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fItransA\fP Transposition operator for matrix \fIA\fP\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIA\fP A valid matrix handle\&. 
.br
\fIx\fP Dense vector \fIx\fP\&. 
.br
\fIincx\fP Stride of \fIx\fP\&. 
.br
\fIy\fP Dense vector \fIy\fP\&. 
.br
\fIincy\fP Stride of \fIy\fP\&. 
.RE
.PP
\fBNote:\fP
.RS 4
.PP
.PP
By setting the \fC\fBblas_rsb_autotune_next_operation\fP\fP property via \fBBLAS_ussp\fP (at any time) the next multiplication routine call (either of \fBBLAS_dusmv\fP, \fBBLAS_susmv\fP, \fBBLAS_zusmv\fP, \fBBLAS_cusmv\fP, \fBBLAS_dusmm\fP, \fBBLAS_susmm\fP, \fBBLAS_zusmm\fP, \fBBLAS_cusmm\fP) will invoke autotuning before carrying out the effective operation\&. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants\&. By setting the \fC\fBblas_rsb_spmv_autotuning_on\fP\fP property via \fBBLAS_ussp\fP, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply)\&. This can be overridden only by setting the \fCRSB_NUM_THREADS\fP environment variable\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
On the topic of autotuning, see also \fBrsb_tune_spmm\fP\&. If \fC--enable-rsb-num-threads\fP has been specified at configure time, the \fCRSB_NUM_THREADS\fP environment variable will override the number of executing threads specified by \fCOMP_NUM_THREADS\fP\&. (See also \fBRSB_IO_WANT_EXECUTING_THREADS\fP)\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_cusrows_scale (\fBblas_sparse_matrix\fP A, const void * d, const enum \fBblas_trans_type\fP trans)"
Scale rows interval of matrix by specified factor\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fId\fP Rows scaling vector\&. 
.br
\fItrans\fP Transposition parameter (if transposed will scale columns)\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_cusrows_scale_ (\fBblas_sparse_matrix\fP * A, const void * d, const enum \fBblas_trans_type\fP * trans, int * istat)"
Scale rows interval of matrix by specified factor\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fId\fP Rows scaling vector\&. 
.br
\fItrans\fP Transposition parameter (if transposed will scale columns)\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_cussc (const int nnz, const void * x, void * y, const int incy, const int * indx, const enum \fBblas_base_type\fP index_base)"
Sparse scatter: $Y |_x <- X$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&.\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "void blas_cussc_ (const int * nnz, const void * x, void * y, const int * incy, const int * indx, const enum \fBblas_base_type\fP * index_base, int * istat)"
Sparse scatter: $Y |_x <- X$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&.\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "int BLAS_cusset_element (\fBblas_sparse_matrix\fP A, const int i, const int j, void * v)"
Set a single (existing) matrix nonzero coefficient $A_{i,j}$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIi\fP Row index\&. 
.br
\fIj\fP Column index\&. 
.br
\fIv\fP Value pointer\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_cusset_element_ (\fBblas_sparse_matrix\fP * A, const int * i, const int * j, void * v, int * istat)"
Set a single (existing) matrix nonzero coefficient $A_{i,j}$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIi\fP Row index\&. 
.br
\fIj\fP Column index\&. 
.br
\fIv\fP Value pointer\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_cusset_elements (\fBblas_sparse_matrix\fP A, const int * ia, const int * ja, const void * va, const int nnz)"
Set individual matrix nonzero coefficients values\&. The operation is pattern preserving, that is, nonzeroes must already exist\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIia\fP Row indices array\&. 
.br
\fIja\fP Column indices array\&. 
.br
\fIva\fP Values array\&. 
.br
\fInnz\fP Length of the \fCia\fP,ja,va arrays\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_cusset_elements_ (\fBblas_sparse_matrix\fP * A, const int * ia, const int * ja, const void * va, const int * nnz, int * istat)"
Set individual matrix nonzero coefficients values\&. The operation is pattern preserving, that is, nonzeroes must already exist\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIia\fP Row indices array\&. 
.br
\fIja\fP Column indices array\&. 
.br
\fIva\fP Values array\&. 
.br
\fInnz\fP Length of the \fCia\fP,ja,va arrays\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_cussm (const enum \fBblas_order_type\fP order, const enum \fBblas_trans_type\fP transT, const int nrhs, const void * alpha, const \fBblas_sparse_matrix\fP T, void * b, const int ldb)"
Triangular solve, by a dense matrix (aka multi-vector)\&. Either of $B <- alpha T^{-1} B,$ $B <- alpha T^{-T} B,$ $B <- alpha T^{-H} B$, depending on the value of \fCtransT\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIorder\fP layour of the dense array\&. 
.br
\fItransT\fP Transposition operator for matrix \fIT\fP\&. 
.br
\fInrhs\fP Number of right hand side columns\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIT\fP A valid triangular matrix handle\&. 
.br
\fIb\fP Dense vector \fIb\fP\&. 
.br
\fIldb\fP Leading dimension of \fIb\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_cussm_ (const enum \fBblas_order_type\fP * order, const enum \fBblas_trans_type\fP * transT, const int * nrhs, const void * alpha, const \fBblas_sparse_matrix\fP * T, void * b, const int * ldb, int * istat)"
Triangular solve, by a dense matrix (aka multi-vector)\&. Either of $B <- alpha T^{-1} B,$ $B <- alpha T^{-T} B,$ $B <- alpha T^{-H} B$, depending on the value of \fCtransT\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIorder\fP layour of the dense array\&. 
.br
\fItransT\fP Transposition operator for matrix \fIT\fP\&. 
.br
\fInrhs\fP Number of right hand side columns\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIT\fP A valid triangular matrix handle\&. 
.br
\fIb\fP Dense vector \fIb\fP\&. 
.br
\fIldb\fP Leading dimension of \fIb\fP\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_cussv (enum \fBblas_trans_type\fP transT, const void * alpha, const \fBblas_sparse_matrix\fP T, void * x, const int incx)"
Triangular solve, by a dense vector\&. Either of $X <- alpha T^{-1}X,$ $X <- alpha T^{-T}X,$ $X <- alpha T^{-H}X$, depending on the value of \fCtransT\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fItransT\fP Transposition operator for matrix \fIT\fP\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIT\fP A valid triangular matrix handle\&. 
.br
\fIx\fP Dense vector \fIx\fP\&. 
.br
\fIincx\fP Stride of \fIx\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_cussv_ (enum \fBblas_trans_type\fP * transT, const void * alpha, const \fBblas_sparse_matrix\fP * T, void * x, const int * incx, int * istat)"
Triangular solve, by a dense vector\&. Either of $X <- alpha T^{-1}X,$ $X <- alpha T^{-T}X,$ $X <- alpha T^{-H}X$, depending on the value of \fCtransT\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fItransT\fP Transposition operator for matrix \fIT\fP\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIT\fP A valid triangular matrix handle\&. 
.br
\fIx\fP Dense vector \fIx\fP\&. 
.br
\fIincx\fP Stride of \fIx\fP\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_dusaxpy (const int nnz, double alpha, const double * x, const int * indx, double * y, const int incy, const enum \fBblas_base_type\fP index_base)"
Sparse vector update: $Y <- alpha X + Y$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&. 
.br
\fIalpha\fP Will scale values of $X$ before accumulating to $Y$\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "void blas_dusaxpy_ (const int * nnz, double * alpha, const double * x, const int * indx, double * y, const int * incy, const enum \fBblas_base_type\fP * index_base, int * istat)"
Sparse vector update: $Y <- alpha X + Y$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&. 
.br
\fIalpha\fP Will scale values of $X$ before accumulating to $Y$\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "\fBblas_sparse_matrix\fP BLAS_duscr_begin (int m, int n)"
Allocates an empty matrix (A) and leaves it in build state\&. 
.PP
\fBParameters:\fP
.RS 4
\fIm\fP Is the count of rows\&. 
.br
\fIn\fP Is the count of columns\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A matrix handle in case of success, or -1 on error\&.
.RE
.PP

.SS "void blas_duscr_begin_ (int * m, int * n, \fBblas_sparse_matrix\fP * A, int * istat)"
Allocates an empty matrix (A) and leaves it in build state\&. 
.PP
\fBParameters:\fP
.RS 4
\fIm\fP Is the count of rows\&. 
.br
\fIn\fP Is the count of columns\&.
.br
\fIA\fP A valid pointer to an empty matrix handle\&. 
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. Will assign a valid matrix handle to $A$ in case of success, or set it to -1 on error\&.
.RE
.PP

.SS "\fBblas_sparse_matrix\fP BLAS_duscr_block_begin (int Mb, int Nb, int k, int l)"
Allocates an empty matrix (A) and leaves it in build state\&. 
.PP
\fBParameters:\fP
.RS 4
\fIk,l\fP Are row and column dimensions when specifying a matrix as BCSR\&. 
.br
\fIMb\fP Block rows count\&. 
.br
\fINb\fP Block columns count\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A matrix handle in case of success, or -1 on error\&.
.RE
.PP

.SS "void blas_duscr_block_begin_ (int * Mb, int * Nb, int * k, int * l, \fBblas_sparse_matrix\fP * A, int * istat)"
Allocates an empty matrix (A) and leaves it in build state\&. 
.PP
\fBParameters:\fP
.RS 4
\fIk,l\fP Are row and column dimensions when specifying a matrix as BCSR\&. 
.br
\fIMb\fP Block rows count\&. 
.br
\fINb\fP Block columns count\&.
.br
\fIA\fP A valid pointer to an empty matrix handle\&. 
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. Will assign a valid matrix handle to $A$ in case of success, or set it to -1 on error\&.
.RE
.PP

.SS "int BLAS_duscr_end (\fBblas_sparse_matrix\fP A)"
Makes an assembled matrix out of a matrix in build state\&. After this, it is not possible anymore to insert nonzeroes, but computational routines\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_duscr_end_ (\fBblas_sparse_matrix\fP * A, int * istat)"
Makes an assembled matrix out of a matrix in build state\&. After this, it is not possible anymore to insert nonzeroes, but computational routines\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_duscr_insert_block (\fBblas_sparse_matrix\fP A, const double * val, int row_stride, int col_stride, int i, int j)"
Inserts a whole block in a matrix, assuming it is in build state\&. The block size is assumed to be the one specified when calling the (type) corresponding matrix blocked \fCbegin\fP function\&. If not called a blocked \fCbegin\fP function, will assume 1x1 (that is, no) blocking\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIrow_stride,col_stride\fP Row and column strides in accessing \fCval\fP\&. 
.br
\fIi,j\fP Block row/column indices\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Signature of this routine for Fortran does not agree to the standard\&. This shall be corrected in a future release\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBBLAS_cuscr_block_begin\fP, \fBBLAS_cuscr_block_begin\fP, \fBBLAS_duscr_block_begin\fP, \fBBLAS_zuscr_block_begin\fP, \fBBLAS_cuscr_begin\fP, \fBBLAS_suscr_begin\fP, \fBBLAS_duscr_begin\fP, \fBBLAS_zuscr_begin\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_duscr_insert_block_ (\fBblas_sparse_matrix\fP * A, const double * val, int * row_stride, int * col_stride, int * i, int * j, int * istat)"
Inserts a whole block in a matrix, assuming it is in build state\&. The block size is assumed to be the one specified when calling the (type) corresponding matrix blocked \fCbegin\fP function\&. If not called a blocked \fCbegin\fP function, will assume 1x1 (that is, no) blocking\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIrow_stride,col_stride\fP Row and column strides in accessing \fCval\fP\&. 
.br
\fIi,j\fP Block row/column indices\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Signature of this routine for Fortran does not agree to the standard\&. This shall be corrected in a future release\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBBLAS_cuscr_block_begin\fP, \fBBLAS_cuscr_block_begin\fP, \fBBLAS_duscr_block_begin\fP, \fBBLAS_zuscr_block_begin\fP, \fBBLAS_cuscr_begin\fP, \fBBLAS_suscr_begin\fP, \fBBLAS_duscr_begin\fP, \fBBLAS_zuscr_begin\fP\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_duscr_insert_clique (\fBblas_sparse_matrix\fP A, const int k, const int l, const double * val, const int row_stride, const int col_stride, const int * indx, const int * jndx)"
Inserts a whole clique in a matrix, assuming this is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIk,l\fP Clique rows and columns count\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIrow_stride,col_stride\fP Row/columns stride in accessing the clique\&. 
.br
\fIindx,jndx\fP Row/column indices arrays\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Signature of this routine for Fortran does not agree to the standard\&. This shall be corrected in a future release\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_duscr_insert_clique_ (\fBblas_sparse_matrix\fP * A, const int * k, const int * l, const double * val, const int * row_stride, const int * col_stride, const int * indx, const int * jndx, int * istat)"
Inserts a whole clique in a matrix, assuming this is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIk,l\fP Clique rows and columns count\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIrow_stride,col_stride\fP Row/columns stride in accessing the clique\&. 
.br
\fIindx,jndx\fP Row/column indices arrays\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Signature of this routine for Fortran does not agree to the standard\&. This shall be corrected in a future release\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_duscr_insert_col (\fBblas_sparse_matrix\fP A, int j, int nnz, const double * val, const int * indx)"
Inserts a whole column in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIj\fP Column index\&. 
.br
\fInnz\fP Number of nonzeroes to insert\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIindx\fP Row indices array\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_duscr_insert_col_ (\fBblas_sparse_matrix\fP * A, int * j, int * nnz, const double * val, const int * indx, int * istat)"
Inserts a whole column in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIj\fP Column index\&. 
.br
\fInnz\fP Number of nonzeroes to insert\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIindx\fP Row indices array\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_duscr_insert_entries (\fBblas_sparse_matrix\fP A, int nnz, const double * val, const int * indx, const int * jndx)"
Inserts entries in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fInnz\fP Number of nonzeroes to insert\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIindx\fP Row indices array\&. 
.br
\fIjndx\fP Column indices array\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_duscr_insert_entries_ (\fBblas_sparse_matrix\fP * A, int * nnz, const double * val, const int * indx, const int * jndx, int * istat)"
Inserts entries in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fInnz\fP Number of nonzeroes to insert\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIindx\fP Row indices array\&. 
.br
\fIjndx\fP Column indices array\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_duscr_insert_entry (\fBblas_sparse_matrix\fP A, double val, int i, int j)"
Inserts an entry in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIi,j\fP Row and column indices\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_duscr_insert_entry_ (\fBblas_sparse_matrix\fP * A, double * val, int * i, int * j, int * istat)"
Inserts an entry in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIi,j\fP Row and column indices\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_duscr_insert_row (\fBblas_sparse_matrix\fP A, int i, int nnz, const double * val, const int * indx)"
Inserts a whole row in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIi\fP Row index\&. 
.br
\fInnz\fP Number of nonzeroes to insert\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIindx\fP Row index\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_duscr_insert_row_ (\fBblas_sparse_matrix\fP * A, int * i, int * nnz, const double * val, const int * indx, int * istat)"
Inserts a whole row in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIi\fP Row index\&. 
.br
\fInnz\fP Number of nonzeroes to insert\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIindx\fP Row index\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "\fBblas_sparse_matrix\fP BLAS_duscr_variable_block_begin (int Mb, int Nb, const int * K, const int * L)"
Allocates an empty matrix (A) and leaves it in build state\&. 
.PP
\fBParameters:\fP
.RS 4
\fIK,L\fP Are arrays specifying row/column block sizes when specifying a matrix as VBR\&. 
.br
\fIMb\fP Block rows count\&. 
.br
\fINb\fP Block columns count\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A matrix handle in case of success, or -1 on error\&.
.RE
.PP

.SS "void blas_duscr_variable_block_begin_ (int * Mb, int * Nb, const int * K, const int * L, \fBblas_sparse_matrix\fP * A, int * istat)"
Allocates an empty matrix (A) and leaves it in build state\&. 
.PP
\fBParameters:\fP
.RS 4
\fIK,L\fP Are arrays specifying row/column block sizes when specifying a matrix as VBR\&. 
.br
\fIMb\fP Block rows count\&. 
.br
\fINb\fP Block columns count\&.
.br
\fIA\fP A valid pointer to an empty matrix handle\&. 
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. Will assign a valid matrix handle to $A$ in case of success, or set it to -1 on error\&.
.RE
.PP

.SS "int BLAS_dusdot (const enum \fBblas_conj_type\fP conj, const int nnz, const double * x, const int * indx, const double * y, const int incy, double * r, const enum \fBblas_base_type\fP index_base)"
Sparse dot product\&. $r <- X^T Y,$ $r <- X^H Y$ 
.PP
\fBParameters:\fP
.RS 4
\fIr\fP Sparse dot result array\&. 
.br
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&. 
.br
\fIconj\fP If \fBblas_conj\fP, values of X will be considered conjugated\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "void blas_dusdot_ (const enum \fBblas_conj_type\fP * conj, const int * nnz, const double * x, const int * indx, const double * y, const int * incy, double * r, const enum \fBblas_base_type\fP * index_base, int * istat)"
Sparse dot product\&. $r <- X^T Y,$ $r <- X^H Y$ 
.PP
\fBParameters:\fP
.RS 4
\fIr\fP Sparse dot result array\&. 
.br
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&. 
.br
\fIconj\fP If \fBblas_conj\fP, values of X will be considered conjugated\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "int BLAS_dusga (const int nnz, const double * y, const int incy, double * x, const int * indx, const enum \fBblas_base_type\fP index_base)"
Sparse gather\&. $X <- Y |_x$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&.\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "void blas_dusga_ (const int * nnz, const double * y, const int * incy, double * x, const int * indx, const enum \fBblas_base_type\fP * index_base, int * istat)"
Sparse gather\&. $X <- Y |_x$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&.\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "int BLAS_dusget_diag (\fBblas_sparse_matrix\fP A, double * d)"
Get matrix diagonal\&. $d <- diag(A)$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fId\fP Array for the diagonal entries\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_dusget_diag_ (\fBblas_sparse_matrix\fP * A, double * d, int * istat)"
Get matrix diagonal\&. $d <- diag(A)$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fId\fP Array for the diagonal entries\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_dusget_element (\fBblas_sparse_matrix\fP A, const int i, const int j, double * v)"
Get a single matrix nonzero coefficient $A_{i,j}$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIi\fP Row index\&. 
.br
\fIj\fP Column index\&. 
.br
\fIv\fP Value pointer\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_dusget_element_ (\fBblas_sparse_matrix\fP * A, const int * i, const int * j, double * v, int * istat)"
Get a single matrix nonzero coefficient $A_{i,j}$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIi\fP Row index\&. 
.br
\fIj\fP Column index\&. 
.br
\fIv\fP Value pointer\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_dusget_infinity_norm (\fBblas_sparse_matrix\fP A, double * in, const enum \fBblas_trans_type\fP trans)"
Get infinity norm of matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIin\fP Infinity norm pointer\&. 
.br
\fItrans\fP Transposition parameter\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_dusget_infinity_norm_ (\fBblas_sparse_matrix\fP * A, double * in, const enum \fBblas_trans_type\fP * trans, int * istat)"
Get infinity norm of matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIin\fP Infinity norm pointer\&. 
.br
\fItrans\fP Transposition parameter\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_dusget_matrix_nnz (\fBblas_sparse_matrix\fP A, int * nnz)"
Get nnz count of matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fInnz\fP Output value pointer\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_dusget_matrix_nnz_ (\fBblas_sparse_matrix\fP * A, int * nnz, int * istat)"
Get nnz count of matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fInnz\fP Output value pointer\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_dusget_rows_nnz (\fBblas_sparse_matrix\fP A, const int fr, const int lr, int * nnzp)"
Get nnz count of matrix row interval\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIfr\fP First row\&. 
.br
\fIlr\fP Last row\&. 
.br
\fInnzp\fP Pointer to the nonzeroes variable\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_dusget_rows_nnz_ (\fBblas_sparse_matrix\fP * A, const int * fr, const int * lr, int * nnzp, int * istat)"
Get nnz count of matrix row interval\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIfr\fP First row\&. 
.br
\fIlr\fP Last row\&. 
.br
\fInnzp\fP Pointer to the nonzeroes variable\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_dusget_rows_sparse (\fBblas_sparse_matrix\fP A, double * VA, int * IA, int * JA, int * nnz, const int fr, const int lr)"
Get sparse rows of matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIVA\fP pointer to values\&. 
.br
\fIIA\fP Row indices array\&. 
.br
\fIJA\fP Column indices array\&. 
.br
\fInnz\fP Obtained nonzeroes\&. 
.br
\fIfr\fP first row\&. 
.br
\fIlr\fP Last row\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_dusget_rows_sparse_ (\fBblas_sparse_matrix\fP * A, double * VA, int * IA, int * JA, int * nnz, const int * fr, const int * lr, int * istat)"
Get sparse rows of matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIVA\fP pointer to values\&. 
.br
\fIIA\fP Row indices array\&. 
.br
\fIJA\fP Column indices array\&. 
.br
\fInnz\fP Obtained nonzeroes\&. 
.br
\fIfr\fP first row\&. 
.br
\fIlr\fP Last row\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_dusgz (const int nnz, double * y, const int incy, double * x, const int * indx, const enum \fBblas_base_type\fP index_base)"
Sparse gather and zero\&. $X <- Y |_x;Y|_x <- 0$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&.\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "void blas_dusgz_ (const int * nnz, double * y, const int * incy, double * x, const int * indx, const enum \fBblas_base_type\fP * index_base, int * istat)"
Sparse gather and zero\&. $X <- Y |_x;Y|_x <- 0$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&.\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "int BLAS_dusmm (const enum \fBblas_order_type\fP order, const enum \fBblas_trans_type\fP transA, const int nrhs, double alpha, const \fBblas_sparse_matrix\fP A, const double * b, const int ldb, double * c, const int ldc)"
Multiply by a dense matrix (aka multi-vector)\&. Either of $C <- alpha AB+C,$ $C <- alpha A^T B+C,$ $C <- alpha A^H B+C$, depending on the value of \fCtransA\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIorder\fP layour of the dense array\&. 
.br
\fItransA\fP Transposition operator for matrix \fIA\fP\&. 
.br
\fInrhs\fP Number of right hand side columns\&. 
.br
\fIA\fP A valid matrix handle\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIb\fP Dense vector \fIb\fP\&. 
.br
\fIldb\fP Leading dimension of \fIb\fP\&. 
.br
\fIc\fP Dense vector \fIc\fP\&. 
.br
\fIldc\fP Leading dimension of \fIc\fP\&. 
.RE
.PP
\fBNote:\fP
.RS 4
.PP
.PP
By setting the \fC\fBblas_rsb_autotune_next_operation\fP\fP property via \fBBLAS_ussp\fP (at any time) the next multiplication routine call (either of \fBBLAS_dusmv\fP, \fBBLAS_susmv\fP, \fBBLAS_zusmv\fP, \fBBLAS_cusmv\fP, \fBBLAS_dusmm\fP, \fBBLAS_susmm\fP, \fBBLAS_zusmm\fP, \fBBLAS_cusmm\fP) will invoke autotuning before carrying out the effective operation\&. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants\&. By setting the \fC\fBblas_rsb_spmv_autotuning_on\fP\fP property via \fBBLAS_ussp\fP, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply)\&. This can be overridden only by setting the \fCRSB_NUM_THREADS\fP environment variable\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
On the topic of autotuning, see also \fBrsb_tune_spmm\fP\&. If \fC--enable-rsb-num-threads\fP has been specified at configure time, the \fCRSB_NUM_THREADS\fP environment variable will override the number of executing threads specified by \fCOMP_NUM_THREADS\fP\&. (See also \fBRSB_IO_WANT_EXECUTING_THREADS\fP)\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_dusmm_ (const enum \fBblas_order_type\fP * order, const enum \fBblas_trans_type\fP * transA, const int * nrhs, double * alpha, const \fBblas_sparse_matrix\fP * A, const double * b, const int * ldb, double * c, const int * ldc, int * istat)"
Multiply by a dense matrix (aka multi-vector)\&. Either of $C <- alpha AB+C,$ $C <- alpha A^T B+C,$ $C <- alpha A^H B+C$, depending on the value of \fCtransA\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIorder\fP layour of the dense array\&. 
.br
\fItransA\fP Transposition operator for matrix \fIA\fP\&. 
.br
\fInrhs\fP Number of right hand side columns\&. 
.br
\fIA\fP A valid matrix handle\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIb\fP Dense vector \fIb\fP\&. 
.br
\fIldb\fP Leading dimension of \fIb\fP\&. 
.br
\fIc\fP Dense vector \fIc\fP\&. 
.br
\fIldc\fP Leading dimension of \fIc\fP\&. 
.RE
.PP
\fBNote:\fP
.RS 4
.PP
.PP
By setting the \fC\fBblas_rsb_autotune_next_operation\fP\fP property via \fBBLAS_ussp\fP (at any time) the next multiplication routine call (either of \fBBLAS_dusmv\fP, \fBBLAS_susmv\fP, \fBBLAS_zusmv\fP, \fBBLAS_cusmv\fP, \fBBLAS_dusmm\fP, \fBBLAS_susmm\fP, \fBBLAS_zusmm\fP, \fBBLAS_cusmm\fP) will invoke autotuning before carrying out the effective operation\&. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants\&. By setting the \fC\fBblas_rsb_spmv_autotuning_on\fP\fP property via \fBBLAS_ussp\fP, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply)\&. This can be overridden only by setting the \fCRSB_NUM_THREADS\fP environment variable\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
On the topic of autotuning, see also \fBrsb_tune_spmm\fP\&. If \fC--enable-rsb-num-threads\fP has been specified at configure time, the \fCRSB_NUM_THREADS\fP environment variable will override the number of executing threads specified by \fCOMP_NUM_THREADS\fP\&. (See also \fBRSB_IO_WANT_EXECUTING_THREADS\fP)\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_dusmv (const enum \fBblas_trans_type\fP transA, double alpha, const \fBblas_sparse_matrix\fP A, const double * x, const int incx, double * y, const int incy)"
Multiply by a dense vector\&. Either of $Y <- alpha A X + Y ,$ $Y <- alpha A^T X + Y,$ $Y <- alpha A^H X + Y$, depending on the value of \fCtransA\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fItransA\fP Transposition operator for matrix \fIA\fP\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIA\fP A valid matrix handle\&. 
.br
\fIx\fP Dense vector \fIx\fP\&. 
.br
\fIincx\fP Stride of \fIx\fP\&. 
.br
\fIy\fP Dense vector \fIy\fP\&. 
.br
\fIincy\fP Stride of \fIy\fP\&. 
.RE
.PP
\fBNote:\fP
.RS 4
.PP
.PP
By setting the \fC\fBblas_rsb_autotune_next_operation\fP\fP property via \fBBLAS_ussp\fP (at any time) the next multiplication routine call (either of \fBBLAS_dusmv\fP, \fBBLAS_susmv\fP, \fBBLAS_zusmv\fP, \fBBLAS_cusmv\fP, \fBBLAS_dusmm\fP, \fBBLAS_susmm\fP, \fBBLAS_zusmm\fP, \fBBLAS_cusmm\fP) will invoke autotuning before carrying out the effective operation\&. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants\&. By setting the \fC\fBblas_rsb_spmv_autotuning_on\fP\fP property via \fBBLAS_ussp\fP, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply)\&. This can be overridden only by setting the \fCRSB_NUM_THREADS\fP environment variable\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
On the topic of autotuning, see also \fBrsb_tune_spmm\fP\&. If \fC--enable-rsb-num-threads\fP has been specified at configure time, the \fCRSB_NUM_THREADS\fP environment variable will override the number of executing threads specified by \fCOMP_NUM_THREADS\fP\&. (See also \fBRSB_IO_WANT_EXECUTING_THREADS\fP)\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_dusmv_ (const enum \fBblas_trans_type\fP * transA, double * alpha, const \fBblas_sparse_matrix\fP * A, const double * x, const int * incx, double * y, const int * incy, int * istat)"
Multiply by a dense vector\&. Either of $Y <- alpha A X + Y ,$ $Y <- alpha A^T X + Y,$ $Y <- alpha A^H X + Y$, depending on the value of \fCtransA\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fItransA\fP Transposition operator for matrix \fIA\fP\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIA\fP A valid matrix handle\&. 
.br
\fIx\fP Dense vector \fIx\fP\&. 
.br
\fIincx\fP Stride of \fIx\fP\&. 
.br
\fIy\fP Dense vector \fIy\fP\&. 
.br
\fIincy\fP Stride of \fIy\fP\&. 
.RE
.PP
\fBNote:\fP
.RS 4
.PP
.PP
By setting the \fC\fBblas_rsb_autotune_next_operation\fP\fP property via \fBBLAS_ussp\fP (at any time) the next multiplication routine call (either of \fBBLAS_dusmv\fP, \fBBLAS_susmv\fP, \fBBLAS_zusmv\fP, \fBBLAS_cusmv\fP, \fBBLAS_dusmm\fP, \fBBLAS_susmm\fP, \fBBLAS_zusmm\fP, \fBBLAS_cusmm\fP) will invoke autotuning before carrying out the effective operation\&. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants\&. By setting the \fC\fBblas_rsb_spmv_autotuning_on\fP\fP property via \fBBLAS_ussp\fP, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply)\&. This can be overridden only by setting the \fCRSB_NUM_THREADS\fP environment variable\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
On the topic of autotuning, see also \fBrsb_tune_spmm\fP\&. If \fC--enable-rsb-num-threads\fP has been specified at configure time, the \fCRSB_NUM_THREADS\fP environment variable will override the number of executing threads specified by \fCOMP_NUM_THREADS\fP\&. (See also \fBRSB_IO_WANT_EXECUTING_THREADS\fP)\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_dusrows_scale (\fBblas_sparse_matrix\fP A, const double * d, const enum \fBblas_trans_type\fP trans)"
Scale rows interval of matrix by specified factor\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fId\fP Rows scaling vector\&. 
.br
\fItrans\fP Transposition parameter (if transposed will scale columns)\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_dusrows_scale_ (\fBblas_sparse_matrix\fP * A, const double * d, const enum \fBblas_trans_type\fP * trans, int * istat)"
Scale rows interval of matrix by specified factor\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fId\fP Rows scaling vector\&. 
.br
\fItrans\fP Transposition parameter (if transposed will scale columns)\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_dussc (const int nnz, const double * x, double * y, const int incy, const int * indx, const enum \fBblas_base_type\fP index_base)"
Sparse scatter: $Y |_x <- X$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&.\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "void blas_dussc_ (const int * nnz, const double * x, double * y, const int * incy, const int * indx, const enum \fBblas_base_type\fP * index_base, int * istat)"
Sparse scatter: $Y |_x <- X$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&.\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "int BLAS_dusset_element (\fBblas_sparse_matrix\fP A, const int i, const int j, double * v)"
Set a single (existing) matrix nonzero coefficient $A_{i,j}$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIi\fP Row index\&. 
.br
\fIj\fP Column index\&. 
.br
\fIv\fP Value pointer\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_dusset_element_ (\fBblas_sparse_matrix\fP * A, const int * i, const int * j, double * v, int * istat)"
Set a single (existing) matrix nonzero coefficient $A_{i,j}$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIi\fP Row index\&. 
.br
\fIj\fP Column index\&. 
.br
\fIv\fP Value pointer\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_dusset_elements (\fBblas_sparse_matrix\fP A, const int * ia, const int * ja, const double * va, const int nnz)"
Set individual matrix nonzero coefficients values\&. The operation is pattern preserving, that is, nonzeroes must already exist\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIia\fP Row indices array\&. 
.br
\fIja\fP Column indices array\&. 
.br
\fIva\fP Values array\&. 
.br
\fInnz\fP Length of the \fCia\fP,ja,va arrays\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_dusset_elements_ (\fBblas_sparse_matrix\fP * A, const int * ia, const int * ja, const double * va, const int * nnz, int * istat)"
Set individual matrix nonzero coefficients values\&. The operation is pattern preserving, that is, nonzeroes must already exist\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIia\fP Row indices array\&. 
.br
\fIja\fP Column indices array\&. 
.br
\fIva\fP Values array\&. 
.br
\fInnz\fP Length of the \fCia\fP,ja,va arrays\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_dussm (const enum \fBblas_order_type\fP order, const enum \fBblas_trans_type\fP transT, const int nrhs, double alpha, const \fBblas_sparse_matrix\fP T, double * b, const int ldb)"
Triangular solve, by a dense matrix (aka multi-vector)\&. Either of $B <- alpha T^{-1} B,$ $B <- alpha T^{-T} B,$ $B <- alpha T^{-H} B$, depending on the value of \fCtransT\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIorder\fP layour of the dense array\&. 
.br
\fItransT\fP Transposition operator for matrix \fIT\fP\&. 
.br
\fInrhs\fP Number of right hand side columns\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIT\fP A valid triangular matrix handle\&. 
.br
\fIb\fP Dense vector \fIb\fP\&. 
.br
\fIldb\fP Leading dimension of \fIb\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_dussm_ (const enum \fBblas_order_type\fP * order, const enum \fBblas_trans_type\fP * transT, const int * nrhs, double * alpha, const \fBblas_sparse_matrix\fP * T, double * b, const int * ldb, int * istat)"
Triangular solve, by a dense matrix (aka multi-vector)\&. Either of $B <- alpha T^{-1} B,$ $B <- alpha T^{-T} B,$ $B <- alpha T^{-H} B$, depending on the value of \fCtransT\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIorder\fP layour of the dense array\&. 
.br
\fItransT\fP Transposition operator for matrix \fIT\fP\&. 
.br
\fInrhs\fP Number of right hand side columns\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIT\fP A valid triangular matrix handle\&. 
.br
\fIb\fP Dense vector \fIb\fP\&. 
.br
\fIldb\fP Leading dimension of \fIb\fP\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_dussv (enum \fBblas_trans_type\fP transT, double alpha, const \fBblas_sparse_matrix\fP T, double * x, const int incx)"
Triangular solve, by a dense vector\&. Either of $X <- alpha T^{-1}X,$ $X <- alpha T^{-T}X,$ $X <- alpha T^{-H}X$, depending on the value of \fCtransT\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fItransT\fP Transposition operator for matrix \fIT\fP\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIT\fP A valid triangular matrix handle\&. 
.br
\fIx\fP Dense vector \fIx\fP\&. 
.br
\fIincx\fP Stride of \fIx\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_dussv_ (enum \fBblas_trans_type\fP * transT, double * alpha, const \fBblas_sparse_matrix\fP * T, double * x, const int * incx, int * istat)"
Triangular solve, by a dense vector\&. Either of $X <- alpha T^{-1}X,$ $X <- alpha T^{-T}X,$ $X <- alpha T^{-H}X$, depending on the value of \fCtransT\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fItransT\fP Transposition operator for matrix \fIT\fP\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIT\fP A valid triangular matrix handle\&. 
.br
\fIx\fP Dense vector \fIx\fP\&. 
.br
\fIincx\fP Stride of \fIx\fP\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_susaxpy (const int nnz, float alpha, const float * x, const int * indx, float * y, const int incy, const enum \fBblas_base_type\fP index_base)"
Sparse vector update: $Y <- alpha X + Y$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&. 
.br
\fIalpha\fP Will scale values of $X$ before accumulating to $Y$\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "void blas_susaxpy_ (const int * nnz, float * alpha, const float * x, const int * indx, float * y, const int * incy, const enum \fBblas_base_type\fP * index_base, int * istat)"
Sparse vector update: $Y <- alpha X + Y$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&. 
.br
\fIalpha\fP Will scale values of $X$ before accumulating to $Y$\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "\fBblas_sparse_matrix\fP BLAS_suscr_begin (int m, int n)"
Allocates an empty matrix (A) and leaves it in build state\&. 
.PP
\fBParameters:\fP
.RS 4
\fIm\fP Is the count of rows\&. 
.br
\fIn\fP Is the count of columns\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A matrix handle in case of success, or -1 on error\&.
.RE
.PP

.SS "void blas_suscr_begin_ (int * m, int * n, \fBblas_sparse_matrix\fP * A, int * istat)"
Allocates an empty matrix (A) and leaves it in build state\&. 
.PP
\fBParameters:\fP
.RS 4
\fIm\fP Is the count of rows\&. 
.br
\fIn\fP Is the count of columns\&.
.br
\fIA\fP A valid pointer to an empty matrix handle\&. 
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. Will assign a valid matrix handle to $A$ in case of success, or set it to -1 on error\&.
.RE
.PP

.SS "\fBblas_sparse_matrix\fP BLAS_suscr_block_begin (int Mb, int Nb, int k, int l)"
Allocates an empty matrix (A) and leaves it in build state\&. 
.PP
\fBParameters:\fP
.RS 4
\fIk,l\fP Are row and column dimensions when specifying a matrix as BCSR\&. 
.br
\fIMb\fP Block rows count\&. 
.br
\fINb\fP Block columns count\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A matrix handle in case of success, or -1 on error\&.
.RE
.PP

.SS "void blas_suscr_block_begin_ (int * Mb, int * Nb, int * k, int * l, \fBblas_sparse_matrix\fP * A, int * istat)"
Allocates an empty matrix (A) and leaves it in build state\&. 
.PP
\fBParameters:\fP
.RS 4
\fIk,l\fP Are row and column dimensions when specifying a matrix as BCSR\&. 
.br
\fIMb\fP Block rows count\&. 
.br
\fINb\fP Block columns count\&.
.br
\fIA\fP A valid pointer to an empty matrix handle\&. 
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. Will assign a valid matrix handle to $A$ in case of success, or set it to -1 on error\&.
.RE
.PP

.SS "int BLAS_suscr_end (\fBblas_sparse_matrix\fP A)"
Makes an assembled matrix out of a matrix in build state\&. After this, it is not possible anymore to insert nonzeroes, but computational routines\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_suscr_end_ (\fBblas_sparse_matrix\fP * A, int * istat)"
Makes an assembled matrix out of a matrix in build state\&. After this, it is not possible anymore to insert nonzeroes, but computational routines\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_suscr_insert_block (\fBblas_sparse_matrix\fP A, const float * val, int row_stride, int col_stride, int i, int j)"
Inserts a whole block in a matrix, assuming it is in build state\&. The block size is assumed to be the one specified when calling the (type) corresponding matrix blocked \fCbegin\fP function\&. If not called a blocked \fCbegin\fP function, will assume 1x1 (that is, no) blocking\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIrow_stride,col_stride\fP Row and column strides in accessing \fCval\fP\&. 
.br
\fIi,j\fP Block row/column indices\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Signature of this routine for Fortran does not agree to the standard\&. This shall be corrected in a future release\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBBLAS_cuscr_block_begin\fP, \fBBLAS_cuscr_block_begin\fP, \fBBLAS_duscr_block_begin\fP, \fBBLAS_zuscr_block_begin\fP, \fBBLAS_cuscr_begin\fP, \fBBLAS_suscr_begin\fP, \fBBLAS_duscr_begin\fP, \fBBLAS_zuscr_begin\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_suscr_insert_block_ (\fBblas_sparse_matrix\fP * A, const float * val, int * row_stride, int * col_stride, int * i, int * j, int * istat)"
Inserts a whole block in a matrix, assuming it is in build state\&. The block size is assumed to be the one specified when calling the (type) corresponding matrix blocked \fCbegin\fP function\&. If not called a blocked \fCbegin\fP function, will assume 1x1 (that is, no) blocking\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIrow_stride,col_stride\fP Row and column strides in accessing \fCval\fP\&. 
.br
\fIi,j\fP Block row/column indices\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Signature of this routine for Fortran does not agree to the standard\&. This shall be corrected in a future release\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBBLAS_cuscr_block_begin\fP, \fBBLAS_cuscr_block_begin\fP, \fBBLAS_duscr_block_begin\fP, \fBBLAS_zuscr_block_begin\fP, \fBBLAS_cuscr_begin\fP, \fBBLAS_suscr_begin\fP, \fBBLAS_duscr_begin\fP, \fBBLAS_zuscr_begin\fP\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_suscr_insert_clique (\fBblas_sparse_matrix\fP A, const int k, const int l, const float * val, const int row_stride, const int col_stride, const int * indx, const int * jndx)"
Inserts a whole clique in a matrix, assuming this is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIk,l\fP Clique rows and columns count\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIrow_stride,col_stride\fP Row/columns stride in accessing the clique\&. 
.br
\fIindx,jndx\fP Row/column indices arrays\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Signature of this routine for Fortran does not agree to the standard\&. This shall be corrected in a future release\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_suscr_insert_clique_ (\fBblas_sparse_matrix\fP * A, const int * k, const int * l, const float * val, const int * row_stride, const int * col_stride, const int * indx, const int * jndx, int * istat)"
Inserts a whole clique in a matrix, assuming this is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIk,l\fP Clique rows and columns count\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIrow_stride,col_stride\fP Row/columns stride in accessing the clique\&. 
.br
\fIindx,jndx\fP Row/column indices arrays\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Signature of this routine for Fortran does not agree to the standard\&. This shall be corrected in a future release\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_suscr_insert_col (\fBblas_sparse_matrix\fP A, int j, int nnz, const float * val, const int * indx)"
Inserts a whole column in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIj\fP Column index\&. 
.br
\fInnz\fP Number of nonzeroes to insert\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIindx\fP Row indices array\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_suscr_insert_col_ (\fBblas_sparse_matrix\fP * A, int * j, int * nnz, const float * val, const int * indx, int * istat)"
Inserts a whole column in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIj\fP Column index\&. 
.br
\fInnz\fP Number of nonzeroes to insert\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIindx\fP Row indices array\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_suscr_insert_entries (\fBblas_sparse_matrix\fP A, int nnz, const float * val, const int * indx, const int * jndx)"
Inserts entries in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fInnz\fP Number of nonzeroes to insert\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIindx\fP Row indices array\&. 
.br
\fIjndx\fP Column indices array\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_suscr_insert_entries_ (\fBblas_sparse_matrix\fP * A, int * nnz, const float * val, const int * indx, const int * jndx, int * istat)"
Inserts entries in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fInnz\fP Number of nonzeroes to insert\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIindx\fP Row indices array\&. 
.br
\fIjndx\fP Column indices array\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_suscr_insert_entry (\fBblas_sparse_matrix\fP A, float val, int i, int j)"
Inserts an entry in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIi,j\fP Row and column indices\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_suscr_insert_entry_ (\fBblas_sparse_matrix\fP * A, float * val, int * i, int * j, int * istat)"
Inserts an entry in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIi,j\fP Row and column indices\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_suscr_insert_row (\fBblas_sparse_matrix\fP A, int i, int nnz, const float * val, const int * indx)"
Inserts a whole row in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIi\fP Row index\&. 
.br
\fInnz\fP Number of nonzeroes to insert\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIindx\fP Row index\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_suscr_insert_row_ (\fBblas_sparse_matrix\fP * A, int * i, int * nnz, const float * val, const int * indx, int * istat)"
Inserts a whole row in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIi\fP Row index\&. 
.br
\fInnz\fP Number of nonzeroes to insert\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIindx\fP Row index\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "\fBblas_sparse_matrix\fP BLAS_suscr_variable_block_begin (int Mb, int Nb, const int * K, const int * L)"
Allocates an empty matrix (A) and leaves it in build state\&. 
.PP
\fBParameters:\fP
.RS 4
\fIK,L\fP Are arrays specifying row/column block sizes when specifying a matrix as VBR\&. 
.br
\fIMb\fP Block rows count\&. 
.br
\fINb\fP Block columns count\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A matrix handle in case of success, or -1 on error\&.
.RE
.PP

.SS "void blas_suscr_variable_block_begin_ (int * Mb, int * Nb, const int * K, const int * L, \fBblas_sparse_matrix\fP * A, int * istat)"
Allocates an empty matrix (A) and leaves it in build state\&. 
.PP
\fBParameters:\fP
.RS 4
\fIK,L\fP Are arrays specifying row/column block sizes when specifying a matrix as VBR\&. 
.br
\fIMb\fP Block rows count\&. 
.br
\fINb\fP Block columns count\&.
.br
\fIA\fP A valid pointer to an empty matrix handle\&. 
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. Will assign a valid matrix handle to $A$ in case of success, or set it to -1 on error\&.
.RE
.PP

.SS "int BLAS_susdot (const enum \fBblas_conj_type\fP conj, const int nnz, const float * x, const int * indx, const float * y, const int incy, float * r, const enum \fBblas_base_type\fP index_base)"
Sparse dot product\&. $r <- X^T Y,$ $r <- X^H Y$ 
.PP
\fBParameters:\fP
.RS 4
\fIr\fP Sparse dot result array\&. 
.br
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&. 
.br
\fIconj\fP If \fBblas_conj\fP, values of X will be considered conjugated\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "void blas_susdot_ (const enum \fBblas_conj_type\fP * conj, const int * nnz, const float * x, const int * indx, const float * y, const int * incy, float * r, const enum \fBblas_base_type\fP * index_base, int * istat)"
Sparse dot product\&. $r <- X^T Y,$ $r <- X^H Y$ 
.PP
\fBParameters:\fP
.RS 4
\fIr\fP Sparse dot result array\&. 
.br
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&. 
.br
\fIconj\fP If \fBblas_conj\fP, values of X will be considered conjugated\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "int BLAS_susga (const int nnz, const float * y, const int incy, float * x, const int * indx, const enum \fBblas_base_type\fP index_base)"
Sparse gather\&. $X <- Y |_x$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&.\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "void blas_susga_ (const int * nnz, const float * y, const int * incy, float * x, const int * indx, const enum \fBblas_base_type\fP * index_base, int * istat)"
Sparse gather\&. $X <- Y |_x$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&.\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "int BLAS_susget_diag (\fBblas_sparse_matrix\fP A, float * d)"
Get matrix diagonal\&. $d <- diag(A)$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fId\fP Array for the diagonal entries\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_susget_diag_ (\fBblas_sparse_matrix\fP * A, float * d, int * istat)"
Get matrix diagonal\&. $d <- diag(A)$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fId\fP Array for the diagonal entries\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_susget_element (\fBblas_sparse_matrix\fP A, const int i, const int j, float * v)"
Get a single matrix nonzero coefficient $A_{i,j}$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIi\fP Row index\&. 
.br
\fIj\fP Column index\&. 
.br
\fIv\fP Value pointer\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_susget_element_ (\fBblas_sparse_matrix\fP * A, const int * i, const int * j, float * v, int * istat)"
Get a single matrix nonzero coefficient $A_{i,j}$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIi\fP Row index\&. 
.br
\fIj\fP Column index\&. 
.br
\fIv\fP Value pointer\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_susget_infinity_norm (\fBblas_sparse_matrix\fP A, float * in, const enum \fBblas_trans_type\fP trans)"
Get infinity norm of matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIin\fP Infinity norm pointer\&. 
.br
\fItrans\fP Transposition parameter\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_susget_infinity_norm_ (\fBblas_sparse_matrix\fP * A, float * in, const enum \fBblas_trans_type\fP * trans, int * istat)"
Get infinity norm of matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIin\fP Infinity norm pointer\&. 
.br
\fItrans\fP Transposition parameter\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_susget_matrix_nnz (\fBblas_sparse_matrix\fP A, int * nnz)"
Get nnz count of matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fInnz\fP Output value pointer\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_susget_matrix_nnz_ (\fBblas_sparse_matrix\fP * A, int * nnz, int * istat)"
Get nnz count of matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fInnz\fP Output value pointer\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_susget_rows_nnz (\fBblas_sparse_matrix\fP A, const int fr, const int lr, int * nnzp)"
Get nnz count of matrix row interval\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIfr\fP First row\&. 
.br
\fIlr\fP Last row\&. 
.br
\fInnzp\fP Pointer to the nonzeroes variable\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_susget_rows_nnz_ (\fBblas_sparse_matrix\fP * A, const int * fr, const int * lr, int * nnzp, int * istat)"
Get nnz count of matrix row interval\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIfr\fP First row\&. 
.br
\fIlr\fP Last row\&. 
.br
\fInnzp\fP Pointer to the nonzeroes variable\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_susget_rows_sparse (\fBblas_sparse_matrix\fP A, float * VA, int * IA, int * JA, int * nnz, const int fr, const int lr)"
Get sparse rows of matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIVA\fP pointer to values\&. 
.br
\fIIA\fP Row indices array\&. 
.br
\fIJA\fP Column indices array\&. 
.br
\fInnz\fP Obtained nonzeroes\&. 
.br
\fIfr\fP first row\&. 
.br
\fIlr\fP Last row\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_susget_rows_sparse_ (\fBblas_sparse_matrix\fP * A, float * VA, int * IA, int * JA, int * nnz, const int * fr, const int * lr, int * istat)"
Get sparse rows of matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIVA\fP pointer to values\&. 
.br
\fIIA\fP Row indices array\&. 
.br
\fIJA\fP Column indices array\&. 
.br
\fInnz\fP Obtained nonzeroes\&. 
.br
\fIfr\fP first row\&. 
.br
\fIlr\fP Last row\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_susgz (const int nnz, float * y, const int incy, float * x, const int * indx, const enum \fBblas_base_type\fP index_base)"
Sparse gather and zero\&. $X <- Y |_x;Y|_x <- 0$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&.\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "void blas_susgz_ (const int * nnz, float * y, const int * incy, float * x, const int * indx, const enum \fBblas_base_type\fP * index_base, int * istat)"
Sparse gather and zero\&. $X <- Y |_x;Y|_x <- 0$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&.\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "int BLAS_susmm (const enum \fBblas_order_type\fP order, const enum \fBblas_trans_type\fP transA, const int nrhs, float alpha, const \fBblas_sparse_matrix\fP A, const float * b, const int ldb, float * c, const int ldc)"
Multiply by a dense matrix (aka multi-vector)\&. Either of $C <- alpha AB+C,$ $C <- alpha A^T B+C,$ $C <- alpha A^H B+C$, depending on the value of \fCtransA\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIorder\fP layour of the dense array\&. 
.br
\fItransA\fP Transposition operator for matrix \fIA\fP\&. 
.br
\fInrhs\fP Number of right hand side columns\&. 
.br
\fIA\fP A valid matrix handle\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIb\fP Dense vector \fIb\fP\&. 
.br
\fIldb\fP Leading dimension of \fIb\fP\&. 
.br
\fIc\fP Dense vector \fIc\fP\&. 
.br
\fIldc\fP Leading dimension of \fIc\fP\&. 
.RE
.PP
\fBNote:\fP
.RS 4
.PP
.PP
By setting the \fC\fBblas_rsb_autotune_next_operation\fP\fP property via \fBBLAS_ussp\fP (at any time) the next multiplication routine call (either of \fBBLAS_dusmv\fP, \fBBLAS_susmv\fP, \fBBLAS_zusmv\fP, \fBBLAS_cusmv\fP, \fBBLAS_dusmm\fP, \fBBLAS_susmm\fP, \fBBLAS_zusmm\fP, \fBBLAS_cusmm\fP) will invoke autotuning before carrying out the effective operation\&. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants\&. By setting the \fC\fBblas_rsb_spmv_autotuning_on\fP\fP property via \fBBLAS_ussp\fP, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply)\&. This can be overridden only by setting the \fCRSB_NUM_THREADS\fP environment variable\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
On the topic of autotuning, see also \fBrsb_tune_spmm\fP\&. If \fC--enable-rsb-num-threads\fP has been specified at configure time, the \fCRSB_NUM_THREADS\fP environment variable will override the number of executing threads specified by \fCOMP_NUM_THREADS\fP\&. (See also \fBRSB_IO_WANT_EXECUTING_THREADS\fP)\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_susmm_ (const enum \fBblas_order_type\fP * order, const enum \fBblas_trans_type\fP * transA, const int * nrhs, float * alpha, const \fBblas_sparse_matrix\fP * A, const float * b, const int * ldb, float * c, const int * ldc, int * istat)"
Multiply by a dense matrix (aka multi-vector)\&. Either of $C <- alpha AB+C,$ $C <- alpha A^T B+C,$ $C <- alpha A^H B+C$, depending on the value of \fCtransA\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIorder\fP layour of the dense array\&. 
.br
\fItransA\fP Transposition operator for matrix \fIA\fP\&. 
.br
\fInrhs\fP Number of right hand side columns\&. 
.br
\fIA\fP A valid matrix handle\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIb\fP Dense vector \fIb\fP\&. 
.br
\fIldb\fP Leading dimension of \fIb\fP\&. 
.br
\fIc\fP Dense vector \fIc\fP\&. 
.br
\fIldc\fP Leading dimension of \fIc\fP\&. 
.RE
.PP
\fBNote:\fP
.RS 4
.PP
.PP
By setting the \fC\fBblas_rsb_autotune_next_operation\fP\fP property via \fBBLAS_ussp\fP (at any time) the next multiplication routine call (either of \fBBLAS_dusmv\fP, \fBBLAS_susmv\fP, \fBBLAS_zusmv\fP, \fBBLAS_cusmv\fP, \fBBLAS_dusmm\fP, \fBBLAS_susmm\fP, \fBBLAS_zusmm\fP, \fBBLAS_cusmm\fP) will invoke autotuning before carrying out the effective operation\&. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants\&. By setting the \fC\fBblas_rsb_spmv_autotuning_on\fP\fP property via \fBBLAS_ussp\fP, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply)\&. This can be overridden only by setting the \fCRSB_NUM_THREADS\fP environment variable\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
On the topic of autotuning, see also \fBrsb_tune_spmm\fP\&. If \fC--enable-rsb-num-threads\fP has been specified at configure time, the \fCRSB_NUM_THREADS\fP environment variable will override the number of executing threads specified by \fCOMP_NUM_THREADS\fP\&. (See also \fBRSB_IO_WANT_EXECUTING_THREADS\fP)\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_susmv (const enum \fBblas_trans_type\fP transA, float alpha, const \fBblas_sparse_matrix\fP A, const float * x, const int incx, float * y, const int incy)"
Multiply by a dense vector\&. Either of $Y <- alpha A X + Y ,$ $Y <- alpha A^T X + Y,$ $Y <- alpha A^H X + Y$, depending on the value of \fCtransA\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fItransA\fP Transposition operator for matrix \fIA\fP\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIA\fP A valid matrix handle\&. 
.br
\fIx\fP Dense vector \fIx\fP\&. 
.br
\fIincx\fP Stride of \fIx\fP\&. 
.br
\fIy\fP Dense vector \fIy\fP\&. 
.br
\fIincy\fP Stride of \fIy\fP\&. 
.RE
.PP
\fBNote:\fP
.RS 4
.PP
.PP
By setting the \fC\fBblas_rsb_autotune_next_operation\fP\fP property via \fBBLAS_ussp\fP (at any time) the next multiplication routine call (either of \fBBLAS_dusmv\fP, \fBBLAS_susmv\fP, \fBBLAS_zusmv\fP, \fBBLAS_cusmv\fP, \fBBLAS_dusmm\fP, \fBBLAS_susmm\fP, \fBBLAS_zusmm\fP, \fBBLAS_cusmm\fP) will invoke autotuning before carrying out the effective operation\&. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants\&. By setting the \fC\fBblas_rsb_spmv_autotuning_on\fP\fP property via \fBBLAS_ussp\fP, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply)\&. This can be overridden only by setting the \fCRSB_NUM_THREADS\fP environment variable\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
On the topic of autotuning, see also \fBrsb_tune_spmm\fP\&. If \fC--enable-rsb-num-threads\fP has been specified at configure time, the \fCRSB_NUM_THREADS\fP environment variable will override the number of executing threads specified by \fCOMP_NUM_THREADS\fP\&. (See also \fBRSB_IO_WANT_EXECUTING_THREADS\fP)\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_susmv_ (const enum \fBblas_trans_type\fP * transA, float * alpha, const \fBblas_sparse_matrix\fP * A, const float * x, const int * incx, float * y, const int * incy, int * istat)"
Multiply by a dense vector\&. Either of $Y <- alpha A X + Y ,$ $Y <- alpha A^T X + Y,$ $Y <- alpha A^H X + Y$, depending on the value of \fCtransA\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fItransA\fP Transposition operator for matrix \fIA\fP\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIA\fP A valid matrix handle\&. 
.br
\fIx\fP Dense vector \fIx\fP\&. 
.br
\fIincx\fP Stride of \fIx\fP\&. 
.br
\fIy\fP Dense vector \fIy\fP\&. 
.br
\fIincy\fP Stride of \fIy\fP\&. 
.RE
.PP
\fBNote:\fP
.RS 4
.PP
.PP
By setting the \fC\fBblas_rsb_autotune_next_operation\fP\fP property via \fBBLAS_ussp\fP (at any time) the next multiplication routine call (either of \fBBLAS_dusmv\fP, \fBBLAS_susmv\fP, \fBBLAS_zusmv\fP, \fBBLAS_cusmv\fP, \fBBLAS_dusmm\fP, \fBBLAS_susmm\fP, \fBBLAS_zusmm\fP, \fBBLAS_cusmm\fP) will invoke autotuning before carrying out the effective operation\&. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants\&. By setting the \fC\fBblas_rsb_spmv_autotuning_on\fP\fP property via \fBBLAS_ussp\fP, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply)\&. This can be overridden only by setting the \fCRSB_NUM_THREADS\fP environment variable\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
On the topic of autotuning, see also \fBrsb_tune_spmm\fP\&. If \fC--enable-rsb-num-threads\fP has been specified at configure time, the \fCRSB_NUM_THREADS\fP environment variable will override the number of executing threads specified by \fCOMP_NUM_THREADS\fP\&. (See also \fBRSB_IO_WANT_EXECUTING_THREADS\fP)\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_susrows_scale (\fBblas_sparse_matrix\fP A, const float * d, const enum \fBblas_trans_type\fP trans)"
Scale rows interval of matrix by specified factor\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fId\fP Rows scaling vector\&. 
.br
\fItrans\fP Transposition parameter (if transposed will scale columns)\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_susrows_scale_ (\fBblas_sparse_matrix\fP * A, const float * d, const enum \fBblas_trans_type\fP * trans, int * istat)"
Scale rows interval of matrix by specified factor\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fId\fP Rows scaling vector\&. 
.br
\fItrans\fP Transposition parameter (if transposed will scale columns)\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_sussc (const int nnz, const float * x, float * y, const int incy, const int * indx, const enum \fBblas_base_type\fP index_base)"
Sparse scatter: $Y |_x <- X$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&.\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "void blas_sussc_ (const int * nnz, const float * x, float * y, const int * incy, const int * indx, const enum \fBblas_base_type\fP * index_base, int * istat)"
Sparse scatter: $Y |_x <- X$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&.\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "int BLAS_susset_element (\fBblas_sparse_matrix\fP A, const int i, const int j, float * v)"
Set a single (existing) matrix nonzero coefficient $A_{i,j}$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIi\fP Row index\&. 
.br
\fIj\fP Column index\&. 
.br
\fIv\fP Value pointer\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_susset_element_ (\fBblas_sparse_matrix\fP * A, const int * i, const int * j, float * v, int * istat)"
Set a single (existing) matrix nonzero coefficient $A_{i,j}$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIi\fP Row index\&. 
.br
\fIj\fP Column index\&. 
.br
\fIv\fP Value pointer\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_susset_elements (\fBblas_sparse_matrix\fP A, const int * ia, const int * ja, const float * va, const int nnz)"
Set individual matrix nonzero coefficients values\&. The operation is pattern preserving, that is, nonzeroes must already exist\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIia\fP Row indices array\&. 
.br
\fIja\fP Column indices array\&. 
.br
\fIva\fP Values array\&. 
.br
\fInnz\fP Length of the \fCia\fP,ja,va arrays\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_susset_elements_ (\fBblas_sparse_matrix\fP * A, const int * ia, const int * ja, const float * va, const int * nnz, int * istat)"
Set individual matrix nonzero coefficients values\&. The operation is pattern preserving, that is, nonzeroes must already exist\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIia\fP Row indices array\&. 
.br
\fIja\fP Column indices array\&. 
.br
\fIva\fP Values array\&. 
.br
\fInnz\fP Length of the \fCia\fP,ja,va arrays\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_sussm (const enum \fBblas_order_type\fP order, const enum \fBblas_trans_type\fP transT, const int nrhs, float alpha, const \fBblas_sparse_matrix\fP T, float * b, const int ldb)"
Triangular solve, by a dense matrix (aka multi-vector)\&. Either of $B <- alpha T^{-1} B,$ $B <- alpha T^{-T} B,$ $B <- alpha T^{-H} B$, depending on the value of \fCtransT\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIorder\fP layour of the dense array\&. 
.br
\fItransT\fP Transposition operator for matrix \fIT\fP\&. 
.br
\fInrhs\fP Number of right hand side columns\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIT\fP A valid triangular matrix handle\&. 
.br
\fIb\fP Dense vector \fIb\fP\&. 
.br
\fIldb\fP Leading dimension of \fIb\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_sussm_ (const enum \fBblas_order_type\fP * order, const enum \fBblas_trans_type\fP * transT, const int * nrhs, float * alpha, const \fBblas_sparse_matrix\fP * T, float * b, const int * ldb, int * istat)"
Triangular solve, by a dense matrix (aka multi-vector)\&. Either of $B <- alpha T^{-1} B,$ $B <- alpha T^{-T} B,$ $B <- alpha T^{-H} B$, depending on the value of \fCtransT\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIorder\fP layour of the dense array\&. 
.br
\fItransT\fP Transposition operator for matrix \fIT\fP\&. 
.br
\fInrhs\fP Number of right hand side columns\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIT\fP A valid triangular matrix handle\&. 
.br
\fIb\fP Dense vector \fIb\fP\&. 
.br
\fIldb\fP Leading dimension of \fIb\fP\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_sussv (enum \fBblas_trans_type\fP transT, float alpha, const \fBblas_sparse_matrix\fP T, float * x, const int incx)"
Triangular solve, by a dense vector\&. Either of $X <- alpha T^{-1}X,$ $X <- alpha T^{-T}X,$ $X <- alpha T^{-H}X$, depending on the value of \fCtransT\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fItransT\fP Transposition operator for matrix \fIT\fP\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIT\fP A valid triangular matrix handle\&. 
.br
\fIx\fP Dense vector \fIx\fP\&. 
.br
\fIincx\fP Stride of \fIx\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_sussv_ (enum \fBblas_trans_type\fP * transT, float * alpha, const \fBblas_sparse_matrix\fP * T, float * x, const int * incx, int * istat)"
Triangular solve, by a dense vector\&. Either of $X <- alpha T^{-1}X,$ $X <- alpha T^{-T}X,$ $X <- alpha T^{-H}X$, depending on the value of \fCtransT\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fItransT\fP Transposition operator for matrix \fIT\fP\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIT\fP A valid triangular matrix handle\&. 
.br
\fIx\fP Dense vector \fIx\fP\&. 
.br
\fIincx\fP Stride of \fIx\fP\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_uscr_end (\fBblas_sparse_matrix\fP A)"
Makes an assembled matrix out of a matrix in build state\&. After this, it is not possible anymore to insert nonzeroes, but computational routines\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_uscr_end_ (\fBblas_sparse_matrix\fP * A, int * istat)"
Makes an assembled matrix out of a matrix in build state\&. After this, it is not possible anymore to insert nonzeroes, but computational routines\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_usds (\fBblas_sparse_matrix\fP A)"
Destroys a matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_usds_ (\fBblas_sparse_matrix\fP * A, int * istat)"
Destroys a matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_usgp (\fBblas_sparse_matrix\fP A, rsb_blas_pname_t pname)"
Get a matrix property\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A is the matrix to apply the property\&. 
.br
\fIpname\fP The desired matrix property\&. For valid matrix properties, see \fBblas_rsb_ext_type\fP, \fBblas_uplo_type\fP, \fBblas_diag_type\fP, \fBblas_conj_type\fP, \fBblas_base_type\fP, \fBblas_symmetry_type\fP, \fBblas_field_type\fP, \fBblas_size_type\fP, \fBblas_sparsity_optimization_type\fP\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_usgp_ (\fBblas_sparse_matrix\fP * A, rsb_blas_pname_t * pname, int * istat)"
Get a matrix property\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A is the matrix to apply the property\&. 
.br
\fIpname\fP The desired matrix property\&. For valid matrix properties, see \fBblas_rsb_ext_type\fP, \fBblas_uplo_type\fP, \fBblas_diag_type\fP, \fBblas_conj_type\fP, \fBblas_base_type\fP, \fBblas_symmetry_type\fP, \fBblas_field_type\fP, \fBblas_size_type\fP, \fBblas_sparsity_optimization_type\fP\&. 
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_ussp (\fBblas_sparse_matrix\fP A, rsb_blas_pname_t pname)"
Set a matrix property\&. Should be called just after creation, before nonzeroes insertion\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A is the matrix to apply the property\&. 
.br
\fIpname\fP The desired matrix property\&. For valid matrix properties, see \fBblas_rsb_ext_type\fP, \fBblas_uplo_type\fP, \fBblas_diag_type\fP, \fBblas_conj_type\fP, \fBblas_base_type\fP, \fBblas_symmetry_type\fP, \fBblas_field_type\fP, \fBblas_size_type\fP, \fBblas_sparsity_optimization_type\fP\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_ussp_ (\fBblas_sparse_matrix\fP * A, rsb_blas_pname_t * pname, int * istat)"
Set a matrix property\&. Should be called just after creation, before nonzeroes insertion\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A is the matrix to apply the property\&. 
.br
\fIpname\fP The desired matrix property\&. For valid matrix properties, see \fBblas_rsb_ext_type\fP, \fBblas_uplo_type\fP, \fBblas_diag_type\fP, \fBblas_conj_type\fP, \fBblas_base_type\fP, \fBblas_symmetry_type\fP, \fBblas_field_type\fP, \fBblas_size_type\fP, \fBblas_sparsity_optimization_type\fP\&. 
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_zusaxpy (const int nnz, const void * alpha, const void * x, const int * indx, void * y, const int incy, const enum \fBblas_base_type\fP index_base)"
Sparse vector update: $Y <- alpha X + Y$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&. 
.br
\fIalpha\fP Will scale values of $X$ before accumulating to $Y$\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "void blas_zusaxpy_ (const int * nnz, const void * alpha, const void * x, const int * indx, void * y, const int * incy, const enum \fBblas_base_type\fP * index_base, int * istat)"
Sparse vector update: $Y <- alpha X + Y$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&. 
.br
\fIalpha\fP Will scale values of $X$ before accumulating to $Y$\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "\fBblas_sparse_matrix\fP BLAS_zuscr_begin (int m, int n)"
Allocates an empty matrix (A) and leaves it in build state\&. 
.PP
\fBParameters:\fP
.RS 4
\fIm\fP Is the count of rows\&. 
.br
\fIn\fP Is the count of columns\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A matrix handle in case of success, or -1 on error\&.
.RE
.PP

.SS "void blas_zuscr_begin_ (int * m, int * n, \fBblas_sparse_matrix\fP * A, int * istat)"
Allocates an empty matrix (A) and leaves it in build state\&. 
.PP
\fBParameters:\fP
.RS 4
\fIm\fP Is the count of rows\&. 
.br
\fIn\fP Is the count of columns\&.
.br
\fIA\fP A valid pointer to an empty matrix handle\&. 
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. Will assign a valid matrix handle to $A$ in case of success, or set it to -1 on error\&.
.RE
.PP

.SS "\fBblas_sparse_matrix\fP BLAS_zuscr_block_begin (int Mb, int Nb, int k, int l)"
Allocates an empty matrix (A) and leaves it in build state\&. 
.PP
\fBParameters:\fP
.RS 4
\fIk,l\fP Are row and column dimensions when specifying a matrix as BCSR\&. 
.br
\fIMb\fP Block rows count\&. 
.br
\fINb\fP Block columns count\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A matrix handle in case of success, or -1 on error\&.
.RE
.PP

.SS "void blas_zuscr_block_begin_ (int * Mb, int * Nb, int * k, int * l, \fBblas_sparse_matrix\fP * A, int * istat)"
Allocates an empty matrix (A) and leaves it in build state\&. 
.PP
\fBParameters:\fP
.RS 4
\fIk,l\fP Are row and column dimensions when specifying a matrix as BCSR\&. 
.br
\fIMb\fP Block rows count\&. 
.br
\fINb\fP Block columns count\&.
.br
\fIA\fP A valid pointer to an empty matrix handle\&. 
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. Will assign a valid matrix handle to $A$ in case of success, or set it to -1 on error\&.
.RE
.PP

.SS "int BLAS_zuscr_end (\fBblas_sparse_matrix\fP A)"
Makes an assembled matrix out of a matrix in build state\&. After this, it is not possible anymore to insert nonzeroes, but computational routines\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_zuscr_end_ (\fBblas_sparse_matrix\fP * A, int * istat)"
Makes an assembled matrix out of a matrix in build state\&. After this, it is not possible anymore to insert nonzeroes, but computational routines\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_zuscr_insert_block (\fBblas_sparse_matrix\fP A, const void * val, int row_stride, int col_stride, int i, int j)"
Inserts a whole block in a matrix, assuming it is in build state\&. The block size is assumed to be the one specified when calling the (type) corresponding matrix blocked \fCbegin\fP function\&. If not called a blocked \fCbegin\fP function, will assume 1x1 (that is, no) blocking\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIrow_stride,col_stride\fP Row and column strides in accessing \fCval\fP\&. 
.br
\fIi,j\fP Block row/column indices\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Signature of this routine for Fortran does not agree to the standard\&. This shall be corrected in a future release\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBBLAS_cuscr_block_begin\fP, \fBBLAS_cuscr_block_begin\fP, \fBBLAS_duscr_block_begin\fP, \fBBLAS_zuscr_block_begin\fP, \fBBLAS_cuscr_begin\fP, \fBBLAS_suscr_begin\fP, \fBBLAS_duscr_begin\fP, \fBBLAS_zuscr_begin\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_zuscr_insert_block_ (\fBblas_sparse_matrix\fP * A, const void * val, int * row_stride, int * col_stride, int * i, int * j, int * istat)"
Inserts a whole block in a matrix, assuming it is in build state\&. The block size is assumed to be the one specified when calling the (type) corresponding matrix blocked \fCbegin\fP function\&. If not called a blocked \fCbegin\fP function, will assume 1x1 (that is, no) blocking\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIrow_stride,col_stride\fP Row and column strides in accessing \fCval\fP\&. 
.br
\fIi,j\fP Block row/column indices\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Signature of this routine for Fortran does not agree to the standard\&. This shall be corrected in a future release\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBBLAS_cuscr_block_begin\fP, \fBBLAS_cuscr_block_begin\fP, \fBBLAS_duscr_block_begin\fP, \fBBLAS_zuscr_block_begin\fP, \fBBLAS_cuscr_begin\fP, \fBBLAS_suscr_begin\fP, \fBBLAS_duscr_begin\fP, \fBBLAS_zuscr_begin\fP\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_zuscr_insert_clique (\fBblas_sparse_matrix\fP A, const int k, const int l, const void * val, const int row_stride, const int col_stride, const int * indx, const int * jndx)"
Inserts a whole clique in a matrix, assuming this is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIk,l\fP Clique rows and columns count\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIrow_stride,col_stride\fP Row/columns stride in accessing the clique\&. 
.br
\fIindx,jndx\fP Row/column indices arrays\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Signature of this routine for Fortran does not agree to the standard\&. This shall be corrected in a future release\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_zuscr_insert_clique_ (\fBblas_sparse_matrix\fP * A, const int * k, const int * l, const void * val, const int * row_stride, const int * col_stride, const int * indx, const int * jndx, int * istat)"
Inserts a whole clique in a matrix, assuming this is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIk,l\fP Clique rows and columns count\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIrow_stride,col_stride\fP Row/columns stride in accessing the clique\&. 
.br
\fIindx,jndx\fP Row/column indices arrays\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Signature of this routine for Fortran does not agree to the standard\&. This shall be corrected in a future release\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_zuscr_insert_col (\fBblas_sparse_matrix\fP A, int j, int nnz, const void * val, const int * indx)"
Inserts a whole column in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIj\fP Column index\&. 
.br
\fInnz\fP Number of nonzeroes to insert\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIindx\fP Row indices array\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_zuscr_insert_col_ (\fBblas_sparse_matrix\fP * A, int * j, int * nnz, const void * val, const int * indx, int * istat)"
Inserts a whole column in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIj\fP Column index\&. 
.br
\fInnz\fP Number of nonzeroes to insert\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIindx\fP Row indices array\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_zuscr_insert_entries (\fBblas_sparse_matrix\fP A, int nnz, const void * val, const int * indx, const int * jndx)"
Inserts entries in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fInnz\fP Number of nonzeroes to insert\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIindx\fP Row indices array\&. 
.br
\fIjndx\fP Column indices array\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_zuscr_insert_entries_ (\fBblas_sparse_matrix\fP * A, int * nnz, const void * val, const int * indx, const int * jndx, int * istat)"
Inserts entries in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fInnz\fP Number of nonzeroes to insert\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIindx\fP Row indices array\&. 
.br
\fIjndx\fP Column indices array\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_zuscr_insert_entry (\fBblas_sparse_matrix\fP A, const void * val, int i, int j)"
Inserts an entry in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIi,j\fP Row and column indices\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_zuscr_insert_entry_ (\fBblas_sparse_matrix\fP * A, const void * val, int * i, int * j, int * istat)"
Inserts an entry in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIi,j\fP Row and column indices\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_zuscr_insert_row (\fBblas_sparse_matrix\fP A, int i, int nnz, const void * val, const int * indx)"
Inserts a whole row in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIi\fP Row index\&. 
.br
\fInnz\fP Number of nonzeroes to insert\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIindx\fP Row index\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_zuscr_insert_row_ (\fBblas_sparse_matrix\fP * A, int * i, int * nnz, const void * val, const int * indx, int * istat)"
Inserts a whole row in a matrix, assuming it is in build state\&. By default, duplicate entries will be summed together\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIi\fP Row index\&. 
.br
\fInnz\fP Number of nonzeroes to insert\&. 
.br
\fIval\fP Array of values\&. 
.br
\fIindx\fP Row index\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "\fBblas_sparse_matrix\fP BLAS_zuscr_variable_block_begin (int Mb, int Nb, const int * K, const int * L)"
Allocates an empty matrix (A) and leaves it in build state\&. 
.PP
\fBParameters:\fP
.RS 4
\fIK,L\fP Are arrays specifying row/column block sizes when specifying a matrix as VBR\&. 
.br
\fIMb\fP Block rows count\&. 
.br
\fINb\fP Block columns count\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A matrix handle in case of success, or -1 on error\&.
.RE
.PP

.SS "void blas_zuscr_variable_block_begin_ (int * Mb, int * Nb, const int * K, const int * L, \fBblas_sparse_matrix\fP * A, int * istat)"
Allocates an empty matrix (A) and leaves it in build state\&. 
.PP
\fBParameters:\fP
.RS 4
\fIK,L\fP Are arrays specifying row/column block sizes when specifying a matrix as VBR\&. 
.br
\fIMb\fP Block rows count\&. 
.br
\fINb\fP Block columns count\&.
.br
\fIA\fP A valid pointer to an empty matrix handle\&. 
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. Will assign a valid matrix handle to $A$ in case of success, or set it to -1 on error\&.
.RE
.PP

.SS "int BLAS_zusdot (const enum \fBblas_conj_type\fP conj, const int nnz, const void * x, const int * indx, const void * y, const int incy, void * r, const enum \fBblas_base_type\fP index_base)"
Sparse dot product\&. $r <- X^T Y,$ $r <- X^H Y$ 
.PP
\fBParameters:\fP
.RS 4
\fIr\fP Sparse dot result array\&. 
.br
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&. 
.br
\fIconj\fP If \fBblas_conj\fP, values of X will be considered conjugated\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "void blas_zusdot_ (const enum \fBblas_conj_type\fP * conj, const int * nnz, const void * x, const int * indx, const void * y, const int * incy, void * r, const enum \fBblas_base_type\fP * index_base, int * istat)"
Sparse dot product\&. $r <- X^T Y,$ $r <- X^H Y$ 
.PP
\fBParameters:\fP
.RS 4
\fIr\fP Sparse dot result array\&. 
.br
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&. 
.br
\fIconj\fP If \fBblas_conj\fP, values of X will be considered conjugated\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "int BLAS_zusga (const int nnz, const void * y, const int incy, void * x, const int * indx, const enum \fBblas_base_type\fP index_base)"
Sparse gather\&. $X <- Y |_x$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&.\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "void blas_zusga_ (const int * nnz, const void * y, const int * incy, void * x, const int * indx, const enum \fBblas_base_type\fP * index_base, int * istat)"
Sparse gather\&. $X <- Y |_x$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&.\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "int BLAS_zusget_diag (\fBblas_sparse_matrix\fP A, void * d)"
Get matrix diagonal\&. $d <- diag(A)$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fId\fP Array for the diagonal entries\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_zusget_diag_ (\fBblas_sparse_matrix\fP * A, void * d, int * istat)"
Get matrix diagonal\&. $d <- diag(A)$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fId\fP Array for the diagonal entries\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_zusget_element (\fBblas_sparse_matrix\fP A, const int i, const int j, void * v)"
Get a single matrix nonzero coefficient $A_{i,j}$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIi\fP Row index\&. 
.br
\fIj\fP Column index\&. 
.br
\fIv\fP Value pointer\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_zusget_element_ (\fBblas_sparse_matrix\fP * A, const int * i, const int * j, void * v, int * istat)"
Get a single matrix nonzero coefficient $A_{i,j}$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIi\fP Row index\&. 
.br
\fIj\fP Column index\&. 
.br
\fIv\fP Value pointer\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_zusget_infinity_norm (\fBblas_sparse_matrix\fP A, void * in, const enum \fBblas_trans_type\fP trans)"
Get infinity norm of matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIin\fP Infinity norm pointer\&. 
.br
\fItrans\fP Transposition parameter\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_zusget_infinity_norm_ (\fBblas_sparse_matrix\fP * A, void * in, const enum \fBblas_trans_type\fP * trans, int * istat)"
Get infinity norm of matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIin\fP Infinity norm pointer\&. 
.br
\fItrans\fP Transposition parameter\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_zusget_matrix_nnz (\fBblas_sparse_matrix\fP A, int * nnz)"
Get nnz count of matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fInnz\fP Output value pointer\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_zusget_matrix_nnz_ (\fBblas_sparse_matrix\fP * A, int * nnz, int * istat)"
Get nnz count of matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fInnz\fP Output value pointer\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_zusget_rows_nnz (\fBblas_sparse_matrix\fP A, const int fr, const int lr, int * nnzp)"
Get nnz count of matrix row interval\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIfr\fP First row\&. 
.br
\fIlr\fP Last row\&. 
.br
\fInnzp\fP Pointer to the nonzeroes variable\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_zusget_rows_nnz_ (\fBblas_sparse_matrix\fP * A, const int * fr, const int * lr, int * nnzp, int * istat)"
Get nnz count of matrix row interval\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIfr\fP First row\&. 
.br
\fIlr\fP Last row\&. 
.br
\fInnzp\fP Pointer to the nonzeroes variable\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_zusget_rows_sparse (\fBblas_sparse_matrix\fP A, void * VA, int * IA, int * JA, int * nnz, const int fr, const int lr)"
Get sparse rows of matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIVA\fP pointer to values\&. 
.br
\fIIA\fP Row indices array\&. 
.br
\fIJA\fP Column indices array\&. 
.br
\fInnz\fP Obtained nonzeroes\&. 
.br
\fIfr\fP first row\&. 
.br
\fIlr\fP Last row\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_zusget_rows_sparse_ (\fBblas_sparse_matrix\fP * A, void * VA, int * IA, int * JA, int * nnz, const int * fr, const int * lr, int * istat)"
Get sparse rows of matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIVA\fP pointer to values\&. 
.br
\fIIA\fP Row indices array\&. 
.br
\fIJA\fP Column indices array\&. 
.br
\fInnz\fP Obtained nonzeroes\&. 
.br
\fIfr\fP first row\&. 
.br
\fIlr\fP Last row\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_zusgz (const int nnz, void * y, const int incy, void * x, const int * indx, const enum \fBblas_base_type\fP index_base)"
Sparse gather and zero\&. $X <- Y |_x;Y|_x <- 0$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&.\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "void blas_zusgz_ (const int * nnz, void * y, const int * incy, void * x, const int * indx, const enum \fBblas_base_type\fP * index_base, int * istat)"
Sparse gather and zero\&. $X <- Y |_x;Y|_x <- 0$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&.\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "int BLAS_zusmm (const enum \fBblas_order_type\fP order, const enum \fBblas_trans_type\fP transA, const int nrhs, const void * alpha, const \fBblas_sparse_matrix\fP A, const void * b, const int ldb, void * c, const int ldc)"
Multiply by a dense matrix (aka multi-vector)\&. Either of $C <- alpha AB+C,$ $C <- alpha A^T B+C,$ $C <- alpha A^H B+C$, depending on the value of \fCtransA\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIorder\fP layour of the dense array\&. 
.br
\fItransA\fP Transposition operator for matrix \fIA\fP\&. 
.br
\fInrhs\fP Number of right hand side columns\&. 
.br
\fIA\fP A valid matrix handle\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIb\fP Dense vector \fIb\fP\&. 
.br
\fIldb\fP Leading dimension of \fIb\fP\&. 
.br
\fIc\fP Dense vector \fIc\fP\&. 
.br
\fIldc\fP Leading dimension of \fIc\fP\&. 
.RE
.PP
\fBNote:\fP
.RS 4
.PP
.PP
By setting the \fC\fBblas_rsb_autotune_next_operation\fP\fP property via \fBBLAS_ussp\fP (at any time) the next multiplication routine call (either of \fBBLAS_dusmv\fP, \fBBLAS_susmv\fP, \fBBLAS_zusmv\fP, \fBBLAS_cusmv\fP, \fBBLAS_dusmm\fP, \fBBLAS_susmm\fP, \fBBLAS_zusmm\fP, \fBBLAS_cusmm\fP) will invoke autotuning before carrying out the effective operation\&. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants\&. By setting the \fC\fBblas_rsb_spmv_autotuning_on\fP\fP property via \fBBLAS_ussp\fP, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply)\&. This can be overridden only by setting the \fCRSB_NUM_THREADS\fP environment variable\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
On the topic of autotuning, see also \fBrsb_tune_spmm\fP\&. If \fC--enable-rsb-num-threads\fP has been specified at configure time, the \fCRSB_NUM_THREADS\fP environment variable will override the number of executing threads specified by \fCOMP_NUM_THREADS\fP\&. (See also \fBRSB_IO_WANT_EXECUTING_THREADS\fP)\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_zusmm_ (const enum \fBblas_order_type\fP * order, const enum \fBblas_trans_type\fP * transA, const int * nrhs, const void * alpha, const \fBblas_sparse_matrix\fP * A, const void * b, const int * ldb, void * c, const int * ldc, int * istat)"
Multiply by a dense matrix (aka multi-vector)\&. Either of $C <- alpha AB+C,$ $C <- alpha A^T B+C,$ $C <- alpha A^H B+C$, depending on the value of \fCtransA\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIorder\fP layour of the dense array\&. 
.br
\fItransA\fP Transposition operator for matrix \fIA\fP\&. 
.br
\fInrhs\fP Number of right hand side columns\&. 
.br
\fIA\fP A valid matrix handle\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIb\fP Dense vector \fIb\fP\&. 
.br
\fIldb\fP Leading dimension of \fIb\fP\&. 
.br
\fIc\fP Dense vector \fIc\fP\&. 
.br
\fIldc\fP Leading dimension of \fIc\fP\&. 
.RE
.PP
\fBNote:\fP
.RS 4
.PP
.PP
By setting the \fC\fBblas_rsb_autotune_next_operation\fP\fP property via \fBBLAS_ussp\fP (at any time) the next multiplication routine call (either of \fBBLAS_dusmv\fP, \fBBLAS_susmv\fP, \fBBLAS_zusmv\fP, \fBBLAS_cusmv\fP, \fBBLAS_dusmm\fP, \fBBLAS_susmm\fP, \fBBLAS_zusmm\fP, \fBBLAS_cusmm\fP) will invoke autotuning before carrying out the effective operation\&. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants\&. By setting the \fC\fBblas_rsb_spmv_autotuning_on\fP\fP property via \fBBLAS_ussp\fP, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply)\&. This can be overridden only by setting the \fCRSB_NUM_THREADS\fP environment variable\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
On the topic of autotuning, see also \fBrsb_tune_spmm\fP\&. If \fC--enable-rsb-num-threads\fP has been specified at configure time, the \fCRSB_NUM_THREADS\fP environment variable will override the number of executing threads specified by \fCOMP_NUM_THREADS\fP\&. (See also \fBRSB_IO_WANT_EXECUTING_THREADS\fP)\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_zusmv (const enum \fBblas_trans_type\fP transA, const void * alpha, const \fBblas_sparse_matrix\fP A, const void * x, const int incx, void * y, const int incy)"
Multiply by a dense vector\&. Either of $Y <- alpha A X + Y ,$ $Y <- alpha A^T X + Y,$ $Y <- alpha A^H X + Y$, depending on the value of \fCtransA\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fItransA\fP Transposition operator for matrix \fIA\fP\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIA\fP A valid matrix handle\&. 
.br
\fIx\fP Dense vector \fIx\fP\&. 
.br
\fIincx\fP Stride of \fIx\fP\&. 
.br
\fIy\fP Dense vector \fIy\fP\&. 
.br
\fIincy\fP Stride of \fIy\fP\&. 
.RE
.PP
\fBNote:\fP
.RS 4
.PP
.PP
By setting the \fC\fBblas_rsb_autotune_next_operation\fP\fP property via \fBBLAS_ussp\fP (at any time) the next multiplication routine call (either of \fBBLAS_dusmv\fP, \fBBLAS_susmv\fP, \fBBLAS_zusmv\fP, \fBBLAS_cusmv\fP, \fBBLAS_dusmm\fP, \fBBLAS_susmm\fP, \fBBLAS_zusmm\fP, \fBBLAS_cusmm\fP) will invoke autotuning before carrying out the effective operation\&. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants\&. By setting the \fC\fBblas_rsb_spmv_autotuning_on\fP\fP property via \fBBLAS_ussp\fP, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply)\&. This can be overridden only by setting the \fCRSB_NUM_THREADS\fP environment variable\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
On the topic of autotuning, see also \fBrsb_tune_spmm\fP\&. If \fC--enable-rsb-num-threads\fP has been specified at configure time, the \fCRSB_NUM_THREADS\fP environment variable will override the number of executing threads specified by \fCOMP_NUM_THREADS\fP\&. (See also \fBRSB_IO_WANT_EXECUTING_THREADS\fP)\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_zusmv_ (const enum \fBblas_trans_type\fP * transA, const void * alpha, const \fBblas_sparse_matrix\fP * A, const void * x, const int * incx, void * y, const int * incy, int * istat)"
Multiply by a dense vector\&. Either of $Y <- alpha A X + Y ,$ $Y <- alpha A^T X + Y,$ $Y <- alpha A^H X + Y$, depending on the value of \fCtransA\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fItransA\fP Transposition operator for matrix \fIA\fP\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIA\fP A valid matrix handle\&. 
.br
\fIx\fP Dense vector \fIx\fP\&. 
.br
\fIincx\fP Stride of \fIx\fP\&. 
.br
\fIy\fP Dense vector \fIy\fP\&. 
.br
\fIincy\fP Stride of \fIy\fP\&. 
.RE
.PP
\fBNote:\fP
.RS 4
.PP
.PP
By setting the \fC\fBblas_rsb_autotune_next_operation\fP\fP property via \fBBLAS_ussp\fP (at any time) the next multiplication routine call (either of \fBBLAS_dusmv\fP, \fBBLAS_susmv\fP, \fBBLAS_zusmv\fP, \fBBLAS_cusmv\fP, \fBBLAS_dusmm\fP, \fBBLAS_susmm\fP, \fBBLAS_zusmm\fP, \fBBLAS_cusmm\fP) will invoke autotuning before carrying out the effective operation\&. The tuning will take in account parameters like transposition, number of right hand sides, and scaling constants\&. By setting the \fC\fBblas_rsb_spmv_autotuning_on\fP\fP property via \fBBLAS_ussp\fP, the default number of executing threads for this matrix will be determined once, at matrix assembly time, and employed irrespective of the default threads count (different values for transposed and untransposed multiply)\&. This can be overridden only by setting the \fCRSB_NUM_THREADS\fP environment variable\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
On the topic of autotuning, see also \fBrsb_tune_spmm\fP\&. If \fC--enable-rsb-num-threads\fP has been specified at configure time, the \fCRSB_NUM_THREADS\fP environment variable will override the number of executing threads specified by \fCOMP_NUM_THREADS\fP\&. (See also \fBRSB_IO_WANT_EXECUTING_THREADS\fP)\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_zusrows_scale (\fBblas_sparse_matrix\fP A, const void * d, const enum \fBblas_trans_type\fP trans)"
Scale rows interval of matrix by specified factor\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fId\fP Rows scaling vector\&. 
.br
\fItrans\fP Transposition parameter (if transposed will scale columns)\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_zusrows_scale_ (\fBblas_sparse_matrix\fP * A, const void * d, const enum \fBblas_trans_type\fP * trans, int * istat)"
Scale rows interval of matrix by specified factor\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fId\fP Rows scaling vector\&. 
.br
\fItrans\fP Transposition parameter (if transposed will scale columns)\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_zussc (const int nnz, const void * x, void * y, const int incy, const int * indx, const enum \fBblas_base_type\fP index_base)"
Sparse scatter: $Y |_x <- X$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&.\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "void blas_zussc_ (const int * nnz, const void * x, void * y, const int * incy, const int * indx, const enum \fBblas_base_type\fP * index_base, int * istat)"
Sparse scatter: $Y |_x <- X$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIy\fP Array for $Y$ vector\&. 
.br
\fIx\fP Array for $X$ vector\&. 
.br
\fInnz\fP Size of $X$ \fIand\fP \fI$Y$\fP vectors\&. 
.br
\fIindx\fP Is the array of indices at which sparse vector $X$ will be accessed\&. 
.br
\fIindex_base\fP Specifies the contents of \fCindx\fP, either \fBblas_one_base\fP or \fBblas_one_base\fP\&. 
.br
\fIincy\fP The distance between consecutive \fCy\fP array elements\&.\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&. 
.RE
.PP
\fBWarning:\fP
.RS 4
Sparse BLAS Level 1 has been implemented, although not with performance in mind\&.
.RE
.PP

.SS "int BLAS_zusset_element (\fBblas_sparse_matrix\fP A, const int i, const int j, void * v)"
Set a single (existing) matrix nonzero coefficient $A_{i,j}$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIi\fP Row index\&. 
.br
\fIj\fP Column index\&. 
.br
\fIv\fP Value pointer\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_zusset_element_ (\fBblas_sparse_matrix\fP * A, const int * i, const int * j, void * v, int * istat)"
Set a single (existing) matrix nonzero coefficient $A_{i,j}$\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIi\fP Row index\&. 
.br
\fIj\fP Column index\&. 
.br
\fIv\fP Value pointer\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_zusset_elements (\fBblas_sparse_matrix\fP A, const int * ia, const int * ja, const void * va, const int nnz)"
Set individual matrix nonzero coefficients values\&. The operation is pattern preserving, that is, nonzeroes must already exist\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIia\fP Row indices array\&. 
.br
\fIja\fP Column indices array\&. 
.br
\fIva\fP Values array\&. 
.br
\fInnz\fP Length of the \fCia\fP,ja,va arrays\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_zusset_elements_ (\fBblas_sparse_matrix\fP * A, const int * ia, const int * ja, const void * va, const int * nnz, int * istat)"
Set individual matrix nonzero coefficients values\&. The operation is pattern preserving, that is, nonzeroes must already exist\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.br
\fIia\fP Row indices array\&. 
.br
\fIja\fP Column indices array\&. 
.br
\fIva\fP Values array\&. 
.br
\fInnz\fP Length of the \fCia\fP,ja,va arrays\&. 
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_zussm (const enum \fBblas_order_type\fP order, const enum \fBblas_trans_type\fP transT, const int nrhs, const void * alpha, const \fBblas_sparse_matrix\fP T, void * b, const int ldb)"
Triangular solve, by a dense matrix (aka multi-vector)\&. Either of $B <- alpha T^{-1} B,$ $B <- alpha T^{-T} B,$ $B <- alpha T^{-H} B$, depending on the value of \fCtransT\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIorder\fP layour of the dense array\&. 
.br
\fItransT\fP Transposition operator for matrix \fIT\fP\&. 
.br
\fInrhs\fP Number of right hand side columns\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIT\fP A valid triangular matrix handle\&. 
.br
\fIb\fP Dense vector \fIb\fP\&. 
.br
\fIldb\fP Leading dimension of \fIb\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_zussm_ (const enum \fBblas_order_type\fP * order, const enum \fBblas_trans_type\fP * transT, const int * nrhs, const void * alpha, const \fBblas_sparse_matrix\fP * T, void * b, const int * ldb, int * istat)"
Triangular solve, by a dense matrix (aka multi-vector)\&. Either of $B <- alpha T^{-1} B,$ $B <- alpha T^{-T} B,$ $B <- alpha T^{-H} B$, depending on the value of \fCtransT\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIorder\fP layour of the dense array\&. 
.br
\fItransT\fP Transposition operator for matrix \fIT\fP\&. 
.br
\fInrhs\fP Number of right hand side columns\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIT\fP A valid triangular matrix handle\&. 
.br
\fIb\fP Dense vector \fIb\fP\&. 
.br
\fIldb\fP Leading dimension of \fIb\fP\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "int BLAS_zussv (enum \fBblas_trans_type\fP transT, const void * alpha, const \fBblas_sparse_matrix\fP T, void * x, const int incx)"
Triangular solve, by a dense vector\&. Either of $X <- alpha T^{-1}X,$ $X <- alpha T^{-T}X,$ $X <- alpha T^{-H}X$, depending on the value of \fCtransT\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fItransT\fP Transposition operator for matrix \fIT\fP\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIT\fP A valid triangular matrix handle\&. 
.br
\fIx\fP Dense vector \fIx\fP\&. 
.br
\fIincx\fP Stride of \fIx\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
On success, 0 is returned; on error, -1\&.
.RE
.PP

.SS "void blas_zussv_ (enum \fBblas_trans_type\fP * transT, const void * alpha, const \fBblas_sparse_matrix\fP * T, void * x, const int * incx, int * istat)"
Triangular solve, by a dense vector\&. Either of $X <- alpha T^{-1}X,$ $X <- alpha T^{-T}X,$ $X <- alpha T^{-H}X$, depending on the value of \fCtransT\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fItransT\fP Transposition operator for matrix \fIT\fP\&. 
.br
\fIalpha\fP Value for $ alpha $\&. 
.br
\fIT\fP A valid triangular matrix handle\&. 
.br
\fIx\fP Dense vector \fIx\fP\&. 
.br
\fIincx\fP Stride of \fIx\fP\&.
.br
\fIistat\fP If non \fCNULL\fP, \fC*istat\fP will be set to the return code, either 0 (success) or -1 (failure)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
This is a subroutine for Fortran, so it does not return any value\&.
.RE
.PP

.SS "\fBblas_sparse_matrix\fP rsb_blas_file_mtx_load (const \fBrsb_char_t\fP * filename, \fBrsb_type_t\fP typecode)"
Load Matrix Market matrix file of specified type to a matrix, and return Sparse BLAS handler\&.
.PP
\fBParameters:\fP
.RS 4
\fIfilename\fP The specified matrix file name (cannot be \fCNULL\fP)\&. 
.br
\fItypecode\fP A valid type code for the desired output matrix (see \fBmatrix_type_symbols_section\fP)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
On success, a valid matrix handle will be returned\&. On error, \fBblas_invalid_handle\fP will be returned\&.
.RE
.PP

.br
 
.SS "struct rsb_mtx_t* rsb_blas_get_mtx (\fBblas_sparse_matrix\fP A)"
Given a valid Sparse BLAS handle, returns a pointer to the inner rsb_mtx_t structure\&. Then, this can be used for many of the \fBrsb\&.h\fP functions\&. This is an experimental function, so we recommend to use it with functions not modifying the matrix (ones that take \fCconst\fP \fCstruct\fP \fCrsb_mtx_t*mtxAp\fP)\&. You can use this function from either Fortran or C\&.
.PP
\fBParameters:\fP
.RS 4
\fIA\fP A valid matrix handle\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
On success, a valid pointer to the inner matrix structure (\fCstruct\fP \fCrsb_mtx_t*\fP); on error, \fCNULL\fP\&.
.RE
.PP

.br
 An example using Fortran: 
.PP
.nf
\&.\&.\&.  
USE blas_sparse 
USE rsb 
IMPLICIT NONE 
TYPE(C_PTR),TARGET :: mtxAp = C_NULL_PTR ! matrix pointer 
INTEGER :: A ! blas_sparse_matrix handle 
INTEGER, TARGET :: istat = 0 
\&.\&.\&. ! begin, populate and finalize A, e\&.g\&. using BLAS_duscr_begin, BLAS_duscr_insert_entries, BLAS_uscr_end
! get pointer to rsb structure: 
mtxAp = rsb_blas_get_mtx(A) 
! Now one can use it with any rsb\&.h/rsb\&.F90 function, e\&.g\&.: 
istat = rsb_file_mtx_save(mtxAp, C_NULL_PTR) ! write to stdout 

.fi
.PP
 
.PP
\fBSee also:\fP
.RS 4
\fBrsb_mtx_get_coo\fP, \fBrsb_mtx_get_csr\fP, \fBrsb_mtx_get_rows_sparse\fP, \fBrsb_mtx_get_coo_block\fP, \fBrsb_mtx_get_prec\fP, \fBrsb_mtx_get_nrm\fP, \fBrsb_mtx_get_vec\fP, \fBrsb_file_mtx_get_dims\fP, \fBrsb_mtx_get_vals\fP, 
.PP
\fBrsb_mtx_upd_vals\fP, \fBrsb_mtx_set_vals\fP, 
.PP
\fBrsb_spmsp_to_dense\fP, \fBrsb_sppsp\fP, \fBrsb_spmsp\fP, \fBrsb_mtx_add_to_dense\fP, 
.PP
\fBrsb_mtx_rndr\fP, \fBrsb_file_mtx_rndr\fP, 
.PP
\fBrsb_mtx_get_info\fP, \fBrsb_mtx_get_info_str\fP, \fBrsb_file_mtx_save\fP, \fBrsb_file_vec_load\fP, \fBrsb_file_mtx_load\fP\&.
.RE
.PP
\fBNote:\fP
.RS 4
This function is an extension implemented by \fClibrsb\fP and thus it is not part of the standard\&. Do not rely on it, as it may change! Please contact the library maintainers if you need its functionality\&.
.RE
.PP

.SH "Author"
.PP 
librsb was written by Michele Martone; this documentation has been generated by Doxygen.
.SH "SEE ALSO"
.B rsb-examples
.B rsb.h
.B rsb.hpp
.B rsb-spblas.h
