.TH "RsbMatrix< NT >" 3 "Thu Apr 28 2022" "Version 1.3.0.1" "librsb" \" -*- nroff -*-
.ad l
.nh
.SH NAME
RsbMatrix \- Represent a sparse matrix in RSB format by means of \fClibrsb\fP\&.  

.SH SYNOPSIS
.br
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBRsbSym\fP { \fBIsGen\fP = RSB_FLAG_NOFLAGS, \fBIsHer\fP = RSB_FLAG_HERMITIAN, \fBIsSym\fP = RSB_FLAG_SYMMETRIC, \fBIsTri\fP = RSB_FLAG_TRIANGULAR }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBRsbMatrix\fP (\fBrsb_coo_idx_t\fP nrA, \fBrsb_coo_idx_t\fP ncA, const \fBRsbSym\fP sym=\fBIsGen\fP)"
.br
.ti -1c
.RI "\fBRsbMatrix\fP (\fBrsb_coo_idx_t\fP nrA, const \fBrsb_coo_idx_t\fP *RP, const \fBrsb_coo_idx_t\fP *JA, const NT *VA, const \fBRsbSym\fP sym=\fBIsGen\fP)"
.br
.ti -1c
.RI "\fBRsbMatrix\fP (const \fBrsb_coo_idx_t\fP *IA, const \fBrsb_coo_idx_t\fP *JA, const NT *VA, \fBrsb_nnz_idx_t\fP nnzA, const \fBrsb_flags_t\fP flagsA=\fBRSB_FLAG_NOFLAGS\fP)"
.br
.ti -1c
.RI "\fBRsbMatrix\fP (const \fBrsb_char_t\fP *filename, const \fBRsbSym\fP sym=\fBIsGen\fP)"
.br
.ti -1c
.RI "\fBRsbMatrix\fP (const \fBRsbMatrix\fP &A_Rsb, bool do_trans=false, \fBrsb_flags_t\fP flagsA=\fBRSB_FLAG_NOFLAGS\fP)"
.br
.ti -1c
.RI "\fBRsbMatrix\fP (\fBRsbMatrix\fP &&other)"
.br
.ti -1c
.RI "\fB~RsbMatrix\fP (void)"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP \fBRSBP_DEPRECATED\fP Err_t \fB_add\fP (\fBrsb_coo_idx_t\fP i, \fBrsb_coo_idx_t\fP j, NT val)"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP Err_t \fBclose\fP (void)"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP \fBRSBP_DEPRECATED\fP Err_t \fB_close\fP (void)"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP \fBRSBP_DEPRECATED\fP Err_t \fBspmv\fP (\fBrsb_trans_t\fP transA, const NT *alphap, const NT *Xp, \fBrsb_coo_idx_t\fP incX, const NT *betap, NT *Yp, \fBrsb_coo_idx_t\fP incY) const"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP Err_t \fBspmv\fP (\fBrsb_trans_t\fP transA, const NT alpha, const NT *Xp, \fBrsb_coo_idx_t\fP incX, const NT beta, NT *Yp, \fBrsb_coo_idx_t\fP incY) const"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP Err_t \fBspmv\fP (\fBrsb_trans_t\fP transA, const NT alpha, const NT *Xp, const NT beta, NT *Yp) const"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP Err_t \fBspmv\fP (NT *y, const NT *x, bool do_trans=false) const"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP \fBRSBP_DEPRECATED\fP Err_t \fBspmm\fP (\fBrsb_trans_t\fP transA, const NT *alphap, \fBrsb_coo_idx_t\fP nrhs, \fBrsb_flags_t\fP order, const NT *Bp, \fBrsb_nnz_idx_t\fP ldB, const NT *betap, NT *Cp, \fBrsb_nnz_idx_t\fP ldC) const"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP Err_t \fBspmm\fP (\fBrsb_trans_t\fP transA, const NT alpha, \fBrsb_coo_idx_t\fP nrhs, \fBrsb_flags_t\fP order, const NT *Bp, \fBrsb_nnz_idx_t\fP ldB, const NT beta, NT *Cp, \fBrsb_nnz_idx_t\fP ldC) const"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP Err_t \fBspmm\fP (\fBrsb_trans_t\fP transA, const NT alpha, \fBrsb_coo_idx_t\fP nrhs, \fBrsb_flags_t\fP order, const NT *Bp, const NT beta, NT *Cp) const"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP \fBRSBP_DEPRECATED\fP Err_t \fBspsm\fP (\fBrsb_trans_t\fP transT, const NT *alphap, \fBrsb_coo_idx_t\fP nrhs, \fBrsb_flags_t\fP order, const NT *betap, const NT *Bp, \fBrsb_nnz_idx_t\fP ldB, NT *Cp, \fBrsb_nnz_idx_t\fP ldC) const"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP Err_t \fBspsm\fP (\fBrsb_trans_t\fP transT, const NT alpha, \fBrsb_coo_idx_t\fP nrhs, \fBrsb_flags_t\fP order, const NT beta, const NT *Bp, \fBrsb_nnz_idx_t\fP ldB, NT *Cp, \fBrsb_nnz_idx_t\fP ldC) const"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP Err_t \fBspsm\fP (\fBrsb_trans_t\fP transT, const NT alpha, \fBrsb_coo_idx_t\fP nrhs, const NT *Bp, NT *Cp) const"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP Err_t \fBspsm\fP (NT *y, const NT *x, \fBrsb_coo_idx_t\fP nrhs, bool do_trans=false) const"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP Err_t \fBspsm\fP (NT *y, \fBrsb_coo_idx_t\fP nrhs, bool do_trans=false) const"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP \fBRSBP_DEPRECATED\fP Err_t \fBspsv\fP (\fBrsb_trans_t\fP transT, const NT *alphap, const NT *Xp, \fBrsb_coo_idx_t\fP incX, NT *Yp, \fBrsb_coo_idx_t\fP incY) const"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP Err_t \fBspsv\fP (\fBrsb_trans_t\fP transT, const NT alpha, const NT *Xp, NT *Yp) const"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP Err_t \fBspsv\fP (NT *y, const NT *x, bool do_trans=false) const"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP Err_t \fBspsv\fP (NT *y, bool do_trans=false) const"
.br
.ti -1c
.RI "size_t \fBget_info_size_t\fP (enum \fBrsb_mif_t\fP mif) const"
.br
.ti -1c
.RI "\fBrsb_flags_t\fP \fBget_info_rsb_flags_t\fP (enum \fBrsb_mif_t\fP mif) const"
.br
.ti -1c
.RI "\fBrsb_blk_idx_t\fP \fBget_info_blk_t\fP (enum \fBrsb_mif_t\fP mif) const"
.br
.ti -1c
.RI "\fBrsb_nnz_idx_t\fP \fBget_info_nnz_t\fP (enum \fBrsb_mif_t\fP mif) const"
.br
.ti -1c
.RI "\fBrsb_flags_t\fP \fBget_flags_t\fP (enum \fBrsb_mif_t\fP mif) const"
.br
.ti -1c
.RI "\fBrsb_type_t\fP \fBget_type_t\fP (enum \fBrsb_mif_t\fP mif) const"
.br
.ti -1c
.RI "\fBrsb_coo_idx_t\fP \fBget_info_coo_t\fP (enum \fBrsb_mif_t\fP mif) const"
.br
.ti -1c
.RI "size_t \fB_get_index_storage_bytes\fP (void) const"
.br
.ti -1c
.RI "size_t \fB_get_storage_bytes\fP (void) const"
.br
.ti -1c
.RI "\fBrsb_nnz_idx_t\fP \fBnnz\fP (void) const"
.br
.ti -1c
.RI "\fBrsb_blk_idx_t\fP \fBblocks\fP (void) const"
.br
.ti -1c
.RI "\fBrsb_coo_idx_t\fP \fBrows\fP (void) const"
.br
.ti -1c
.RI "\fBrsb_coo_idx_t\fP \fBcols\fP (void) const"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP Err_t \fBget_vals\fP (NT *VA, const \fBrsb_coo_idx_t\fP *IA, const \fBrsb_coo_idx_t\fP *JA, \fBrsb_nnz_idx_t\fP \fBnnz\fP, \fBrsb_flags_t\fP flags) const"
.br
.ti -1c
.RI "NT \fBget_val\fP (const \fBrsb_coo_idx_t\fP i, const \fBrsb_coo_idx_t\fP j, \fBrsb_flags_t\fP flags=\fBRSB_FLAG_NOFLAGS\fP) const"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP Err_t \fBset_val\fP (const NT val, const \fBrsb_coo_idx_t\fP i, const \fBrsb_coo_idx_t\fP j, \fBrsb_flags_t\fP flags=\fBRSB_FLAG_NOFLAGS\fP)"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP Err_t \fBset_vals\fP (const NT *VA, const \fBrsb_coo_idx_t\fP *IA, const \fBrsb_coo_idx_t\fP *JA, \fBrsb_nnz_idx_t\fP \fBnnz\fP, \fBrsb_flags_t\fP flags)"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP Err_t \fBget_vec\fP (NT *Dp, enum \fBrsb_extff_t\fP flags) const"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP \fBRSBP_DEPRECATED\fP Err_t \fBget_coo\fP (\fBrsb_trans_t\fP transA, NT *VA, \fBrsb_coo_idx_t\fP *IA, \fBrsb_coo_idx_t\fP *JA, \fBrsb_flags_t\fP flags) const"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP \fBRSBP_DEPRECATED\fP Err_t \fBget_csr\fP (\fBrsb_trans_t\fP transA, NT *VA, \fBrsb_coo_idx_t\fP *RP, \fBrsb_coo_idx_t\fP *JA, \fBrsb_flags_t\fP flags) const"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP \fBRSBP_DEPRECATED\fP Err_t \fBget_rows_sparse\fP (\fBrsb_trans_t\fP transA, const NT *alphap, NT *VA, \fBrsb_coo_idx_t\fP *IA, \fBrsb_coo_idx_t\fP *JA, \fBrsb_coo_idx_t\fP frA, \fBrsb_coo_idx_t\fP lrA, \fBrsb_nnz_idx_t\fP *rnzp, \fBrsb_flags_t\fP flags) const"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP Err_t \fBupd_vals\fP (enum \fBrsb_elopf_t\fP elop_flags, const NT &omega)"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP Err_t \fBupd_vals\fP (enum \fBrsb_elopf_t\fP elop_flags, const NT *omegap)"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP Err_t \fBget_nrm\fP (NT *Np, enum \fBrsb_extff_t\fP flags) const"
.br
.ti -1c
.RI "\fBrsb_type_t\fP \fBrsbtype\fP (void) const"
.br
.ti -1c
.RI "\fBrsb_flags_t\fP \fBrsbflags\fP (void) const"
.br
.ti -1c
.RI "rsb_string_t \fBget_info_str\fP (const char *key) const"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP Err_t \fBget_info\fP (enum \fBrsb_mif_t\fP miflags, void *minfop) const"
.br
.ti -1c
.RI "rsb_string_t \fB_info\fP (void) const"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP \fBRSBP_DEPRECATED\fP Err_t \fBtune_spsm_threads\fP (\fBrsb_real_t\fP *sfp=RSBP_NULL, \fBrsb_int_t\fP *tnp=RSBP_NULL, \fBrsb_int_t\fP maxr=0, \fBrsb_time_t\fP maxt=0, \fBrsb_trans_t\fP transA=\fBRSB_TRANSPOSITION_N\fP, const NT *alphap=RSBP_NULL, \fBrsb_coo_idx_t\fP nrhs=1, \fBrsb_flags_t\fP order=\fBRSB_FLAG_WANT_COLUMN_MAJOR_ORDER\fP, const NT *Bp=RSBP_NULL, \fBrsb_nnz_idx_t\fP ldB=0, const NT *betap=RSBP_NULL, NT *Cp=RSBP_NULL, \fBrsb_nnz_idx_t\fP ldC=0) const"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP \fBRSBP_DEPRECATED\fP Err_t \fBtune_spmm_threads\fP (\fBrsb_real_t\fP *sfp=RSBP_NULL, \fBrsb_int_t\fP *tnp=RSBP_NULL, \fBrsb_int_t\fP maxr=0, \fBrsb_time_t\fP maxt=0, \fBrsb_trans_t\fP transA=\fBRSB_TRANSPOSITION_N\fP, const NT *alphap=RSBP_NULL, \fBrsb_coo_idx_t\fP nrhs=1, \fBrsb_flags_t\fP order=\fBRSB_FLAG_WANT_COLUMN_MAJOR_ORDER\fP, const NT *Bp=RSBP_NULL, \fBrsb_nnz_idx_t\fP ldB=0, const NT *betap=RSBP_NULL, NT *Cp=RSBP_NULL, \fBrsb_nnz_idx_t\fP ldC=0) const"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP \fBRSBP_DEPRECATED\fP Err_t \fBtune_spmm\fP (\fBrsb_real_t\fP *sfp, \fBrsb_int_t\fP *tnp, \fBrsb_int_t\fP maxr, \fBrsb_time_t\fP maxt, \fBrsb_trans_t\fP transA, const NT *alphap, \fBrsb_coo_idx_t\fP nrhs, \fBrsb_flags_t\fP order, const NT *Bp, \fBrsb_nnz_idx_t\fP ldB, const NT *betap, NT *Cp, \fBrsb_nnz_idx_t\fP ldC)"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP \fBRSBP_DEPRECATED\fP Err_t \fBtune_spmm\fP (\fBrsb_real_t\fP *sfp, \fBrsb_int_t\fP *tnp, \fBrsb_int_t\fP maxr, \fBrsb_time_t\fP maxt, \fBrsb_trans_t\fP transA, const NT alpha, \fBrsb_coo_idx_t\fP nrhs, \fBrsb_flags_t\fP order, const NT *Bp, \fBrsb_nnz_idx_t\fP ldB, const NT beta, NT *Cp, \fBrsb_nnz_idx_t\fP ldC)"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP Err_t \fBtune_spmm\fP (\fBrsb_real_t\fP &sf, \fBrsb_trans_t\fP transA, const NT alpha, \fBrsb_coo_idx_t\fP nrhs, \fBrsb_flags_t\fP order, const NT *Bp, const NT beta, NT *Cp)"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP \fBRSBP_DEPRECATED\fP Err_t \fBtune_spsm\fP (\fBrsb_real_t\fP *sfp, \fBrsb_int_t\fP *tnp, \fBrsb_int_t\fP maxr, \fBrsb_time_t\fP maxt, \fBrsb_trans_t\fP transA, const NT *alphap, \fBrsb_coo_idx_t\fP nrhs, \fBrsb_flags_t\fP order, const NT *Bp, \fBrsb_nnz_idx_t\fP ldB, const NT *betap, NT *Cp, \fBrsb_nnz_idx_t\fP ldC)"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP Err_t \fBfile_save\fP (const \fBrsb_char_t\fP *filename=RSBP_NULL) const"
.br
.ti -1c
.RI "\fBRsbMatrix\fP & \fBoperator=\fP (const \fBRsbMatrix\fP &A_Rsb)"
.br
.ti -1c
.RI "bool \fB_is_complex\fP (void) const"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBRsbMatrix\fP &B_Rsb) const"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBRsbMatrix\fP &B_Rsb) const"
.br
.ti -1c
.RI "NT \fBnormOne\fP (void) const"
.br
.ti -1c
.RI "NT \fBnormInf\fP (void) const"
.br
.ti -1c
.RI "\fBRSBP_RVT\fP Err_t \fBrndr\fP (const \fBrsb_char_t\fP *filename=RSBP_NULL, \fBrsb_coo_idx_t\fP pmWidth=512, \fBrsb_coo_idx_t\fP pmHeight=512, \fBrsb_marf_t\fP rflags=\fBRSB_MARF_EPS\fP) const"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<RSBP_Scalar_t NT>
.br
class RsbMatrix< NT >"
Represent a sparse matrix in RSB format by means of \fClibrsb\fP\&. 

Manage construction, destruction, and std::move of numerical matrices\&. 
.br
Most of the member functions here translate directly to a single function call to \fClibrsb\fP (\fC\fBrsb\&.h\fP\fP), and pass the parameters as they are, so the error checking is done by \fClibrsb\fP\&. 
.br
While most of \fClibrsb\fP \fCC\fP functions use \fCvoid*\fP pointers instead of numerical data, \fC\fBRsbMatrix\fP\fP is templated by a type parameter\&. This introduces type safety at compile time\&.
.PP
Users of member functions can choose among several overloads\&. So in additional to the more direct overloads passing e\&.g\&. $ alpha $ and $ beta $ by reference, here a user can pass them by value\&.
.PP
\fBParameters:\fP
.RS 4
\fINT\fP the numerical type, at least for the four canonical ones (\fCfloat\fP, \fCdouble\fP, \fCstd::complex<float>\fP, \fCstd::complex<double>\fP); see \fBmatrix_supported_numerical_types_section\fP and \fBrsb_type_t\fP for more\&.
.RE
.PP
\fBNote:\fP
.RS 4
Default error propagation is by exception throw for all constructors and most member functions\&. 
.br
Functions declared to return Err_t can be specialized in rsb_err_t so not to throw exceptions, but to return an error code instead\&. 
.br
Exceptions thrown by member functions (not constructors) can be deactivated at build time by defining \fBRSBP_NOTHROW\fP before including \fC<\fBrsb\&.hpp\fP>\fP\&.
.PP
One may turn on return error value as default at build time by defining \fBRSBP_WANT_REV\fP=1 \&.
.RE
.PP
\fBWarning:\fP
.RS 4
The error model is work in progress and subject to change\&.
.RE
.PP
\fBTodo\fP
.RS 4
While the \fC\fBrsb\&.h\fP\fP interface is stable, the \fC\fBrsb\&.hpp\fP\fP interface is neither stable, nor complete: early users' feedback is very welcome\&. 
.br
Shall all $ alpha $ and $ beta $ be passed by values only? This is natural and fits C++\&. But \fBrsb_tune_spmm()\fP / \fBrsb_tune_spsm()\fP have more parameters with a nullptr-like `default' value: how to deal with them in \fBRsbMatrix::tune_spmm()\fP / \fBRsbMatrix::tune_spsm()\fP without introducing too many special cases ? 
.br
Similarly for the consistency of \fBRsbMatrix::get_flags_t()\fP, \fBRsbMatrix::get_type_t()\fP, \fBRsbMatrix::get_info_coo_t()\fP, and similar: shall they throw an exception if given a flag not matching the return type ? 
.br
Or maybe keeping only \fBRsbMatrix::get_info()\fP, with per-type reference overloads ? 
.br
Furthermore: if working under C++20, shall \fB\fBRsbLib\fP\fP avoid pointer-based interfaces completely (using \fCstd::span\fP only)? 
.RE
.PP

.SH "Member Enumeration Documentation"
.PP 
.SS "template<RSBP_Scalar_t NT> enum \fBRsbMatrix::RsbSym\fP"
Matrix structure: either general, symmetric, hermitian, or triangular (also see \fBrsb_flags_t\fP)\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIIsGen \fP\fP
General matrix, no triangle structure or symmetry assumed\&. 
.TP
\fB\fIIsHer \fP\fP
Hermitian ( $ A == A^H $)\&. Please pass only lower/upper triangle\&. 
.TP
\fB\fIIsSym \fP\fP
Symmetric ( $ A == A^T $)\&. Please pass only lower/upper triangle\&. 
.TP
\fB\fIIsTri \fP\fP
Triangular (required for \fBspsv\fP/\fBspsm\fP)\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<RSBP_Scalar_t NT> \fBRsbMatrix\fP< NT >::\fBRsbMatrix\fP (\fBrsb_coo_idx_t\fP nrA, \fBrsb_coo_idx_t\fP ncA, const \fBRsbSym\fP sym = \fC\fBIsGen\fP\fP)\fC [inline]\fP"
Begin assembling a sparse matrix of given dimensions and type\&. 
.br
Then you can use \fBset_val()\fP or \fBset_vals()\fP repeatedly to populate the matrix\&. 
.br
After populating the matrix, use \fBclose()\fP to terminate its assembly\&. 
.br
 Example snip from \fBexamples/assemble\&.cpp\fP: 
.PP
.nf
  const rsb_coo_idx_t nrA { 4 }, ncA { 4 };
  RsbMatrix<double> mtx(nrA,ncA); // begin matrix assembly

  // insert elements of a tridiagonal matrix, one by one
  for (auto i = 0; i < nrA; ++i )
    for (auto j = i-1; j <= i+1; ++j )
      if ( i >= 0 && i < nrA )
        if ( j >= 0 && j < ncA )
          mtx\&.set_val((i+1)*100+(j+1),i,j); // add entry

  mtx\&.close(); // finish matrix assembly
  assert(mtx\&.nnz() == 3 * nrA - 2);

.fi
.PP
 
.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_mtx_alloc_from_coo_begin()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRsbMatrix\fP< NT >::\fBRsbMatrix\fP (\fBrsb_coo_idx_t\fP nrA, const \fBrsb_coo_idx_t\fP * RP, const \fBrsb_coo_idx_t\fP * JA, const NT * VA, const \fBRsbSym\fP sym = \fC\fBIsGen\fP\fP)\fC [inline]\fP"
Assemble a sparse matrix given CSR input\&. 
.br
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_mtx_alloc_from_csr_const()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRsbMatrix\fP< NT >::\fBRsbMatrix\fP (const \fBrsb_coo_idx_t\fP * IA, const \fBrsb_coo_idx_t\fP * JA, const NT * VA, \fBrsb_nnz_idx_t\fP nnzA, const \fBrsb_flags_t\fP flagsA = \fC\fBRSB_FLAG_NOFLAGS\fP\fP)\fC [inline]\fP"
Assemble a sparse matrix given COO input\&. 
.br
Example snip from \fBexamples/misc\&.cpp\fP: 
.PP
.nf
    const rsb_nnz_idx_t nnzA { 7 };
    const rsb_coo_idx_t nrA { 6 }, ncA { 6 }, nrhs { 1 };
    const std::vector<rsb_coo_idx_t> IA {0,1,2,3,4,5,1}, JA {0,1,2,3,4,5,0};
    const std::vector<double> VA {1,1,1,1,1,1,2}, X(ncA,1);
    RsbMatrix<double> mtx(IA\&.data(),JA\&.data(),VA\&.data(),nnzA);

.fi
.PP

.br
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_mtx_alloc_from_coo_const()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRsbMatrix\fP< NT >::\fBRsbMatrix\fP (const \fBrsb_char_t\fP * filename, const \fBRsbSym\fP sym = \fC\fBIsGen\fP\fP)\fC [inline]\fP"
Assemble a sparse matrix given filename input\&. 
.br
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_file_mtx_load()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRsbMatrix\fP< NT >::\fBRsbMatrix\fP (const \fBRsbMatrix\fP< NT > & A_Rsb, bool do_trans = \fCfalse\fP, \fBrsb_flags_t\fP flagsA = \fC\fBRSB_FLAG_NOFLAGS\fP\fP)\fC [inline]\fP"
Copy a sparse matrix given example input\&. 
.br
Can either clone it, or transpose it or change flags (structure) in the process\&.
.SS "template<RSBP_Scalar_t NT> \fBRsbMatrix\fP< NT >::\fBRsbMatrix\fP (\fBRsbMatrix\fP< NT > && other)\fC [inline]\fP"
Move constructor\&. 
.br
The moved matrix object will be invalid afterwards\&. 
.br
Example snip from \fBexamples/misc\&.cpp\fP: 
.PP
.nf
  assert( mtx1\&.nnz() == nnzA );
  RsbMatrix<double> mtx3 { std::move(mtx1) };
  assert( mtx3\&.nnz() == nnzA );

.fi
.PP
 
.SS "template<RSBP_Scalar_t NT> \fBRsbMatrix\fP< NT >::~\fBRsbMatrix\fP (void)\fC [inline]\fP"
Destructor\&. 
.br
Frees matrix object memory\&. 
.br
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_mtx_free()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP \fBRSBP_DEPRECATED\fP Err_t \fBRsbMatrix\fP< NT >::_add (\fBrsb_coo_idx_t\fP i, \fBrsb_coo_idx_t\fP j, NT val)\fC [inline]\fP"

.PP
\fBDeprecated\fP
.RS 4
Use \fBset_val()\fP and \fBset_vals()\fP instead\&. 
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP \fBRSBP_DEPRECATED\fP Err_t \fBRsbMatrix\fP< NT >::_close (void)\fC [inline]\fP"

.PP
\fBDeprecated\fP
.RS 4
Use \fBclose()\fP instead\&. 
.RE
.PP

.SS "template<RSBP_Scalar_t NT> size_t \fBRsbMatrix\fP< NT >::_get_index_storage_bytes (void) const\fC [inline]\fP"

.PP
\fBWarning:\fP
.RS 4
The name of this member function is expected to change\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> size_t \fBRsbMatrix\fP< NT >::_get_storage_bytes (void) const\fC [inline]\fP"

.PP
\fBWarning:\fP
.RS 4
The name of this member function is expected to change\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> rsb_string_t \fBRsbMatrix\fP< NT >::_info (void) const\fC [inline]\fP"

.PP
\fBWarning:\fP
.RS 4
The name of this member function is expected to change\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> bool \fBRsbMatrix\fP< NT >::_is_complex (void) const\fC [inline]\fP"

.PP
\fBWarning:\fP
.RS 4
The name of this member function is expected to change\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBrsb_blk_idx_t\fP \fBRsbMatrix\fP< NT >::blocks (void) const\fC [inline]\fP"

.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP Err_t \fBRsbMatrix\fP< NT >::close (void)\fC [inline]\fP"
Terminate assembly of a previously started and populated matrix\&. 
.br
Shall be called once\&.
.PP
Example snip from \fBexamples/assemble\&.cpp\fP: 
.PP
.nf
  const rsb_coo_idx_t nrA { 4 }, ncA { 4 };
  RsbMatrix<double> mtx(nrA,ncA); // begin matrix assembly

  // insert elements of a tridiagonal matrix, one by one
  for (auto i = 0; i < nrA; ++i )
    for (auto j = i-1; j <= i+1; ++j )
      if ( i >= 0 && i < nrA )
        if ( j >= 0 && j < ncA )
          mtx\&.set_val((i+1)*100+(j+1),i,j); // add entry

  mtx\&.close(); // finish matrix assembly
  assert(mtx\&.nnz() == 3 * nrA - 2);

.fi
.PP
 
.PP
\fBSee also:\fP
.RS 4
\fBRsbMatrix::RsbMatrix\fP(\fBrsb_coo_idx_t\fP nrA, \fBrsb_coo_idx_t\fP ncA, const \fBRsbSym\fP sym = \fBIsGen\fP ); 
.RE
.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_mtx_alloc_from_coo_end()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBrsb_coo_idx_t\fP \fBRsbMatrix\fP< NT >::cols (void) const\fC [inline]\fP"
Example snip from \fBexamples/twonnz\&.cpp\fP: 
.PP
.nf
     std::cout << "# Matrix sized " << mtx\&.rows() << "x" << mtx\&.cols() << ", " << nnzA << " nnz  built in " << dt << " s and occupies " << mtxocc << " bytes " << std::endl;

.fi
.PP
 
.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP Err_t \fBRsbMatrix\fP< NT >::file_save (const \fBrsb_char_t\fP * filename = \fCRSBP_NULL\fP) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_file_mtx_save()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP
Example snip from \fBexamples/misc\&.cpp\fP: 
.PP
.nf
    mtx\&.file_save(); // print to stdout

.fi
.PP
 
.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP \fBRSBP_DEPRECATED\fP Err_t \fBRsbMatrix\fP< NT >::get_coo (\fBrsb_trans_t\fP transA, NT * VA, \fBrsb_coo_idx_t\fP * IA, \fBrsb_coo_idx_t\fP * JA, \fBrsb_flags_t\fP flags) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_mtx_get_coo()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP
\fBWarning:\fP
.RS 4
Only \fCtransA=RSB_TRANSPOSITION_N\fP currently supported\&. 
.RE
.PP
\fBDeprecated\fP
.RS 4
This function overload is deprecated: use the corresponding overload without the C-style pointers-to-scalar, or request one if non existing yet\&. 
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP \fBRSBP_DEPRECATED\fP Err_t \fBRsbMatrix\fP< NT >::get_csr (\fBrsb_trans_t\fP transA, NT * VA, \fBrsb_coo_idx_t\fP * RP, \fBrsb_coo_idx_t\fP * JA, \fBrsb_flags_t\fP flags) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_mtx_get_csr()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP
\fBWarning:\fP
.RS 4
Only \fCtransA=RSB_TRANSPOSITION_N\fP currently supported\&. 
.RE
.PP
\fBDeprecated\fP
.RS 4
This function overload is deprecated: use the corresponding overload without the C-style pointers-to-scalar, or request one if non existing yet\&. 
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBrsb_flags_t\fP \fBRsbMatrix\fP< NT >::get_flags_t (enum \fBrsb_mif_t\fP mif) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_mtx_get_info()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP Err_t \fBRsbMatrix\fP< NT >::get_info (enum \fBrsb_mif_t\fP miflags, void * minfop) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_mtx_get_info()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBrsb_blk_idx_t\fP \fBRsbMatrix\fP< NT >::get_info_blk_t (enum \fBrsb_mif_t\fP mif) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_mtx_get_info()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBrsb_coo_idx_t\fP \fBRsbMatrix\fP< NT >::get_info_coo_t (enum \fBrsb_mif_t\fP mif) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_mtx_get_info()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBrsb_nnz_idx_t\fP \fBRsbMatrix\fP< NT >::get_info_nnz_t (enum \fBrsb_mif_t\fP mif) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_mtx_get_info()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBrsb_flags_t\fP \fBRsbMatrix\fP< NT >::get_info_rsb_flags_t (enum \fBrsb_mif_t\fP mif) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_mtx_get_info()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> size_t \fBRsbMatrix\fP< NT >::get_info_size_t (enum \fBrsb_mif_t\fP mif) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_mtx_get_info()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> rsb_string_t \fBRsbMatrix\fP< NT >::get_info_str (const char * key) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_mtx_get_info_str()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP Err_t \fBRsbMatrix\fP< NT >::get_nrm (NT * Np, enum \fBrsb_extff_t\fP flags) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_mtx_get_nrm()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP \fBRSBP_DEPRECATED\fP Err_t \fBRsbMatrix\fP< NT >::get_rows_sparse (\fBrsb_trans_t\fP transA, const NT * alphap, NT * VA, \fBrsb_coo_idx_t\fP * IA, \fBrsb_coo_idx_t\fP * JA, \fBrsb_coo_idx_t\fP frA, \fBrsb_coo_idx_t\fP lrA, \fBrsb_nnz_idx_t\fP * rnzp, \fBrsb_flags_t\fP flags) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_mtx_get_rows_sparse()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP
\fBDeprecated\fP
.RS 4
This function overload is deprecated: use the corresponding overload without the C-style pointers-to-scalar, or request one if non existing yet\&. 
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBrsb_type_t\fP \fBRsbMatrix\fP< NT >::get_type_t (enum \fBrsb_mif_t\fP mif) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_mtx_get_info()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> NT \fBRsbMatrix\fP< NT >::get_val (const \fBrsb_coo_idx_t\fP i, const \fBrsb_coo_idx_t\fP j, \fBrsb_flags_t\fP flags = \fC\fBRSB_FLAG_NOFLAGS\fP\fP) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_mtx_get_vals()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP Err_t \fBRsbMatrix\fP< NT >::get_vals (NT * VA, const \fBrsb_coo_idx_t\fP * IA, const \fBrsb_coo_idx_t\fP * JA, \fBrsb_nnz_idx_t\fP nnz, \fBrsb_flags_t\fP flags) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_mtx_get_vals()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP Err_t \fBRsbMatrix\fP< NT >::get_vec (NT * Dp, enum \fBrsb_extff_t\fP flags) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_mtx_get_vec()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBrsb_nnz_idx_t\fP \fBRsbMatrix\fP< NT >::nnz (void) const\fC [inline]\fP"

.SS "template<RSBP_Scalar_t NT> NT \fBRsbMatrix\fP< NT >::normInf (void) const\fC [inline]\fP"

.SS "template<RSBP_Scalar_t NT> NT \fBRsbMatrix\fP< NT >::normOne (void) const\fC [inline]\fP"

.SS "template<RSBP_Scalar_t NT> bool \fBRsbMatrix\fP< NT >::operator!= (const \fBRsbMatrix\fP< NT > & B_Rsb) const\fC [inline]\fP"
Example snip from \fBexamples/misc\&.cpp\fP: 
.PP
.nf
  assert(   mtx1 == mtx2  );
  assert( !(mtx1 != mtx2) );

.fi
.PP
 
.PP
\fBSee also:\fP
.RS 4
\fBRsbMatrix::operator==(const RsbMatrix & B_Rsb) const\fP;
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRsbMatrix\fP& \fBRsbMatrix\fP< NT >::operator= (const \fBRsbMatrix\fP< NT > & A_Rsb)\fC [inline]\fP"
A copy constructor\&. Will clone the input matrix contents\&.
.SS "template<RSBP_Scalar_t NT> bool \fBRsbMatrix\fP< NT >::operator== (const \fBRsbMatrix\fP< NT > & B_Rsb) const\fC [inline]\fP"
Deep comparison: compare if the two matrices have same dimensions, nonzeroes count, nonzeroes pattern and value\&. Meant for very sporadic use\&. Inefficient: it can involve matrices copying\&.
.PP
Example snip from \fBexamples/misc\&.cpp\fP: 
.PP
.nf
  assert(   mtx1 == mtx2  );
  assert( !(mtx1 != mtx2) );

.fi
.PP
 
.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP Err_t \fBRsbMatrix\fP< NT >::rndr (const \fBrsb_char_t\fP * filename = \fCRSBP_NULL\fP, \fBrsb_coo_idx_t\fP pmWidth = \fC512\fP, \fBrsb_coo_idx_t\fP pmHeight = \fC512\fP, \fBrsb_marf_t\fP rflags = \fC\fBRSB_MARF_EPS\fP\fP) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_mtx_rndr()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP
Example snip from \fBexamples/render\&.cpp\fP: 
.PP
.nf
            mtx\&.rndr(psfilename\&.c_str());

.fi
.PP
 
.SS "template<RSBP_Scalar_t NT> \fBrsb_coo_idx_t\fP \fBRsbMatrix\fP< NT >::rows (void) const\fC [inline]\fP"
Example snip from \fBexamples/twonnz\&.cpp\fP: 
.PP
.nf
     std::cout << "# Matrix sized " << mtx\&.rows() << "x" << mtx\&.cols() << ", " << nnzA << " nnz  built in " << dt << " s and occupies " << mtxocc << " bytes " << std::endl;

.fi
.PP
 
.SS "template<RSBP_Scalar_t NT> \fBrsb_flags_t\fP \fBRsbMatrix\fP< NT >::rsbflags (void) const\fC [inline]\fP"

.SS "template<RSBP_Scalar_t NT> \fBrsb_type_t\fP \fBRsbMatrix\fP< NT >::rsbtype (void) const\fC [inline]\fP"
Example snip from \fBexamples/twonnz\&.cpp\fP: 
.PP
.nf
                std::cout << "# type=" << mtx\&.rsbtype() << " nt=1," << rnt << " n=" << n << " nrhs=" << nrhs << " order=" << oc << " alpha=" << alpha << " beta=" << beta << " dt=" << dta[0] << "\&.\&." << dta[1] << " spmm-scalability=" << dta[0]/dta[1] << " nnz/s=" << nnzA/dta[0] << "\&.\&." << nnzA/dta[1] << " flops=" << flops_c/dta[0] << "\&.\&." << flops_c/dta[1] << " occ\&.=" << opocc << " " << std::endl;

.fi
.PP
 
.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP Err_t \fBRsbMatrix\fP< NT >::set_val (const NT val, const \fBrsb_coo_idx_t\fP i, const \fBrsb_coo_idx_t\fP j, \fBrsb_flags_t\fP flags = \fC\fBRSB_FLAG_NOFLAGS\fP\fP)\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_mtx_set_vals()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP
Example snip from \fBexamples/assemble\&.cpp\fP: 
.PP
.nf
  const rsb_coo_idx_t nrA { 4 }, ncA { 4 };
  RsbMatrix<double> mtx(nrA,ncA); // begin matrix assembly

  // insert elements of a tridiagonal matrix, one by one
  for (auto i = 0; i < nrA; ++i )
    for (auto j = i-1; j <= i+1; ++j )
      if ( i >= 0 && i < nrA )
        if ( j >= 0 && j < ncA )
          mtx\&.set_val((i+1)*100+(j+1),i,j); // add entry

  mtx\&.close(); // finish matrix assembly
  assert(mtx\&.nnz() == 3 * nrA - 2);

.fi
.PP
 
.PP
\fBSee also:\fP
.RS 4
\fBset_vals()\fP\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP Err_t \fBRsbMatrix\fP< NT >::set_vals (const NT * VA, const \fBrsb_coo_idx_t\fP * IA, const \fBrsb_coo_idx_t\fP * JA, \fBrsb_nnz_idx_t\fP nnz, \fBrsb_flags_t\fP flags)\fC [inline]\fP"
Add a single entry during the assembly of a matrix created empty\&. 
.br
Use \fBclose()\fP to terminate matrix assembly\&.
.PP
Example snip from \fBexamples/assemble\&.cpp\fP: 
.PP
.nf
  const rsb_coo_idx_t nrA { 4 }, ncA { 4 };
  RsbMatrix<double> mtx(nrA,ncA); // begin matrix assembly

  // insert elements of a tridiagonal matrix, one by one
  for (auto i = 0; i < nrA; ++i )
    for (auto j = i-1; j <= i+1; ++j )
      if ( i >= 0 && i < nrA )
        if ( j >= 0 && j < ncA )
          mtx\&.set_val((i+1)*100+(j+1),i,j); // add entry

  mtx\&.close(); // finish matrix assembly
  assert(mtx\&.nnz() == 3 * nrA - 2);

.fi
.PP
 
.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_mtx_set_vals()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP \fBRSBP_DEPRECATED\fP Err_t \fBRsbMatrix\fP< NT >::spmm (\fBrsb_trans_t\fP transA, const NT * alphap, \fBrsb_coo_idx_t\fP nrhs, \fBrsb_flags_t\fP order, const NT * Bp, \fBrsb_nnz_idx_t\fP ldB, const NT * betap, NT * Cp, \fBrsb_nnz_idx_t\fP ldC) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_spmm()\fP from \fC<\fBrsb\&.h\fP>\fP\&. 
.RE
.PP
\fBDeprecated\fP
.RS 4
This function overload is deprecated: use the corresponding overload without the C-style pointers-to-scalar, or request one if non existing yet\&. 
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP Err_t \fBRsbMatrix\fP< NT >::spmm (\fBrsb_trans_t\fP transA, const NT alpha, \fBrsb_coo_idx_t\fP nrhs, \fBrsb_flags_t\fP order, const NT * Bp, \fBrsb_nnz_idx_t\fP ldB, const NT beta, NT * Cp, \fBrsb_nnz_idx_t\fP ldC) const\fC [inline]\fP"
Example snip from \fBexamples/bench\&.cpp\fP: 
.PP
.nf
                      mtx\&.spmm(transA,&alpha,nrhs,order,B\&.data(),ldB,&beta,C\&.data(),ldC);

.fi
.PP
 
.PP
\fBNote:\fP
.RS 4
Indirectly based on C function \fBrsb_spmm()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP Err_t \fBRsbMatrix\fP< NT >::spmm (\fBrsb_trans_t\fP transA, const NT alpha, \fBrsb_coo_idx_t\fP nrhs, \fBrsb_flags_t\fP order, const NT * Bp, const NT beta, NT * Cp) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Indirectly based on C function \fBrsb_spmm()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP \fBRSBP_DEPRECATED\fP Err_t \fBRsbMatrix\fP< NT >::spmv (\fBrsb_trans_t\fP transA, const NT * alphap, const NT * Xp, \fBrsb_coo_idx_t\fP incX, const NT * betap, NT * Yp, \fBrsb_coo_idx_t\fP incY) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_spmv()\fP from \fC<\fBrsb\&.h\fP>\fP\&. 
.RE
.PP
\fBDeprecated\fP
.RS 4
This function overload is deprecated: use the corresponding overload without the C-style pointers-to-scalar, or request one if non existing yet\&. 
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP Err_t \fBRsbMatrix\fP< NT >::spmv (\fBrsb_trans_t\fP transA, const NT alpha, const NT * Xp, \fBrsb_coo_idx_t\fP incX, const NT beta, NT * Yp, \fBrsb_coo_idx_t\fP incY) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Indirectly based on C function \fBrsb_spmv()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP
Example snip from \fBexamples/span\&.cpp\fP: 
.PP
.nf
  mtx\&.tune_spmm(nullptr,&tn,0,0\&.0,RSB_TRANSPOSITION_N,alpha,nrhs,RSB_FLAG_WANT_COLUMN_MAJOR_ORDER,X,ncA,beta,Y,nrA);
  mtx\&.spmv(RSB_TRANSPOSITION_N, alpha, X, beta, Y);

.fi
.PP
 
.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP Err_t \fBRsbMatrix\fP< NT >::spmv (\fBrsb_trans_t\fP transA, const NT alpha, const NT * Xp, const NT beta, NT * Yp) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Indirectly based on C function \fBrsb_spmv()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP
Example snip from \fBexamples/span\&.cpp\fP: 
.PP
.nf
  mtx\&.tune_spmm(nullptr,&tn,0,0\&.0,RSB_TRANSPOSITION_N,alpha,nrhs,RSB_FLAG_WANT_COLUMN_MAJOR_ORDER,X,ncA,beta,Y,nrA);
  mtx\&.spmv(RSB_TRANSPOSITION_N, alpha, X, beta, Y);

.fi
.PP
 
.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP Err_t \fBRsbMatrix\fP< NT >::spmv (NT * y, const NT * x, bool do_trans = \fCfalse\fP) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Indirectly based on C function \fBrsb_spmv()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP
Example snip from \fBexamples/span\&.cpp\fP: 
.PP
.nf
  mtx\&.tune_spmm(nullptr,&tn,0,0\&.0,RSB_TRANSPOSITION_N,alpha,nrhs,RSB_FLAG_WANT_COLUMN_MAJOR_ORDER,X,ncA,beta,Y,nrA);
  mtx\&.spmv(RSB_TRANSPOSITION_N, alpha, X, beta, Y);

.fi
.PP
 
.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP \fBRSBP_DEPRECATED\fP Err_t \fBRsbMatrix\fP< NT >::spsm (\fBrsb_trans_t\fP transT, const NT * alphap, \fBrsb_coo_idx_t\fP nrhs, \fBrsb_flags_t\fP order, const NT * betap, const NT * Bp, \fBrsb_nnz_idx_t\fP ldB, NT * Cp, \fBrsb_nnz_idx_t\fP ldC) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_spsm()\fP from \fC<\fBrsb\&.h\fP>\fP\&. 
.RE
.PP
\fBDeprecated\fP
.RS 4
This function overload is deprecated: use the corresponding overload without the C-style pointers-to-scalar, or request one if non existing yet\&. 
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP Err_t \fBRsbMatrix\fP< NT >::spsm (\fBrsb_trans_t\fP transT, const NT alpha, \fBrsb_coo_idx_t\fP nrhs, \fBrsb_flags_t\fP order, const NT beta, const NT * Bp, \fBrsb_nnz_idx_t\fP ldB, NT * Cp, \fBrsb_nnz_idx_t\fP ldC) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Indirectly based on C function \fBrsb_spsm()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP Err_t \fBRsbMatrix\fP< NT >::spsm (\fBrsb_trans_t\fP transT, const NT alpha, \fBrsb_coo_idx_t\fP nrhs, const NT * Bp, NT * Cp) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Indirectly based on C function \fBrsb_spsm()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP Err_t \fBRsbMatrix\fP< NT >::spsm (NT * y, const NT * x, \fBrsb_coo_idx_t\fP nrhs, bool do_trans = \fCfalse\fP) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Indirectly based on C function \fBrsb_spsm()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP Err_t \fBRsbMatrix\fP< NT >::spsm (NT * y, \fBrsb_coo_idx_t\fP nrhs, bool do_trans = \fCfalse\fP) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Indirectly based on C function \fBrsb_spsm()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP \fBRSBP_DEPRECATED\fP Err_t \fBRsbMatrix\fP< NT >::spsv (\fBrsb_trans_t\fP transT, const NT * alphap, const NT * Xp, \fBrsb_coo_idx_t\fP incX, NT * Yp, \fBrsb_coo_idx_t\fP incY) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_spsv()\fP from \fC<\fBrsb\&.h\fP>\fP\&. 
.RE
.PP
\fBDeprecated\fP
.RS 4
This function overload is deprecated: use the corresponding overload without the C-style pointers-to-scalar, or request one if non existing yet\&. 
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP Err_t \fBRsbMatrix\fP< NT >::spsv (\fBrsb_trans_t\fP transT, const NT alpha, const NT * Xp, NT * Yp) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Indirectly based on C function \fBrsb_spsv()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP Err_t \fBRsbMatrix\fP< NT >::spsv (NT * y, const NT * x, bool do_trans = \fCfalse\fP) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Indirectly based on C function \fBrsb_spsv()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP Err_t \fBRsbMatrix\fP< NT >::spsv (NT * y, bool do_trans = \fCfalse\fP) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Indirectly based on C function \fBrsb_spsv()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP \fBRSBP_DEPRECATED\fP Err_t \fBRsbMatrix\fP< NT >::tune_spmm (\fBrsb_real_t\fP * sfp, \fBrsb_int_t\fP * tnp, \fBrsb_int_t\fP maxr, \fBrsb_time_t\fP maxt, \fBrsb_trans_t\fP transA, const NT * alphap, \fBrsb_coo_idx_t\fP nrhs, \fBrsb_flags_t\fP order, const NT * Bp, \fBrsb_nnz_idx_t\fP ldB, const NT * betap, NT * Cp, \fBrsb_nnz_idx_t\fP ldC)\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_tune_spmm()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP
Example snip from \fBexamples/autotune\&.cpp\fP: 
.PP
.nf
                  tt = -rsb_time();
                        mtx\&.tune_spmm(&sf,&tn,maxr,tmax,transA,&alpha,nrhs,order,B\&.data(),ldB,&beta,C\&.data(),ldC);
                        tt += rsb_time();

                        auto nnsmA {mtx\&.blocks()};
                        std::cout << "Tuning took " << tt << " s ( " << tt / dt << " ops ) and changed " << nsmA << " to " << nnsmA << " blocks" << std::endl;

                        mtx\&.spmm(transA,&alpha,nrhs,order,B\&.data(),ldB,&beta,C\&.data(),ldC); // caches warmup

.fi
.PP
 
.PP
\fBDeprecated\fP
.RS 4
This function overload is deprecated: use the corresponding overload without the C-style pointers-to-scalar, or request one if non existing yet\&. 
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP \fBRSBP_DEPRECATED\fP Err_t \fBRsbMatrix\fP< NT >::tune_spmm (\fBrsb_real_t\fP * sfp, \fBrsb_int_t\fP * tnp, \fBrsb_int_t\fP maxr, \fBrsb_time_t\fP maxt, \fBrsb_trans_t\fP transA, const NT alpha, \fBrsb_coo_idx_t\fP nrhs, \fBrsb_flags_t\fP order, const NT * Bp, \fBrsb_nnz_idx_t\fP ldB, const NT beta, NT * Cp, \fBrsb_nnz_idx_t\fP ldC)\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Indirectly based on C function \fBrsb_tune_spmm()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP
Example snip from \fBexamples/autotune\&.cpp\fP: 
.PP
.nf
                       tt = -rsb_time();
                        mtx\&.tune_spmm(&sf,&tn,maxr,tmax,transA,&alpha,nrhs,order,B\&.data(),ldB,&beta,C\&.data(),ldC);
                        tt += rsb_time();

                        auto nnsmA {mtx\&.blocks()};
                        std::cout << "Tuning took " << tt << " s ( " << tt / dt << " ops ) and changed " << nsmA << " to " << nnsmA << " blocks" << std::endl;

                        mtx\&.spmm(transA,&alpha,nrhs,order,B\&.data(),ldB,&beta,C\&.data(),ldC); // caches warmup

.fi
.PP
 
.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP Err_t \fBRsbMatrix\fP< NT >::tune_spmm (\fBrsb_real_t\fP & sf, \fBrsb_trans_t\fP transA, const NT alpha, \fBrsb_coo_idx_t\fP nrhs, \fBrsb_flags_t\fP order, const NT * Bp, const NT beta, NT * Cp)\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Indirectly based on C function \fBrsb_tune_spmm()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP
Example snip from \fBexamples/autotune\&.cpp\fP: 
.PP
.nf
                        tt = -rsb_time();
                        mtx\&.tune_spmm(&sf,&tn,maxr,tmax,transA,&alpha,nrhs,order,B\&.data(),ldB,&beta,C\&.data(),ldC);
                        tt += rsb_time();

                        auto nnsmA {mtx\&.blocks()};
                        std::cout << "Tuning took " << tt << " s ( " << tt / dt << " ops ) and changed " << nsmA << " to " << nnsmA << " blocks" << std::endl;

                        mtx\&.spmm(transA,&alpha,nrhs,order,B\&.data(),ldB,&beta,C\&.data(),ldC); // caches warmup

.fi
.PP
 
.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP \fBRSBP_DEPRECATED\fP Err_t \fBRsbMatrix\fP< NT >::tune_spmm_threads (\fBrsb_real_t\fP * sfp = \fCRSBP_NULL\fP, \fBrsb_int_t\fP * tnp = \fCRSBP_NULL\fP, \fBrsb_int_t\fP maxr = \fC0\fP, \fBrsb_time_t\fP maxt = \fC0\fP, \fBrsb_trans_t\fP transA = \fC\fBRSB_TRANSPOSITION_N\fP\fP, const NT * alphap = \fCRSBP_NULL\fP, \fBrsb_coo_idx_t\fP nrhs = \fC1\fP, \fBrsb_flags_t\fP order = \fC\fBRSB_FLAG_WANT_COLUMN_MAJOR_ORDER\fP\fP, const NT * Bp = \fCRSBP_NULL\fP, \fBrsb_nnz_idx_t\fP ldB = \fC0\fP, const NT * betap = \fCRSBP_NULL\fP, NT * Cp = \fCRSBP_NULL\fP, \fBrsb_nnz_idx_t\fP ldC = \fC0\fP) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_tune_spmm()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP
Example snip from \fBexamples/autotune\&.cpp\fP: 
.PP
.nf
                      tt = -rsb_time();
                        mtx\&.tune_spmm(&sf,&tn,maxr,tmax,transA,&alpha,nrhs,order,B\&.data(),ldB,&beta,C\&.data(),ldC);
                        tt += rsb_time();

                        auto nnsmA {mtx\&.blocks()};
                        std::cout << "Tuning took " << tt << " s ( " << tt / dt << " ops ) and changed " << nsmA << " to " << nnsmA << " blocks" << std::endl;

                        mtx\&.spmm(transA,&alpha,nrhs,order,B\&.data(),ldB,&beta,C\&.data(),ldC); // caches warmup

.fi
.PP
\fBDeprecated\fP
.RS 4
This function overload is deprecated: use the corresponding overload without the C-style pointers-to-scalar, or request one if non existing yet\&. 
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP \fBRSBP_DEPRECATED\fP Err_t \fBRsbMatrix\fP< NT >::tune_spsm (\fBrsb_real_t\fP * sfp, \fBrsb_int_t\fP * tnp, \fBrsb_int_t\fP maxr, \fBrsb_time_t\fP maxt, \fBrsb_trans_t\fP transA, const NT * alphap, \fBrsb_coo_idx_t\fP nrhs, \fBrsb_flags_t\fP order, const NT * Bp, \fBrsb_nnz_idx_t\fP ldB, const NT * betap, NT * Cp, \fBrsb_nnz_idx_t\fP ldC)\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_tune_spsm()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP
\fBDeprecated\fP
.RS 4
This function overload is deprecated: use the corresponding overload without the C-style pointers-to-scalar, or request one if non existing yet\&. 
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP \fBRSBP_DEPRECATED\fP Err_t \fBRsbMatrix\fP< NT >::tune_spsm_threads (\fBrsb_real_t\fP * sfp = \fCRSBP_NULL\fP, \fBrsb_int_t\fP * tnp = \fCRSBP_NULL\fP, \fBrsb_int_t\fP maxr = \fC0\fP, \fBrsb_time_t\fP maxt = \fC0\fP, \fBrsb_trans_t\fP transA = \fC\fBRSB_TRANSPOSITION_N\fP\fP, const NT * alphap = \fCRSBP_NULL\fP, \fBrsb_coo_idx_t\fP nrhs = \fC1\fP, \fBrsb_flags_t\fP order = \fC\fBRSB_FLAG_WANT_COLUMN_MAJOR_ORDER\fP\fP, const NT * Bp = \fCRSBP_NULL\fP, \fBrsb_nnz_idx_t\fP ldB = \fC0\fP, const NT * betap = \fCRSBP_NULL\fP, NT * Cp = \fCRSBP_NULL\fP, \fBrsb_nnz_idx_t\fP ldC = \fC0\fP) const\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_tune_spsm()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP
\fBDeprecated\fP
.RS 4
This function overload is deprecated: use the corresponding overload without the C-style pointers-to-scalar, or request one if non existing yet\&. 
.RE
.PP

.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP Err_t \fBRsbMatrix\fP< NT >::upd_vals (enum \fBrsb_elopf_t\fP elop_flags, const NT & omega)\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_mtx_upd_vals()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP
Example snip from \fBexamples/bench\&.cpp\fP: 
.PP
.nf
    mtx\&.upd_vals(RSB_ELOPF_POW,nt_t{0\&.0}); // set matrix values to ones

.fi
.PP
 
.SS "template<RSBP_Scalar_t NT> \fBRSBP_RVT\fP Err_t \fBRsbMatrix\fP< NT >::upd_vals (enum \fBrsb_elopf_t\fP elop_flags, const NT * omegap)\fC [inline]\fP"

.PP
\fBNote:\fP
.RS 4
Directly based on C function \fBrsb_mtx_upd_vals()\fP from \fC<\fBrsb\&.h\fP>\fP\&.
.RE
.PP
\fBDeprecated\fP
.RS 4
This function overload is deprecated: use the corresponding overload without the C-style pointers-to-scalar, or request one if non existing yet\&. 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for librsb from the source code\&.
