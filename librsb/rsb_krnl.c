/* @cond INNERDOC */
/*! 
 @file
 @brief Matrix type dispatching code, for each matrix operation.
 */

/*

Copyright (C) 2008-2020 Michele Martone

This file is part of librsb.

librsb is free software; you can redistribute it and/or modify it
under the terms of the GNU Lesser General Public License as published
by the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

librsb is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
License for more details.

You should have received a copy of the GNU Lesser General Public
License along with librsb; see the file COPYING.
If not, see <http://www.gnu.org/licenses/>.

*/
/*
 The code in this file was generated automatically by an M4 script. 
 It is not meant to be used as an API (Application Programming Interface).
 p.s.: right now, only row major matrix access is considered.

 */


#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/*!
 @file
 @brief
 Performance kernels dispatching code, for each type, submatrix size, operation.
 But for block compressed sparse stripes format.
 Kernels unrolled, with no loops, for only user-specified blockings.
 */

/*

Copyright (C) 2008-2020 Michele Martone

This file is part of librsb.

librsb is free software; you can redistribute it and/or modify it
under the terms of the GNU Lesser General Public License as published
by the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

librsb is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
License for more details.

You should have received a copy of the GNU Lesser General Public
License along with librsb; see the file COPYING.
If not, see <http://www.gnu.org/licenses/>.

*/
/*
 The code in this file was generated automatically by an M4 script. 
 It is not meant to be used as an API (Application Programming Interface).
 p.s.: right now, only row major matrix access is considered.

 */
#include "rsb_common.h"
#include "rsb_krnl_bcss_spmv_u.h"	/* uhm */
#include "rsb_krnl_bcss_spsv_u.h"	/* uhm */
#include "rsb_krnl_bcss_misc_u.h"	/* uhm */

#pragma GCC visibility push(hidden)




rsb_err_t rsb__do_spmv_uaua(const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FUNCTION macro */
{
	/*!
	 * \ingroup rsb_doc_kernels
	 * A run-time kernel dispatching function.
	 * 
	 * Will use the right "spmv_uaua" kernel for each matrix block.
	 * 
	 * However, there could be some overhead in the process of dispatching
	 * the right function kernel for each block, especially for matrices
	 * partitioned in same-size blocks.
	 * 
	 * In that case, it is better to use some specialized function.
	 *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	rsb_flags_t symmetry,diagonal;
#ifdef RSB_COORDINATE_TYPE_H
	rsb_int_t half_storage = rsb__do_is_candidate_size_for_halfword(mtxAp->Mdim,mtxAp->mdim,/*nnz*/0,mtxAp->flags)?RSB_COORDINATE_TYPE_H:RSB_COORDINATE_TYPE_C;
#else /* RSB_M4_MATRIX_INDEX_COORDINATE_TYPE_PREPROCESSOR_SYMBOL(`rsb_half_idx_t') */
	rsb_int_t half_storage=RSB_COORDINATE_TYPE_C;
#endif /* RSB_M4_MATRIX_INDEX_COORDINATE_TYPE_PREPROCESSOR_SYMBOL(`rsb_half_idx_t') */

	if(!mtxAp /*|| !mtxAp->options */)
		return RSB_ERR_BADARGS;

	symmetry = rsb__get_symmetry_type_flag(mtxAp);
	diagonal = rsb__get_diagonal_type_flag(mtxAp);

	if(RSB_MATRIX_UNSUPPORTED_TYPE(mtxAp->typecode))
		return RSB_ERR_BADARGS;

	switch(diagonal)
	{
	case(RSB_DIAGONAL_E):
	switch(half_storage)
	{
	case(RSB_COORDINATE_TYPE_C):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_COORDINATE_TYPE_H):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this coordinate index (0x%x) is not supported.\n",(rsb_int)half_storage);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	break;
		case(RSB_DIAGONAL_I):
	switch(half_storage)
	{
	case(RSB_COORDINATE_TYPE_C):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_COORDINATE_TYPE_H):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uaua_double_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uaua_float_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_float_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uaua_double_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uaua_double_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uaua_float_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_float_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uaua_double_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this coordinate index (0x%x) is not supported.\n",(rsb_int)half_storage);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this diagonal type (0x%x) is not supported.\n",(rsb_int)diagonal);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	return errval;
}

rsb_err_t rsb__do_spmv_uauz(const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FUNCTION macro */
{
	/*!
	 * \ingroup rsb_doc_kernels
	 * A run-time kernel dispatching function.
	 * 
	 * Will use the right "spmv_uauz" kernel for each matrix block.
	 * 
	 * However, there could be some overhead in the process of dispatching
	 * the right function kernel for each block, especially for matrices
	 * partitioned in same-size blocks.
	 * 
	 * In that case, it is better to use some specialized function.
	 *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	rsb_flags_t symmetry,diagonal;
#ifdef RSB_COORDINATE_TYPE_H
	rsb_int_t half_storage = rsb__do_is_candidate_size_for_halfword(mtxAp->Mdim,mtxAp->mdim,/*nnz*/0,mtxAp->flags)?RSB_COORDINATE_TYPE_H:RSB_COORDINATE_TYPE_C;
#else /* RSB_M4_MATRIX_INDEX_COORDINATE_TYPE_PREPROCESSOR_SYMBOL(`rsb_half_idx_t') */
	rsb_int_t half_storage=RSB_COORDINATE_TYPE_C;
#endif /* RSB_M4_MATRIX_INDEX_COORDINATE_TYPE_PREPROCESSOR_SYMBOL(`rsb_half_idx_t') */

	if(!mtxAp /*|| !mtxAp->options */)
		return RSB_ERR_BADARGS;

	symmetry = rsb__get_symmetry_type_flag(mtxAp);
	diagonal = rsb__get_diagonal_type_flag(mtxAp);

	if(RSB_MATRIX_UNSUPPORTED_TYPE(mtxAp->typecode))
		return RSB_ERR_BADARGS;

	switch(diagonal)
	{
	case(RSB_DIAGONAL_E):
	switch(half_storage)
	{
	case(RSB_COORDINATE_TYPE_C):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_COORDINATE_TYPE_H):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this coordinate index (0x%x) is not supported.\n",(rsb_int)half_storage);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	break;
		case(RSB_DIAGONAL_I):
	switch(half_storage)
	{
	case(RSB_COORDINATE_TYPE_C):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_COORDINATE_TYPE_H):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uauz_double_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uauz_float_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_float_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uauz_double_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uauz_double_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uauz_float_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_float_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uauz_double_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this coordinate index (0x%x) is not supported.\n",(rsb_int)half_storage);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this diagonal type (0x%x) is not supported.\n",(rsb_int)diagonal);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	return errval;
}

rsb_err_t rsb__do_spmv_uxua(const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const void * alphap,const rsb_trans_t transA)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FUNCTION macro */
{
	/*!
	 * \ingroup rsb_doc_kernels
	 * A run-time kernel dispatching function.
	 * 
	 * Will use the right "spmv_uxua" kernel for each matrix block.
	 * 
	 * However, there could be some overhead in the process of dispatching
	 * the right function kernel for each block, especially for matrices
	 * partitioned in same-size blocks.
	 * 
	 * In that case, it is better to use some specialized function.
	 *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	rsb_flags_t symmetry,diagonal;
#ifdef RSB_COORDINATE_TYPE_H
	rsb_int_t half_storage = rsb__do_is_candidate_size_for_halfword(mtxAp->Mdim,mtxAp->mdim,/*nnz*/0,mtxAp->flags)?RSB_COORDINATE_TYPE_H:RSB_COORDINATE_TYPE_C;
#else /* RSB_M4_MATRIX_INDEX_COORDINATE_TYPE_PREPROCESSOR_SYMBOL(`rsb_half_idx_t') */
	rsb_int_t half_storage=RSB_COORDINATE_TYPE_C;
#endif /* RSB_M4_MATRIX_INDEX_COORDINATE_TYPE_PREPROCESSOR_SYMBOL(`rsb_half_idx_t') */

	if(!mtxAp /*|| !mtxAp->options */)
		return RSB_ERR_BADARGS;

	symmetry = rsb__get_symmetry_type_flag(mtxAp);
	diagonal = rsb__get_diagonal_type_flag(mtxAp);

	if(RSB_MATRIX_UNSUPPORTED_TYPE(mtxAp->typecode))
		return RSB_ERR_BADARGS;

	switch(diagonal)
	{
	case(RSB_DIAGONAL_E):
	switch(half_storage)
	{
	case(RSB_COORDINATE_TYPE_C):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_COORDINATE_TYPE_H):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this coordinate index (0x%x) is not supported.\n",(rsb_int)half_storage);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	break;
		case(RSB_DIAGONAL_I):
	switch(half_storage)
	{
	case(RSB_COORDINATE_TYPE_C):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_COORDINATE_TYPE_H):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_uxua_double_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_uxua_float_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_float_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_uxua_double_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_uxua_double_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_uxua_float_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_float_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_uxua_double_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this coordinate index (0x%x) is not supported.\n",(rsb_int)half_storage);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this diagonal type (0x%x) is not supported.\n",(rsb_int)diagonal);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	return errval;
}

rsb_err_t rsb__do_spmv_unua(const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FUNCTION macro */
{
	/*!
	 * \ingroup rsb_doc_kernels
	 * A run-time kernel dispatching function.
	 * 
	 * Will use the right "spmv_unua" kernel for each matrix block.
	 * 
	 * However, there could be some overhead in the process of dispatching
	 * the right function kernel for each block, especially for matrices
	 * partitioned in same-size blocks.
	 * 
	 * In that case, it is better to use some specialized function.
	 *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	rsb_flags_t symmetry,diagonal;
#ifdef RSB_COORDINATE_TYPE_H
	rsb_int_t half_storage = rsb__do_is_candidate_size_for_halfword(mtxAp->Mdim,mtxAp->mdim,/*nnz*/0,mtxAp->flags)?RSB_COORDINATE_TYPE_H:RSB_COORDINATE_TYPE_C;
#else /* RSB_M4_MATRIX_INDEX_COORDINATE_TYPE_PREPROCESSOR_SYMBOL(`rsb_half_idx_t') */
	rsb_int_t half_storage=RSB_COORDINATE_TYPE_C;
#endif /* RSB_M4_MATRIX_INDEX_COORDINATE_TYPE_PREPROCESSOR_SYMBOL(`rsb_half_idx_t') */

	if(!mtxAp /*|| !mtxAp->options */)
		return RSB_ERR_BADARGS;

	symmetry = rsb__get_symmetry_type_flag(mtxAp);
	diagonal = rsb__get_diagonal_type_flag(mtxAp);

	if(RSB_MATRIX_UNSUPPORTED_TYPE(mtxAp->typecode))
		return RSB_ERR_BADARGS;

	switch(diagonal)
	{
	case(RSB_DIAGONAL_E):
	switch(half_storage)
	{
	case(RSB_COORDINATE_TYPE_C):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_COORDINATE_TYPE_H):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this coordinate index (0x%x) is not supported.\n",(rsb_int)half_storage);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	break;
		case(RSB_DIAGONAL_I):
	switch(half_storage)
	{
	case(RSB_COORDINATE_TYPE_C):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_COORDINATE_TYPE_H):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_unua_double_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_unua_float_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_float_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_unua_double_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_unua_double_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_unua_float_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_float_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_unua_double_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this coordinate index (0x%x) is not supported.\n",(rsb_int)half_storage);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this diagonal type (0x%x) is not supported.\n",(rsb_int)diagonal);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	return errval;
}

rsb_err_t rsb__do_spmv_sasa(const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,rsb_coo_idx_t incx, rsb_coo_idx_t incy,const rsb_trans_t transA)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FUNCTION macro */
{
	/*!
	 * \ingroup rsb_doc_kernels
	 * A run-time kernel dispatching function.
	 * 
	 * Will use the right "spmv_sasa" kernel for each matrix block.
	 * 
	 * However, there could be some overhead in the process of dispatching
	 * the right function kernel for each block, especially for matrices
	 * partitioned in same-size blocks.
	 * 
	 * In that case, it is better to use some specialized function.
	 *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	rsb_flags_t symmetry,diagonal;
#ifdef RSB_COORDINATE_TYPE_H
	rsb_int_t half_storage = rsb__do_is_candidate_size_for_halfword(mtxAp->Mdim,mtxAp->mdim,/*nnz*/0,mtxAp->flags)?RSB_COORDINATE_TYPE_H:RSB_COORDINATE_TYPE_C;
#else /* RSB_M4_MATRIX_INDEX_COORDINATE_TYPE_PREPROCESSOR_SYMBOL(`rsb_half_idx_t') */
	rsb_int_t half_storage=RSB_COORDINATE_TYPE_C;
#endif /* RSB_M4_MATRIX_INDEX_COORDINATE_TYPE_PREPROCESSOR_SYMBOL(`rsb_half_idx_t') */

	if(!mtxAp /*|| !mtxAp->options */)
		return RSB_ERR_BADARGS;

	symmetry = rsb__get_symmetry_type_flag(mtxAp);
	diagonal = rsb__get_diagonal_type_flag(mtxAp);

	if(RSB_MATRIX_UNSUPPORTED_TYPE(mtxAp->typecode))
		return RSB_ERR_BADARGS;

	switch(diagonal)
	{
	case(RSB_DIAGONAL_E):
	switch(half_storage)
	{
	case(RSB_COORDINATE_TYPE_C):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_COORDINATE_TYPE_H):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this coordinate index (0x%x) is not supported.\n",(rsb_int)half_storage);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	break;
		case(RSB_DIAGONAL_I):
	switch(half_storage)
	{
	case(RSB_COORDINATE_TYPE_C):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_COORDINATE_TYPE_H):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sasa_double_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sasa_float_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_float_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sasa_double_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sasa_double_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sasa_float_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_float_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sasa_double_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this coordinate index (0x%x) is not supported.\n",(rsb_int)half_storage);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this diagonal type (0x%x) is not supported.\n",(rsb_int)diagonal);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	return errval;
}

rsb_err_t rsb__do_spsv_uxua(const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FUNCTION macro */
{
	/*!
	 * \ingroup rsb_doc_kernels
	 * A run-time kernel dispatching function.
	 * 
	 * Will use the right "spsv_uxua" kernel for each matrix block.
	 * 
	 * However, there could be some overhead in the process of dispatching
	 * the right function kernel for each block, especially for matrices
	 * partitioned in same-size blocks.
	 * 
	 * In that case, it is better to use some specialized function.
	 *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	rsb_flags_t symmetry,diagonal;
#ifdef RSB_COORDINATE_TYPE_H
	rsb_int_t half_storage = rsb__do_is_candidate_size_for_halfword(mtxAp->Mdim,mtxAp->mdim,/*nnz*/0,mtxAp->flags)?RSB_COORDINATE_TYPE_H:RSB_COORDINATE_TYPE_C;
#else /* RSB_M4_MATRIX_INDEX_COORDINATE_TYPE_PREPROCESSOR_SYMBOL(`rsb_half_idx_t') */
	rsb_int_t half_storage=RSB_COORDINATE_TYPE_C;
#endif /* RSB_M4_MATRIX_INDEX_COORDINATE_TYPE_PREPROCESSOR_SYMBOL(`rsb_half_idx_t') */

	if(!mtxAp /*|| !mtxAp->options */)
		return RSB_ERR_BADARGS;

	symmetry = rsb__get_symmetry_type_flag(mtxAp);
	diagonal = rsb__get_diagonal_type_flag(mtxAp);

	if(RSB_MATRIX_UNSUPPORTED_TYPE(mtxAp->typecode))
		return RSB_ERR_BADARGS;

	switch(diagonal)
	{
	case(RSB_DIAGONAL_E):
	switch(half_storage)
	{
	case(RSB_COORDINATE_TYPE_C):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_C_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_C_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_C_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_C_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_C_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_C_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_C_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_C_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_C_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_C_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_C_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_C_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_C_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_C_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_C_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_C_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_C_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_C_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_C_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_C_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_C_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_C_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_C_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_C_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_C_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_C_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_C_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_C_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_C_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_C_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_C_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_C_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_C_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_C_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_C_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_C_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_C_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_C_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_C_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_C_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_C_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_C_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_C_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_C_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_C_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_C_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_C_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_C_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_C_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_C_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_C_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_C_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_C_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_C_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_C_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_C_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_C_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_C_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_C_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_C_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_C_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_C_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_C_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_C_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_C_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_C_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_C_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_C_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_C_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_C_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_C_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_C_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_COORDINATE_TYPE_H):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_H_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_H_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_H_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_H_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_H_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_H_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_H_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_H_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_H_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_H_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_H_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_H_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_H_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_H_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_H_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_H_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_H_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_H_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_H_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_H_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_H_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_H_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_H_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_H_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_H_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_H_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_H_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_H_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_H_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_H_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_H_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_H_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_H_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_H_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_H_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_H_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_H_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_H_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_H_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_H_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_H_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_H_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_H_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_H_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_H_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_H_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_H_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_H_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_H_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_H_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_H_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_H_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_H_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_H_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_H_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_H_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_H_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_H_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_H_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_H_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_H_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_H_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_H_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_H_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_H_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_H_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_H_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_H_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_H_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_H_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_H_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_H_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this coordinate index (0x%x) is not supported.\n",(rsb_int)half_storage);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	break;
		case(RSB_DIAGONAL_I):
	switch(half_storage)
	{
	case(RSB_COORDINATE_TYPE_C):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_C_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_C_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_C_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_C_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_C_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_C_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_C_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_C_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_C_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_C_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_C_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_C_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_C_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_C_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_C_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_C_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_C_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_C_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_C_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_C_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_C_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_C_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_C_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_C_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_C_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_C_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_C_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_C_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_C_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_C_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_C_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_C_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_C_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_C_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_C_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_C_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_C_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_C_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_C_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_C_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_C_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_C_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_C_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_C_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_C_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_C_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_C_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_C_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_C_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_C_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_C_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_C_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_C_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_C_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_C_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_C_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_C_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_C_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_C_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_C_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_C_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_C_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_C_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_C_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_C_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_C_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_C_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_C_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_C_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_C_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_C_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_C_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_C_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_C_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_C_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_C_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_COORDINATE_TYPE_H):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_H_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_H_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_H_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_H_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_H_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_H_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_H_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_H_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_H_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_H_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_H_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_H_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_H_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_H_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_H_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_H_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_H_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_H_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_H_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_H_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_H_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_H_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_H_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_H_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_H_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_H_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_H_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_H_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_H_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_H_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_H_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_H_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_H_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_H_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_H_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_H_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_H_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_H_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_H_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_H_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_H_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_H_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_H_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_H_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_H_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_H_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_H_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_H_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_H_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_H_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_H_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_H_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_H_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_H_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_H_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_H_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_H_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_H_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_H_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_H_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_H_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_H_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_H_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_H_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_H_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_H_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_H_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_H_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_float_complex_H_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	else
		errval = rsb__BCOR_spsv_uxua_double_complex_H_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_H_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_H_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_H_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_H_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_float_complex_H_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	else
		errval = rsb__BCSR_spsv_uxua_double_complex_H_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this coordinate index (0x%x) is not supported.\n",(rsb_int)half_storage);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this diagonal type (0x%x) is not supported.\n",(rsb_int)diagonal);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	return errval;
}

rsb_err_t rsb__do_spmv_sxsa(const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const void * alphap,rsb_coo_idx_t incx, rsb_coo_idx_t incy,const rsb_trans_t transA)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FUNCTION macro */
{
	/*!
	 * \ingroup rsb_doc_kernels
	 * A run-time kernel dispatching function.
	 * 
	 * Will use the right "spmv_sxsa" kernel for each matrix block.
	 * 
	 * However, there could be some overhead in the process of dispatching
	 * the right function kernel for each block, especially for matrices
	 * partitioned in same-size blocks.
	 * 
	 * In that case, it is better to use some specialized function.
	 *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	rsb_flags_t symmetry,diagonal;
#ifdef RSB_COORDINATE_TYPE_H
	rsb_int_t half_storage = rsb__do_is_candidate_size_for_halfword(mtxAp->Mdim,mtxAp->mdim,/*nnz*/0,mtxAp->flags)?RSB_COORDINATE_TYPE_H:RSB_COORDINATE_TYPE_C;
#else /* RSB_M4_MATRIX_INDEX_COORDINATE_TYPE_PREPROCESSOR_SYMBOL(`rsb_half_idx_t') */
	rsb_int_t half_storage=RSB_COORDINATE_TYPE_C;
#endif /* RSB_M4_MATRIX_INDEX_COORDINATE_TYPE_PREPROCESSOR_SYMBOL(`rsb_half_idx_t') */

	if(!mtxAp /*|| !mtxAp->options */)
		return RSB_ERR_BADARGS;

	symmetry = rsb__get_symmetry_type_flag(mtxAp);
	diagonal = rsb__get_diagonal_type_flag(mtxAp);

	if(RSB_MATRIX_UNSUPPORTED_TYPE(mtxAp->typecode))
		return RSB_ERR_BADARGS;

	switch(diagonal)
	{
	case(RSB_DIAGONAL_E):
	switch(half_storage)
	{
	case(RSB_COORDINATE_TYPE_C):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_COORDINATE_TYPE_H):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this coordinate index (0x%x) is not supported.\n",(rsb_int)half_storage);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	break;
		case(RSB_DIAGONAL_I):
	switch(half_storage)
	{
	case(RSB_COORDINATE_TYPE_C):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_COORDINATE_TYPE_H):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_spmv_sxsa_double_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_spmv_sxsa_float_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_float_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_spmv_sxsa_double_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_spmv_sxsa_double_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_spmv_sxsa_float_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_float_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_spmv_sxsa_double_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this coordinate index (0x%x) is not supported.\n",(rsb_int)half_storage);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this diagonal type (0x%x) is not supported.\n",(rsb_int)diagonal);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	return errval;
}

rsb_err_t rsb__do_spsv_sxsx(const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const void * alphap,rsb_coo_idx_t incx, rsb_coo_idx_t incy,const rsb_trans_t transA)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FUNCTION macro */
{
	/*!
	 * \ingroup rsb_doc_kernels
	 * A run-time kernel dispatching function.
	 * 
	 * Will use the right "spsv_sxsx" kernel for each matrix block.
	 * 
	 * However, there could be some overhead in the process of dispatching
	 * the right function kernel for each block, especially for matrices
	 * partitioned in same-size blocks.
	 * 
	 * In that case, it is better to use some specialized function.
	 *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	rsb_flags_t symmetry,diagonal;
#ifdef RSB_COORDINATE_TYPE_H
	rsb_int_t half_storage = rsb__do_is_candidate_size_for_halfword(mtxAp->Mdim,mtxAp->mdim,/*nnz*/0,mtxAp->flags)?RSB_COORDINATE_TYPE_H:RSB_COORDINATE_TYPE_C;
#else /* RSB_M4_MATRIX_INDEX_COORDINATE_TYPE_PREPROCESSOR_SYMBOL(`rsb_half_idx_t') */
	rsb_int_t half_storage=RSB_COORDINATE_TYPE_C;
#endif /* RSB_M4_MATRIX_INDEX_COORDINATE_TYPE_PREPROCESSOR_SYMBOL(`rsb_half_idx_t') */

	if(!mtxAp /*|| !mtxAp->options */)
		return RSB_ERR_BADARGS;

	symmetry = rsb__get_symmetry_type_flag(mtxAp);
	diagonal = rsb__get_diagonal_type_flag(mtxAp);

	if(RSB_MATRIX_UNSUPPORTED_TYPE(mtxAp->typecode))
		return RSB_ERR_BADARGS;

	switch(diagonal)
	{
	case(RSB_DIAGONAL_E):
	switch(half_storage)
	{
	case(RSB_COORDINATE_TYPE_C):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_COORDINATE_TYPE_H):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tN_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tN_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tN_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tN_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tN_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tN_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tT_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tT_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tT_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tT_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tT_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tT_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tC_sU_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tC_sU_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tC_sS_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tC_sS_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tC_sH_dE_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tC_sH_dE_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this coordinate index (0x%x) is not supported.\n",(rsb_int)half_storage);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	break;
		case(RSB_DIAGONAL_I):
	switch(half_storage)
	{
	case(RSB_COORDINATE_TYPE_C):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_C_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_C_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_C_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_C_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_C_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_C_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_C_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_C_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_COORDINATE_TYPE_H):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tN_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tN_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tN_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tN_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tN_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tN_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tT_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tT_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tT_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tT_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tT_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tT_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tC_sU_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tC_sU_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tC_sS_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tC_sS_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_H_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_H_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_float_complex_H_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	else
		errval = rsb__BCOR_spsv_sxsx_double_complex_H_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_H_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_H_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_float_complex_H_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
	if(rsb__is_lower_triangle(mtxAp->flags))
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tC_sH_dI_uL(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	else
		errval = rsb__BCSR_spsv_sxsx_double_complex_H_u_tC_sH_dI_uU(	mtxAp->VA,rhs,out,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,alphap,incx,incy);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this coordinate index (0x%x) is not supported.\n",(rsb_int)half_storage);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this diagonal type (0x%x) is not supported.\n",(rsb_int)diagonal);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	return errval;
}

rsb_err_t rsb__do_infty_norm(const struct rsb_mtx_t * mtxAp,const rsb_trans_t transA,void * row_sums)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FUNCTION macro */
{
	/*!
	 * \ingroup rsb_doc_kernels
	 * A run-time kernel dispatching function.
	 * 
	 * Will use the right "infty_norm" kernel for each matrix block.
	 * 
	 * However, there could be some overhead in the process of dispatching
	 * the right function kernel for each block, especially for matrices
	 * partitioned in same-size blocks.
	 * 
	 * In that case, it is better to use some specialized function.
	 *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	rsb_flags_t symmetry,diagonal;
#ifdef RSB_COORDINATE_TYPE_H
	rsb_int_t half_storage = rsb__do_is_candidate_size_for_halfword(mtxAp->Mdim,mtxAp->mdim,/*nnz*/0,mtxAp->flags)?RSB_COORDINATE_TYPE_H:RSB_COORDINATE_TYPE_C;
#else /* RSB_M4_MATRIX_INDEX_COORDINATE_TYPE_PREPROCESSOR_SYMBOL(`rsb_half_idx_t') */
	rsb_int_t half_storage=RSB_COORDINATE_TYPE_C;
#endif /* RSB_M4_MATRIX_INDEX_COORDINATE_TYPE_PREPROCESSOR_SYMBOL(`rsb_half_idx_t') */

	if(!mtxAp /*|| !mtxAp->options */)
		return RSB_ERR_BADARGS;

	symmetry = rsb__get_symmetry_type_flag(mtxAp);
	diagonal = rsb__get_diagonal_type_flag(mtxAp);

	if(RSB_MATRIX_UNSUPPORTED_TYPE(mtxAp->typecode))
		return RSB_ERR_BADARGS;

	switch(diagonal)
	{
	case(RSB_DIAGONAL_E):
	switch(half_storage)
	{
	case(RSB_COORDINATE_TYPE_C):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_C_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_C_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_C_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_C_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_C_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_C_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_C_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_C_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_C_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_C_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_C_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_C_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_C_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_C_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_C_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_C_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_C_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_C_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_C_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_C_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_C_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_C_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_C_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_C_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_C_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_C_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_C_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_C_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_C_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_C_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_C_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_C_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_C_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_C_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_C_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_C_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_COORDINATE_TYPE_H):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_H_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_H_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_H_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_H_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_H_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_H_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_H_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_H_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_H_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_H_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_H_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_H_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_H_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_H_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_H_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_H_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_H_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_H_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_H_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_H_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_H_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_H_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_H_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_H_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_H_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_H_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_H_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_H_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_H_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_H_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_H_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_H_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_H_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_H_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_H_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_H_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this coordinate index (0x%x) is not supported.\n",(rsb_int)half_storage);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	break;
		case(RSB_DIAGONAL_I):
	switch(half_storage)
	{
	case(RSB_COORDINATE_TYPE_C):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_C_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_C_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_C_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_C_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_C_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_C_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_C_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_C_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_C_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_C_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_C_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_C_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_C_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_C_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_C_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_C_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_C_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_C_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_C_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_C_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_C_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_C_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_C_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_C_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_C_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_C_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_C_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_C_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_C_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_C_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_C_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_C_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_C_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_C_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_C_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_C_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_COORDINATE_TYPE_H):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_H_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_H_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_H_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_H_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_H_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_H_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_H_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_H_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_H_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_H_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_H_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_H_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_H_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_H_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_H_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_H_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_H_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_H_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_H_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_H_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_H_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_H_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_H_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_H_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_H_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_H_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_H_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_H_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_H_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_H_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_H_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_H_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_infty_norm_double_H_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_infty_norm_float_H_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_infty_norm_float_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_infty_norm_double_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_infty_norm_double_H_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_infty_norm_float_H_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_infty_norm_float_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_infty_norm_double_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this coordinate index (0x%x) is not supported.\n",(rsb_int)half_storage);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this diagonal type (0x%x) is not supported.\n",(rsb_int)diagonal);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	return errval;
}

rsb_err_t rsb__do_rowssums(const struct rsb_mtx_t * mtxAp,const rsb_trans_t transA,void * row_sums)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FUNCTION macro */
{
	/*!
	 * \ingroup rsb_doc_kernels
	 * A run-time kernel dispatching function.
	 * 
	 * Will use the right "rowssums" kernel for each matrix block.
	 * 
	 * However, there could be some overhead in the process of dispatching
	 * the right function kernel for each block, especially for matrices
	 * partitioned in same-size blocks.
	 * 
	 * In that case, it is better to use some specialized function.
	 *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	rsb_flags_t symmetry,diagonal;
#ifdef RSB_COORDINATE_TYPE_H
	rsb_int_t half_storage = rsb__do_is_candidate_size_for_halfword(mtxAp->Mdim,mtxAp->mdim,/*nnz*/0,mtxAp->flags)?RSB_COORDINATE_TYPE_H:RSB_COORDINATE_TYPE_C;
#else /* RSB_M4_MATRIX_INDEX_COORDINATE_TYPE_PREPROCESSOR_SYMBOL(`rsb_half_idx_t') */
	rsb_int_t half_storage=RSB_COORDINATE_TYPE_C;
#endif /* RSB_M4_MATRIX_INDEX_COORDINATE_TYPE_PREPROCESSOR_SYMBOL(`rsb_half_idx_t') */

	if(!mtxAp /*|| !mtxAp->options */)
		return RSB_ERR_BADARGS;

	symmetry = rsb__get_symmetry_type_flag(mtxAp);
	diagonal = rsb__get_diagonal_type_flag(mtxAp);

	if(RSB_MATRIX_UNSUPPORTED_TYPE(mtxAp->typecode))
		return RSB_ERR_BADARGS;

	switch(diagonal)
	{
	case(RSB_DIAGONAL_E):
	switch(half_storage)
	{
	case(RSB_COORDINATE_TYPE_C):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_C_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_C_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_C_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_C_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_C_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_C_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_C_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_C_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_C_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_C_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_C_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_C_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_C_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_C_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_C_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_C_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_C_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_C_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_C_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_C_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_C_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_C_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_C_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_C_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_C_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_C_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_C_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_C_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_C_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_C_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_C_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_C_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_C_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_C_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_C_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_C_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_COORDINATE_TYPE_H):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_H_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_H_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_H_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_H_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_H_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_H_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_H_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_H_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_H_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_H_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_H_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_H_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_H_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_H_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_H_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_H_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_H_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_H_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_H_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_H_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_H_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_H_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_H_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_H_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_H_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_H_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_H_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_H_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_H_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_H_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_H_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_H_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_H_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_H_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_H_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_H_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this coordinate index (0x%x) is not supported.\n",(rsb_int)half_storage);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	break;
		case(RSB_DIAGONAL_I):
	switch(half_storage)
	{
	case(RSB_COORDINATE_TYPE_C):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_C_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_C_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_C_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_C_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_C_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_C_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_C_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_C_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_C_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_C_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_C_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_C_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_C_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_C_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_C_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_C_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_C_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_C_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_C_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_C_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_C_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_C_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_C_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_C_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_C_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_C_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_C_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_C_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_C_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_C_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_C_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_C_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_C_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_C_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_C_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_C_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_COORDINATE_TYPE_H):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_H_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_H_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_H_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_H_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_H_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_H_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_H_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_H_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_H_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_H_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_H_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_H_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_H_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_H_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_H_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_H_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_H_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_H_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_H_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_H_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_H_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_H_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_H_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_H_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_H_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_H_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_H_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_H_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_H_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_H_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_H_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_H_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_rowssums_double_H_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_rowssums_float_H_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_rowssums_float_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_rowssums_double_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_rowssums_double_H_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_rowssums_float_H_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_rowssums_float_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_rowssums_double_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,row_sums,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this coordinate index (0x%x) is not supported.\n",(rsb_int)half_storage);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this diagonal type (0x%x) is not supported.\n",(rsb_int)diagonal);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	return errval;
}

rsb_err_t rsb__do_scale(struct rsb_mtx_t * mtxAp,const rsb_trans_t transA,const void * scale_factors)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FUNCTION macro */
{
	/*!
	 * \ingroup rsb_doc_kernels
	 * A run-time kernel dispatching function.
	 * 
	 * Will use the right "scale" kernel for each matrix block.
	 * 
	 * However, there could be some overhead in the process of dispatching
	 * the right function kernel for each block, especially for matrices
	 * partitioned in same-size blocks.
	 * 
	 * In that case, it is better to use some specialized function.
	 *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	rsb_flags_t symmetry,diagonal;
#ifdef RSB_COORDINATE_TYPE_H
	rsb_int_t half_storage = rsb__do_is_candidate_size_for_halfword(mtxAp->Mdim,mtxAp->mdim,/*nnz*/0,mtxAp->flags)?RSB_COORDINATE_TYPE_H:RSB_COORDINATE_TYPE_C;
#else /* RSB_M4_MATRIX_INDEX_COORDINATE_TYPE_PREPROCESSOR_SYMBOL(`rsb_half_idx_t') */
	rsb_int_t half_storage=RSB_COORDINATE_TYPE_C;
#endif /* RSB_M4_MATRIX_INDEX_COORDINATE_TYPE_PREPROCESSOR_SYMBOL(`rsb_half_idx_t') */

	if(!mtxAp /*|| !mtxAp->options */)
		return RSB_ERR_BADARGS;

	symmetry = rsb__get_symmetry_type_flag(mtxAp);
	diagonal = rsb__get_diagonal_type_flag(mtxAp);

	if(RSB_MATRIX_UNSUPPORTED_TYPE(mtxAp->typecode))
		return RSB_ERR_BADARGS;

	switch(diagonal)
	{
	case(RSB_DIAGONAL_E):
	switch(half_storage)
	{
	case(RSB_COORDINATE_TYPE_C):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_C_u_tN_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_C_u_tN_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_C_u_tN_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_C_u_tN_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_C_u_tN_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_C_u_tN_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_C_u_tN_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_C_u_tN_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_C_u_tN_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_C_u_tN_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_C_u_tN_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_C_u_tN_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_C_u_tN_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_C_u_tN_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_C_u_tN_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_C_u_tT_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_C_u_tT_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_C_u_tT_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_C_u_tT_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_C_u_tT_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_C_u_tT_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_C_u_tT_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_C_u_tT_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_C_u_tT_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_C_u_tT_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_C_u_tT_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_C_u_tT_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_C_u_tT_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_C_u_tT_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_C_u_tT_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_C_u_tC_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_C_u_tC_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_C_u_tC_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_C_u_tC_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_C_u_tC_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_C_u_tC_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_C_u_tC_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_C_u_tC_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_C_u_tC_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_C_u_tC_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_C_u_tC_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_C_u_tC_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_C_u_tC_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_C_u_tC_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_C_u_tC_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_COORDINATE_TYPE_H):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_H_u_tN_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_H_u_tN_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_H_u_tN_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_H_u_tN_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_H_u_tN_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_H_u_tN_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_H_u_tN_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_H_u_tN_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_H_u_tN_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_H_u_tN_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_H_u_tN_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_H_u_tN_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_H_u_tN_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_H_u_tN_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_H_u_tN_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_H_u_tT_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_H_u_tT_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_H_u_tT_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_H_u_tT_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_H_u_tT_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_H_u_tT_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_H_u_tT_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_H_u_tT_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_H_u_tT_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_H_u_tT_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_H_u_tT_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_H_u_tT_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_H_u_tT_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_H_u_tT_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_H_u_tT_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_H_u_tC_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_H_u_tC_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_H_u_tC_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_H_u_tC_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_H_u_tC_sU_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_H_u_tC_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_H_u_tC_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_H_u_tC_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_H_u_tC_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_H_u_tC_sS_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_H_u_tC_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_H_u_tC_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_H_u_tC_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_H_u_tC_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_H_u_tC_sH_dE_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this coordinate index (0x%x) is not supported.\n",(rsb_int)half_storage);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	break;
		case(RSB_DIAGONAL_I):
	switch(half_storage)
	{
	case(RSB_COORDINATE_TYPE_C):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_C_u_tN_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_C_u_tN_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_C_u_tN_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_C_u_tN_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_C_u_tN_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_C_u_tN_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_C_u_tN_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_C_u_tN_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_C_u_tN_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_C_u_tN_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_C_u_tN_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_C_u_tN_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_C_u_tN_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_C_u_tN_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_C_u_tN_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_C_u_tT_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_C_u_tT_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_C_u_tT_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_C_u_tT_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_C_u_tT_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_C_u_tT_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_C_u_tT_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_C_u_tT_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_C_u_tT_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_C_u_tT_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_C_u_tT_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_C_u_tT_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_C_u_tT_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_C_u_tT_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_C_u_tT_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_C_u_tC_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_C_u_tC_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_C_u_tC_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_C_u_tC_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_C_u_tC_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_C_u_tC_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_C_u_tC_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_C_u_tC_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_C_u_tC_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_C_u_tC_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_C_u_tC_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_C_u_tC_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_C_u_tC_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_C_u_tC_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_C_u_tC_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_coo_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_COORDINATE_TYPE_H):
	switch(transA)
	{
	case(RSB_TRANSPOSITION_N):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_H_u_tN_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_H_u_tN_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_H_u_tN_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_H_u_tN_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_H_u_tN_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_H_u_tN_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_H_u_tN_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_H_u_tN_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_H_u_tN_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_H_u_tN_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_H_u_tN_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_H_u_tN_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_H_u_tN_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_H_u_tN_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_H_u_tN_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_T):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_H_u_tT_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_H_u_tT_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_H_u_tT_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_H_u_tT_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_H_u_tT_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_H_u_tT_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_H_u_tT_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_H_u_tT_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_H_u_tT_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_H_u_tT_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_H_u_tT_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_H_u_tT_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_H_u_tT_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_H_u_tT_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_H_u_tT_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
		case(RSB_TRANSPOSITION_C):
	switch(symmetry)
	{
	case(RSB_SYMMETRY_U):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_H_u_tC_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_H_u_tC_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_H_u_tC_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_H_u_tC_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_H_u_tC_sU_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_S):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_H_u_tC_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_H_u_tC_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_H_u_tC_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_H_u_tC_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_H_u_tC_sS_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
		case(RSB_SYMMETRY_H):
	switch(mtxAp->matrix_storage)
	{
	case(RSB_MATRIX_STORAGE_BCOR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCOR_scale_double_H_u_tC_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCOR_scale_float_H_u_tC_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCOR_scale_float_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCOR_scale_double_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,mtxAp->nnz,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
		case(RSB_MATRIX_STORAGE_BCSR):
	switch(mtxAp->typecode)
	{
	case(RSB_NUMERICAL_TYPE_DOUBLE ):
		errval = rsb__BCSR_scale_double_H_u_tC_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT ):
		errval = rsb__BCSR_scale_float_H_u_tC_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ):
		errval = rsb__BCSR_scale_float_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
		case(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ):
		errval = rsb__BCSR_scale_double_complex_H_u_tC_sH_dI_uG(	mtxAp->VA,mtxAp->Mdim,mtxAp->mdim,(rsb_half_idx_t*)mtxAp->bindx,mtxAp->bpntr,mtxAp->indptr,mtxAp->rpntr,mtxAp->cpntr,mtxAp->broff-mtxAp->roff,mtxAp->bm,mtxAp->roff,mtxAp->coff,mtxAp->flags,scale_factors);
	break;
			default:
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	break;
			default:
		{
		RSB_ERROR("Sorry, matrix storage \"%c\" currently not supported.\n",mtxAp->matrix_storage);
		errval = RSB_ERR_UNSUPPORTED_FORMAT;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this symmetry case (0x%x) is not supported.\n",(rsb_int)symmetry);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this transposition case (0x%x) is not supported.\n",(rsb_int)transA);
			errval = RSB_ERR_UNSUPPORTED_TYPE	;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this coordinate index (0x%x) is not supported.\n",(rsb_int)half_storage);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	break;
			default:
		{
			RSB_ERROR("Sorry, this diagonal type (0x%x) is not supported.\n",(rsb_int)diagonal);
			errval = RSB_ERR_UNSUPPORTED_FEATURE;
		}
	}
	return errval;
}


#ifdef RSB_WANT_KERNELS_DEBUG
rsb_err_t rsb__spmv_uaua_testing(const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
{
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_TESTING_FUNCTION macro */
	/*!
	 * \ingroup gr_debug
	 * This is a trivial reference implementation of the "spmv_uaua" kernel, and 
	 * its numerical results will be used to shed some evidence if bugs 
	 * should be introduced in performance computational kernels.
	 * 
	 * It should be used for debugging or comparing with performance optimized
	 * functions.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	
	register rsb_coo_idx_t baserow = RSB_INI,basecolumn = RSB_INI,rows = RSB_INI,columns = RSB_INI;
	register rsb_coo_idx_t blockrow = RSB_INI,blockcolumn = RSB_INI;
	register rsb_byte_t *bp=0;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!mtxAp /*|| !mtxAp->options*/ )return RSB_ERR_BADARGS;
	{
	RSB_GET_FIRST_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_DOUBLE )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const double* a = (const double*)bp;
		const double* b = ((const double*)rhs)+mtxAp->cpntr[blockcolumn];
		double* c = ((double*)out)+mtxAp->rpntr[blockrow];
		rsb_coo_idx_t i,j;
		c=c;/* here just to prevent from compiler warning */

#if 0
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				c[i]+=a[i*columns+j]*b[j];
#else
		/*
		 * this code will emulate the same kernel order!
		 * it should generate the same numerical roundoff errors the current kernel would
		 * */
		for(i=0;i<rows;++i)
		{
			double rs=0;
			for(j=0;j<columns;++j)
				rs+=a[i*columns+j]*b[j];
			c[i]+=rs;
;
;
		}
#endif /* 0 */

	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_FLOAT )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const float* a = (const float*)bp;
		const float* b = ((const float*)rhs)+mtxAp->cpntr[blockcolumn];
		float* c = ((float*)out)+mtxAp->rpntr[blockrow];
		rsb_coo_idx_t i,j;
		c=c;/* here just to prevent from compiler warning */

#if 0
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				c[i]+=a[i*columns+j]*b[j];
#else
		/*
		 * this code will emulate the same kernel order!
		 * it should generate the same numerical roundoff errors the current kernel would
		 * */
		for(i=0;i<rows;++i)
		{
			float rs=0;
			for(j=0;j<columns;++j)
				rs+=a[i*columns+j]*b[j];
			c[i]+=rs;
;
;
		}
#endif /* 0 */

	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_FLOAT_COMPLEX )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const float complex* a = (const float complex*)bp;
		const float complex* b = ((const float complex*)rhs)+mtxAp->cpntr[blockcolumn];
		float complex* c = ((float complex*)out)+mtxAp->rpntr[blockrow];
		rsb_coo_idx_t i,j;
		c=c;/* here just to prevent from compiler warning */

#if 0
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				c[i]+=a[i*columns+j]*b[j];
#else
		/*
		 * this code will emulate the same kernel order!
		 * it should generate the same numerical roundoff errors the current kernel would
		 * */
		for(i=0;i<rows;++i)
		{
			float complex rs=0;
			for(j=0;j<columns;++j)
				rs+=a[i*columns+j]*b[j];
			c[i]+=rs;
;
;
		}
#endif /* 0 */

	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const double complex* a = (const double complex*)bp;
		const double complex* b = ((const double complex*)rhs)+mtxAp->cpntr[blockcolumn];
		double complex* c = ((double complex*)out)+mtxAp->rpntr[blockrow];
		rsb_coo_idx_t i,j;
		c=c;/* here just to prevent from compiler warning */

#if 0
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				c[i]+=a[i*columns+j]*b[j];
#else
		/*
		 * this code will emulate the same kernel order!
		 * it should generate the same numerical roundoff errors the current kernel would
		 * */
		for(i=0;i<rows;++i)
		{
			double complex rs=0;
			for(j=0;j<columns;++j)
				rs+=a[i*columns+j]*b[j];
			c[i]+=rs;
;
;
		}
#endif /* 0 */

	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	{
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		return RSB_ERR_UNSUPPORTED_TYPE	;
	}
	}
	return RSB_ERR_NO_ERROR;	
}
#endif /* RSB_WANT_KERNELS_DEBUG */

rsb_err_t rsb_do_time_spmv_uaua(double * elapsed_time, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_TIMING_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will perform the "spmv_uaua" operation, 
	 * measuring the time elapsed in seconds and writing it in a
	 * user set variable.
         * 
	 * Note that this dispatch function is matrix type indipendent.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_err_t errval = RSB_ERR_NO_ERROR;

	if( ! elapsed_time ) return RSB_ERR_BADARGS;

	*elapsed_time = - rsb_time();
	errval = rsb__do_spmv_uaua	(mtxAp,rhs,out,transA);
	
	*elapsed_time += rsb_time(); 
	return errval;
}

#ifdef RSB_WANT_KERNELS_DEBUG
rsb_err_t rsb__spmv_uauz_testing(const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
{
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_TESTING_FUNCTION macro */
	/*!
	 * \ingroup gr_debug
	 * This is a trivial reference implementation of the "spmv_uauz" kernel, and 
	 * its numerical results will be used to shed some evidence if bugs 
	 * should be introduced in performance computational kernels.
	 * 
	 * It should be used for debugging or comparing with performance optimized
	 * functions.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	
	register rsb_coo_idx_t baserow = RSB_INI,basecolumn = RSB_INI,rows = RSB_INI,columns = RSB_INI;
	register rsb_coo_idx_t blockrow = RSB_INI,blockcolumn = RSB_INI;
	register rsb_byte_t *bp=0;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!mtxAp /*|| !mtxAp->options*/ )return RSB_ERR_BADARGS;
	{
	RSB_GET_FIRST_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_DOUBLE )
	{

	rsb__cblas_Xscal(RSB_NUMERICAL_TYPE_DOUBLE ,mtxAp->nr,NULL,out,incy);
	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const double* a = (const double*)bp;
		const double* b = ((const double*)rhs)+mtxAp->cpntr[blockcolumn];
		double* c = ((double*)out)+mtxAp->rpntr[blockrow];
		rsb_coo_idx_t i,j;
		c=c;/* here just to prevent from compiler warning */

#if 0
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				c[i]+=a[i*columns+j]*b[j];
#else
		/*
		 * this code will emulate the same kernel order!
		 * it should generate the same numerical roundoff errors the current kernel would
		 * */
		for(i=0;i<rows;++i)
		{
			double rs=0;
			for(j=0;j<columns;++j)
				rs+=a[i*columns+j]*b[j];
;
;
		}
#endif /* 0 */

	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_FLOAT )
	{

	rsb__cblas_Xscal(RSB_NUMERICAL_TYPE_FLOAT ,mtxAp->nr,NULL,out,incy);
	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const float* a = (const float*)bp;
		const float* b = ((const float*)rhs)+mtxAp->cpntr[blockcolumn];
		float* c = ((float*)out)+mtxAp->rpntr[blockrow];
		rsb_coo_idx_t i,j;
		c=c;/* here just to prevent from compiler warning */

#if 0
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				c[i]+=a[i*columns+j]*b[j];
#else
		/*
		 * this code will emulate the same kernel order!
		 * it should generate the same numerical roundoff errors the current kernel would
		 * */
		for(i=0;i<rows;++i)
		{
			float rs=0;
			for(j=0;j<columns;++j)
				rs+=a[i*columns+j]*b[j];
;
;
		}
#endif /* 0 */

	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_FLOAT_COMPLEX )
	{

	rsb__cblas_Xscal(RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ,mtxAp->nr,NULL,out,incy);
	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const float complex* a = (const float complex*)bp;
		const float complex* b = ((const float complex*)rhs)+mtxAp->cpntr[blockcolumn];
		float complex* c = ((float complex*)out)+mtxAp->rpntr[blockrow];
		rsb_coo_idx_t i,j;
		c=c;/* here just to prevent from compiler warning */

#if 0
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				c[i]+=a[i*columns+j]*b[j];
#else
		/*
		 * this code will emulate the same kernel order!
		 * it should generate the same numerical roundoff errors the current kernel would
		 * */
		for(i=0;i<rows;++i)
		{
			float complex rs=0;
			for(j=0;j<columns;++j)
				rs+=a[i*columns+j]*b[j];
;
;
		}
#endif /* 0 */

	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX )
	{

	rsb__cblas_Xscal(RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ,mtxAp->nr,NULL,out,incy);
	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const double complex* a = (const double complex*)bp;
		const double complex* b = ((const double complex*)rhs)+mtxAp->cpntr[blockcolumn];
		double complex* c = ((double complex*)out)+mtxAp->rpntr[blockrow];
		rsb_coo_idx_t i,j;
		c=c;/* here just to prevent from compiler warning */

#if 0
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				c[i]+=a[i*columns+j]*b[j];
#else
		/*
		 * this code will emulate the same kernel order!
		 * it should generate the same numerical roundoff errors the current kernel would
		 * */
		for(i=0;i<rows;++i)
		{
			double complex rs=0;
			for(j=0;j<columns;++j)
				rs+=a[i*columns+j]*b[j];
;
;
		}
#endif /* 0 */

	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	{
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		return RSB_ERR_UNSUPPORTED_TYPE	;
	}
	}
	return RSB_ERR_NO_ERROR;	
}
#endif /* RSB_WANT_KERNELS_DEBUG */

rsb_err_t rsb_do_time_spmv_uauz(double * elapsed_time, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_TIMING_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will perform the "spmv_uauz" operation, 
	 * measuring the time elapsed in seconds and writing it in a
	 * user set variable.
         * 
	 * Note that this dispatch function is matrix type indipendent.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_err_t errval = RSB_ERR_NO_ERROR;

	if( ! elapsed_time ) return RSB_ERR_BADARGS;

	*elapsed_time = - rsb_time();
	errval = rsb__do_spmv_uauz	(mtxAp,rhs,out,transA);
	
	*elapsed_time += rsb_time(); 
	return errval;
}

#ifdef RSB_WANT_KERNELS_DEBUG
rsb_err_t rsb__spmv_uxua_testing(const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const void * alphap,const rsb_trans_t transA)
{
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_TESTING_FUNCTION macro */
	/*!
	 * \ingroup gr_debug
	 * This is a trivial reference implementation of the "spmv_uxua" kernel, and 
	 * its numerical results will be used to shed some evidence if bugs 
	 * should be introduced in performance computational kernels.
	 * 
	 * It should be used for debugging or comparing with performance optimized
	 * functions.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	
	register rsb_coo_idx_t baserow = RSB_INI,basecolumn = RSB_INI,rows = RSB_INI,columns = RSB_INI;
	register rsb_coo_idx_t blockrow = RSB_INI,blockcolumn = RSB_INI;
	register rsb_byte_t *bp=0;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!mtxAp /*|| !mtxAp->options*/ )return RSB_ERR_BADARGS;
	{
	RSB_GET_FIRST_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_DOUBLE )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const double* a = (const double*)bp;
		const double* b = ((const double*)rhs)+mtxAp->cpntr[blockcolumn];
		double* c = ((double*)out)+mtxAp->rpntr[blockrow];
		rsb_coo_idx_t i,j;
		c=c;/* here just to prevent from compiler warning */

#if 0
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				c[i]+=a[i*columns+j]*b[j];
#else
		/*
		 * this code will emulate the same kernel order!
		 * it should generate the same numerical roundoff errors the current kernel would
		 * */
		for(i=0;i<rows;++i)
		{
			double rs=0;
			for(j=0;j<columns;++j)
				rs+=a[i*columns+j]*b[j];
;
;
		}
#endif /* 0 */

	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_FLOAT )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const float* a = (const float*)bp;
		const float* b = ((const float*)rhs)+mtxAp->cpntr[blockcolumn];
		float* c = ((float*)out)+mtxAp->rpntr[blockrow];
		rsb_coo_idx_t i,j;
		c=c;/* here just to prevent from compiler warning */

#if 0
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				c[i]+=a[i*columns+j]*b[j];
#else
		/*
		 * this code will emulate the same kernel order!
		 * it should generate the same numerical roundoff errors the current kernel would
		 * */
		for(i=0;i<rows;++i)
		{
			float rs=0;
			for(j=0;j<columns;++j)
				rs+=a[i*columns+j]*b[j];
;
;
		}
#endif /* 0 */

	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_FLOAT_COMPLEX )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const float complex* a = (const float complex*)bp;
		const float complex* b = ((const float complex*)rhs)+mtxAp->cpntr[blockcolumn];
		float complex* c = ((float complex*)out)+mtxAp->rpntr[blockrow];
		rsb_coo_idx_t i,j;
		c=c;/* here just to prevent from compiler warning */

#if 0
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				c[i]+=a[i*columns+j]*b[j];
#else
		/*
		 * this code will emulate the same kernel order!
		 * it should generate the same numerical roundoff errors the current kernel would
		 * */
		for(i=0;i<rows;++i)
		{
			float complex rs=0;
			for(j=0;j<columns;++j)
				rs+=a[i*columns+j]*b[j];
;
;
		}
#endif /* 0 */

	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const double complex* a = (const double complex*)bp;
		const double complex* b = ((const double complex*)rhs)+mtxAp->cpntr[blockcolumn];
		double complex* c = ((double complex*)out)+mtxAp->rpntr[blockrow];
		rsb_coo_idx_t i,j;
		c=c;/* here just to prevent from compiler warning */

#if 0
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				c[i]+=a[i*columns+j]*b[j];
#else
		/*
		 * this code will emulate the same kernel order!
		 * it should generate the same numerical roundoff errors the current kernel would
		 * */
		for(i=0;i<rows;++i)
		{
			double complex rs=0;
			for(j=0;j<columns;++j)
				rs+=a[i*columns+j]*b[j];
;
;
		}
#endif /* 0 */

	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	{
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		return RSB_ERR_UNSUPPORTED_TYPE	;
	}
	}
	return RSB_ERR_NO_ERROR;	
}
#endif /* RSB_WANT_KERNELS_DEBUG */

rsb_err_t rsb_do_time_spmv_uxua(double * elapsed_time, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const void * alphap,const rsb_trans_t transA)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_TIMING_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will perform the "spmv_uxua" operation, 
	 * measuring the time elapsed in seconds and writing it in a
	 * user set variable.
         * 
	 * Note that this dispatch function is matrix type indipendent.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_err_t errval = RSB_ERR_NO_ERROR;

	if( ! elapsed_time ) return RSB_ERR_BADARGS;

	*elapsed_time = - rsb_time();
	errval = rsb__do_spmv_uxua	(mtxAp,rhs,out,alphap,transA);
	
	*elapsed_time += rsb_time(); 
	return errval;
}

#ifdef RSB_WANT_KERNELS_DEBUG
rsb_err_t rsb__spmv_unua_testing(const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
{
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_TESTING_FUNCTION macro */
	/*!
	 * \ingroup gr_debug
	 * This is a trivial reference implementation of the "spmv_unua" kernel, and 
	 * its numerical results will be used to shed some evidence if bugs 
	 * should be introduced in performance computational kernels.
	 * 
	 * It should be used for debugging or comparing with performance optimized
	 * functions.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	
	register rsb_coo_idx_t baserow = RSB_INI,basecolumn = RSB_INI,rows = RSB_INI,columns = RSB_INI;
	register rsb_coo_idx_t blockrow = RSB_INI,blockcolumn = RSB_INI;
	register rsb_byte_t *bp=0;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!mtxAp /*|| !mtxAp->options*/ )return RSB_ERR_BADARGS;
	{
	RSB_GET_FIRST_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_DOUBLE )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const double* a = (const double*)bp;
		const double* b = ((const double*)rhs)+mtxAp->cpntr[blockcolumn];
		double* c = ((double*)out)+mtxAp->rpntr[blockrow];
		rsb_coo_idx_t i,j;
		c=c;/* here just to prevent from compiler warning */

#if 0
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				c[i]+=a[i*columns+j]*b[j];
#else
		/*
		 * this code will emulate the same kernel order!
		 * it should generate the same numerical roundoff errors the current kernel would
		 * */
		for(i=0;i<rows;++i)
		{
			double rs=0;
			for(j=0;j<columns;++j)
				rs+=a[i*columns+j]*b[j];
;
			c[i]-=rs;
;
		}
#endif /* 0 */

	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_FLOAT )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const float* a = (const float*)bp;
		const float* b = ((const float*)rhs)+mtxAp->cpntr[blockcolumn];
		float* c = ((float*)out)+mtxAp->rpntr[blockrow];
		rsb_coo_idx_t i,j;
		c=c;/* here just to prevent from compiler warning */

#if 0
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				c[i]+=a[i*columns+j]*b[j];
#else
		/*
		 * this code will emulate the same kernel order!
		 * it should generate the same numerical roundoff errors the current kernel would
		 * */
		for(i=0;i<rows;++i)
		{
			float rs=0;
			for(j=0;j<columns;++j)
				rs+=a[i*columns+j]*b[j];
;
			c[i]-=rs;
;
		}
#endif /* 0 */

	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_FLOAT_COMPLEX )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const float complex* a = (const float complex*)bp;
		const float complex* b = ((const float complex*)rhs)+mtxAp->cpntr[blockcolumn];
		float complex* c = ((float complex*)out)+mtxAp->rpntr[blockrow];
		rsb_coo_idx_t i,j;
		c=c;/* here just to prevent from compiler warning */

#if 0
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				c[i]+=a[i*columns+j]*b[j];
#else
		/*
		 * this code will emulate the same kernel order!
		 * it should generate the same numerical roundoff errors the current kernel would
		 * */
		for(i=0;i<rows;++i)
		{
			float complex rs=0;
			for(j=0;j<columns;++j)
				rs+=a[i*columns+j]*b[j];
;
			c[i]-=rs;
;
		}
#endif /* 0 */

	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const double complex* a = (const double complex*)bp;
		const double complex* b = ((const double complex*)rhs)+mtxAp->cpntr[blockcolumn];
		double complex* c = ((double complex*)out)+mtxAp->rpntr[blockrow];
		rsb_coo_idx_t i,j;
		c=c;/* here just to prevent from compiler warning */

#if 0
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				c[i]+=a[i*columns+j]*b[j];
#else
		/*
		 * this code will emulate the same kernel order!
		 * it should generate the same numerical roundoff errors the current kernel would
		 * */
		for(i=0;i<rows;++i)
		{
			double complex rs=0;
			for(j=0;j<columns;++j)
				rs+=a[i*columns+j]*b[j];
;
			c[i]-=rs;
;
		}
#endif /* 0 */

	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	{
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		return RSB_ERR_UNSUPPORTED_TYPE	;
	}
	}
	return RSB_ERR_NO_ERROR;	
}
#endif /* RSB_WANT_KERNELS_DEBUG */

rsb_err_t rsb_do_time_spmv_unua(double * elapsed_time, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_TIMING_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will perform the "spmv_unua" operation, 
	 * measuring the time elapsed in seconds and writing it in a
	 * user set variable.
         * 
	 * Note that this dispatch function is matrix type indipendent.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_err_t errval = RSB_ERR_NO_ERROR;

	if( ! elapsed_time ) return RSB_ERR_BADARGS;

	*elapsed_time = - rsb_time();
	errval = rsb__do_spmv_unua	(mtxAp,rhs,out,transA);
	
	*elapsed_time += rsb_time(); 
	return errval;
}

#ifdef RSB_WANT_KERNELS_DEBUG
rsb_err_t rsb__spmv_sasa_testing(const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,rsb_coo_idx_t incx, rsb_coo_idx_t incy,const rsb_trans_t transA)
{
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_TESTING_FUNCTION macro */
	/*!
	 * \ingroup gr_debug
	 * This is a trivial reference implementation of the "spmv_sasa" kernel, and 
	 * its numerical results will be used to shed some evidence if bugs 
	 * should be introduced in performance computational kernels.
	 * 
	 * It should be used for debugging or comparing with performance optimized
	 * functions.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	
	register rsb_coo_idx_t baserow = RSB_INI,basecolumn = RSB_INI,rows = RSB_INI,columns = RSB_INI;
	register rsb_coo_idx_t blockrow = RSB_INI,blockcolumn = RSB_INI;
	register rsb_byte_t *bp=0;

	if(!mtxAp /*|| !mtxAp->options*/ )return RSB_ERR_BADARGS;
	{
	RSB_GET_FIRST_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_DOUBLE )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const double* a = (const double*)bp;
		const double* b = ((const double*)rhs)+mtxAp->cpntr[blockcolumn];
		double* c = ((double*)out)+mtxAp->rpntr[blockrow];
		rsb_coo_idx_t i,j;
		c=c;/* here just to prevent from compiler warning */

#if 0
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				c[i]+=a[i*columns+j]*b[j];
#else
		/*
		 * this code will emulate the same kernel order!
		 * it should generate the same numerical roundoff errors the current kernel would
		 * */
		for(i=0;i<rows;++i)
		{
			double rs=0;
			for(j=0;j<columns;++j)
				rs+=a[i*columns+j]*b[j];
;
;
		}
#endif /* 0 */

		
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_FLOAT )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const float* a = (const float*)bp;
		const float* b = ((const float*)rhs)+mtxAp->cpntr[blockcolumn];
		float* c = ((float*)out)+mtxAp->rpntr[blockrow];
		rsb_coo_idx_t i,j;
		c=c;/* here just to prevent from compiler warning */

#if 0
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				c[i]+=a[i*columns+j]*b[j];
#else
		/*
		 * this code will emulate the same kernel order!
		 * it should generate the same numerical roundoff errors the current kernel would
		 * */
		for(i=0;i<rows;++i)
		{
			float rs=0;
			for(j=0;j<columns;++j)
				rs+=a[i*columns+j]*b[j];
;
;
		}
#endif /* 0 */

		
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_FLOAT_COMPLEX )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const float complex* a = (const float complex*)bp;
		const float complex* b = ((const float complex*)rhs)+mtxAp->cpntr[blockcolumn];
		float complex* c = ((float complex*)out)+mtxAp->rpntr[blockrow];
		rsb_coo_idx_t i,j;
		c=c;/* here just to prevent from compiler warning */

#if 0
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				c[i]+=a[i*columns+j]*b[j];
#else
		/*
		 * this code will emulate the same kernel order!
		 * it should generate the same numerical roundoff errors the current kernel would
		 * */
		for(i=0;i<rows;++i)
		{
			float complex rs=0;
			for(j=0;j<columns;++j)
				rs+=a[i*columns+j]*b[j];
;
;
		}
#endif /* 0 */

		
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const double complex* a = (const double complex*)bp;
		const double complex* b = ((const double complex*)rhs)+mtxAp->cpntr[blockcolumn];
		double complex* c = ((double complex*)out)+mtxAp->rpntr[blockrow];
		rsb_coo_idx_t i,j;
		c=c;/* here just to prevent from compiler warning */

#if 0
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				c[i]+=a[i*columns+j]*b[j];
#else
		/*
		 * this code will emulate the same kernel order!
		 * it should generate the same numerical roundoff errors the current kernel would
		 * */
		for(i=0;i<rows;++i)
		{
			double complex rs=0;
			for(j=0;j<columns;++j)
				rs+=a[i*columns+j]*b[j];
;
;
		}
#endif /* 0 */

		
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	{
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		return RSB_ERR_UNSUPPORTED_TYPE	;
	}
	}
	return RSB_ERR_NO_ERROR;	
}
#endif /* RSB_WANT_KERNELS_DEBUG */

rsb_err_t rsb_do_time_spmv_sasa(double * elapsed_time, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,rsb_coo_idx_t incx, rsb_coo_idx_t incy,const rsb_trans_t transA)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_TIMING_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will perform the "spmv_sasa" operation, 
	 * measuring the time elapsed in seconds and writing it in a
	 * user set variable.
         * 
	 * Note that this dispatch function is matrix type indipendent.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_err_t errval = RSB_ERR_NO_ERROR;

	if( ! elapsed_time ) return RSB_ERR_BADARGS;

	*elapsed_time = - rsb_time();
	errval = rsb__do_spmv_sasa	(mtxAp,rhs,out,incx,incy,transA);
	
	*elapsed_time += rsb_time(); 
	return errval;
}

#ifdef RSB_WANT_KERNELS_DEBUG
rsb_err_t rsb__spsv_uxua_testing(const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
{
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_TESTING_FUNCTION macro */
	/*!
	 * \ingroup gr_debug
	 * This is a trivial reference implementation of the "spsv_uxua" kernel, and 
	 * its numerical results will be used to shed some evidence if bugs 
	 * should be introduced in performance computational kernels.
	 * 
	 * It should be used for debugging or comparing with performance optimized
	 * functions.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	
	register rsb_coo_idx_t baserow = RSB_INI,basecolumn = RSB_INI,rows = RSB_INI,columns = RSB_INI;
	register rsb_coo_idx_t blockrow = RSB_INI,blockcolumn = RSB_INI;
	register rsb_byte_t *bp=0;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!mtxAp /*|| !mtxAp->options*/ )return RSB_ERR_BADARGS;
	{
	RSB_GET_FIRST_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_DOUBLE )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
/*	FIXME : UNFINISHED */
	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_FLOAT )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
/*	FIXME : UNFINISHED */
	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_FLOAT_COMPLEX )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
/*	FIXME : UNFINISHED */
	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
/*	FIXME : UNFINISHED */
	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	{
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		return RSB_ERR_UNSUPPORTED_TYPE	;
	}
	}
	return RSB_ERR_NO_ERROR;	
}
#endif /* RSB_WANT_KERNELS_DEBUG */

rsb_err_t rsb_do_time_spsv_uxua(double * elapsed_time, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_TIMING_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will perform the "spsv_uxua" operation, 
	 * measuring the time elapsed in seconds and writing it in a
	 * user set variable.
         * 
	 * Note that this dispatch function is matrix type indipendent.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_err_t errval = RSB_ERR_NO_ERROR;

	if( ! elapsed_time ) return RSB_ERR_BADARGS;

	*elapsed_time = - rsb_time();
	errval = rsb__do_spsv_uxua	(mtxAp,rhs,out,transA);
	
	*elapsed_time += rsb_time(); 
	return errval;
}

#ifdef RSB_WANT_KERNELS_DEBUG
rsb_err_t rsb__spmv_sxsa_testing(const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const void * alphap,rsb_coo_idx_t incx, rsb_coo_idx_t incy,const rsb_trans_t transA)
{
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_TESTING_FUNCTION macro */
	/*!
	 * \ingroup gr_debug
	 * This is a trivial reference implementation of the "spmv_sxsa" kernel, and 
	 * its numerical results will be used to shed some evidence if bugs 
	 * should be introduced in performance computational kernels.
	 * 
	 * It should be used for debugging or comparing with performance optimized
	 * functions.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	
	register rsb_coo_idx_t baserow = RSB_INI,basecolumn = RSB_INI,rows = RSB_INI,columns = RSB_INI;
	register rsb_coo_idx_t blockrow = RSB_INI,blockcolumn = RSB_INI;
	register rsb_byte_t *bp=0;

	if(!mtxAp /*|| !mtxAp->options*/ )return RSB_ERR_BADARGS;
	{
	RSB_GET_FIRST_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_DOUBLE )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const double* a = (const double*)bp;
		const double* b = ((const double*)rhs)+mtxAp->cpntr[blockcolumn];
		double* c = ((double*)out)+mtxAp->rpntr[blockrow];
		rsb_coo_idx_t i,j;
		c=c;/* here just to prevent from compiler warning */

#if 0
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				c[i]+=a[i*columns+j]*b[j];
#else
		/*
		 * this code will emulate the same kernel order!
		 * it should generate the same numerical roundoff errors the current kernel would
		 * */
		for(i=0;i<rows;++i)
		{
			double rs=0;
			for(j=0;j<columns;++j)
				rs+=a[i*columns+j]*b[j];
;
;
		}
#endif /* 0 */

		
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_FLOAT )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const float* a = (const float*)bp;
		const float* b = ((const float*)rhs)+mtxAp->cpntr[blockcolumn];
		float* c = ((float*)out)+mtxAp->rpntr[blockrow];
		rsb_coo_idx_t i,j;
		c=c;/* here just to prevent from compiler warning */

#if 0
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				c[i]+=a[i*columns+j]*b[j];
#else
		/*
		 * this code will emulate the same kernel order!
		 * it should generate the same numerical roundoff errors the current kernel would
		 * */
		for(i=0;i<rows;++i)
		{
			float rs=0;
			for(j=0;j<columns;++j)
				rs+=a[i*columns+j]*b[j];
;
;
		}
#endif /* 0 */

		
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_FLOAT_COMPLEX )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const float complex* a = (const float complex*)bp;
		const float complex* b = ((const float complex*)rhs)+mtxAp->cpntr[blockcolumn];
		float complex* c = ((float complex*)out)+mtxAp->rpntr[blockrow];
		rsb_coo_idx_t i,j;
		c=c;/* here just to prevent from compiler warning */

#if 0
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				c[i]+=a[i*columns+j]*b[j];
#else
		/*
		 * this code will emulate the same kernel order!
		 * it should generate the same numerical roundoff errors the current kernel would
		 * */
		for(i=0;i<rows;++i)
		{
			float complex rs=0;
			for(j=0;j<columns;++j)
				rs+=a[i*columns+j]*b[j];
;
;
		}
#endif /* 0 */

		
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const double complex* a = (const double complex*)bp;
		const double complex* b = ((const double complex*)rhs)+mtxAp->cpntr[blockcolumn];
		double complex* c = ((double complex*)out)+mtxAp->rpntr[blockrow];
		rsb_coo_idx_t i,j;
		c=c;/* here just to prevent from compiler warning */

#if 0
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				c[i]+=a[i*columns+j]*b[j];
#else
		/*
		 * this code will emulate the same kernel order!
		 * it should generate the same numerical roundoff errors the current kernel would
		 * */
		for(i=0;i<rows;++i)
		{
			double complex rs=0;
			for(j=0;j<columns;++j)
				rs+=a[i*columns+j]*b[j];
;
;
		}
#endif /* 0 */

		
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	{
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		return RSB_ERR_UNSUPPORTED_TYPE	;
	}
	}
	return RSB_ERR_NO_ERROR;	
}
#endif /* RSB_WANT_KERNELS_DEBUG */

rsb_err_t rsb_do_time_spmv_sxsa(double * elapsed_time, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const void * alphap,rsb_coo_idx_t incx, rsb_coo_idx_t incy,const rsb_trans_t transA)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_TIMING_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will perform the "spmv_sxsa" operation, 
	 * measuring the time elapsed in seconds and writing it in a
	 * user set variable.
         * 
	 * Note that this dispatch function is matrix type indipendent.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_err_t errval = RSB_ERR_NO_ERROR;

	if( ! elapsed_time ) return RSB_ERR_BADARGS;

	*elapsed_time = - rsb_time();
	errval = rsb__do_spmv_sxsa	(mtxAp,rhs,out,alphap,incx,incy,transA);
	
	*elapsed_time += rsb_time(); 
	return errval;
}

#ifdef RSB_WANT_KERNELS_DEBUG
rsb_err_t rsb__spsv_sxsx_testing(const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const void * alphap,rsb_coo_idx_t incx, rsb_coo_idx_t incy,const rsb_trans_t transA)
{
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_TESTING_FUNCTION macro */
	/*!
	 * \ingroup gr_debug
	 * This is a trivial reference implementation of the "spsv_sxsx" kernel, and 
	 * its numerical results will be used to shed some evidence if bugs 
	 * should be introduced in performance computational kernels.
	 * 
	 * It should be used for debugging or comparing with performance optimized
	 * functions.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	
	register rsb_coo_idx_t baserow = RSB_INI,basecolumn = RSB_INI,rows = RSB_INI,columns = RSB_INI;
	register rsb_coo_idx_t blockrow = RSB_INI,blockcolumn = RSB_INI;
	register rsb_byte_t *bp=0;

	if(!mtxAp /*|| !mtxAp->options*/ )return RSB_ERR_BADARGS;
	{
	RSB_GET_FIRST_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_DOUBLE )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
/*	FIXME : UNFINISHED */
		
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_FLOAT )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
/*	FIXME : UNFINISHED */
		
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_FLOAT_COMPLEX )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
/*	FIXME : UNFINISHED */
		
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
/*	FIXME : UNFINISHED */
		
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	{
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		return RSB_ERR_UNSUPPORTED_TYPE	;
	}
	}
	return RSB_ERR_NO_ERROR;	
}
#endif /* RSB_WANT_KERNELS_DEBUG */

rsb_err_t rsb_do_time_spsv_sxsx(double * elapsed_time, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const void * alphap,rsb_coo_idx_t incx, rsb_coo_idx_t incy,const rsb_trans_t transA)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_TIMING_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will perform the "spsv_sxsx" operation, 
	 * measuring the time elapsed in seconds and writing it in a
	 * user set variable.
         * 
	 * Note that this dispatch function is matrix type indipendent.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_err_t errval = RSB_ERR_NO_ERROR;

	if( ! elapsed_time ) return RSB_ERR_BADARGS;

	*elapsed_time = - rsb_time();
	errval = rsb__do_spsv_sxsx	(mtxAp,rhs,out,alphap,incx,incy,transA);
	
	*elapsed_time += rsb_time(); 
	return errval;
}

#ifdef RSB_WANT_KERNELS_DEBUG
rsb_err_t rsb__infty_norm_testing(const struct rsb_mtx_t * mtxAp,const rsb_trans_t transA,void * row_sums)
{
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_TESTING_FUNCTION macro */
	/*!
	 * \ingroup gr_debug
	 * This is a trivial reference implementation of the "infty_norm" kernel, and 
	 * its numerical results will be used to shed some evidence if bugs 
	 * should be introduced in performance computational kernels.
	 * 
	 * It should be used for debugging or comparing with performance optimized
	 * functions.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	
	register rsb_coo_idx_t baserow = RSB_INI,basecolumn = RSB_INI,rows = RSB_INI,columns = RSB_INI;
	register rsb_coo_idx_t blockrow = RSB_INI,blockcolumn = RSB_INI;
	register rsb_byte_t *bp=0;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!mtxAp /*|| !mtxAp->options*/ )return RSB_ERR_BADARGS;
	{
	RSB_GET_FIRST_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_DOUBLE )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const double* a = (const double*)bp;
		double* row_sums_=row_sums;
		rsb_coo_idx_t i,j;
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				row_sums_[mtxAp->rpntr[blockrow]+i]+=fabs(a[i*columns+j]);
	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_FLOAT )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const float* a = (const float*)bp;
		float* row_sums_=row_sums;
		rsb_coo_idx_t i,j;
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				row_sums_[mtxAp->rpntr[blockrow]+i]+=fabsf(a[i*columns+j]);
	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_FLOAT_COMPLEX )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const float complex* a = (const float complex*)bp;
		float complex* row_sums_=row_sums;
		rsb_coo_idx_t i,j;
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				row_sums_[mtxAp->rpntr[blockrow]+i]+=cabsf(a[i*columns+j]);
	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const double complex* a = (const double complex*)bp;
		double complex* row_sums_=row_sums;
		rsb_coo_idx_t i,j;
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				row_sums_[mtxAp->rpntr[blockrow]+i]+=cabs(a[i*columns+j]);
	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	{
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		return RSB_ERR_UNSUPPORTED_TYPE	;
	}
	}
	return RSB_ERR_NO_ERROR;	
}
#endif /* RSB_WANT_KERNELS_DEBUG */

rsb_err_t rsb_do_time_infty_norm(double * elapsed_time, const struct rsb_mtx_t * mtxAp,const rsb_trans_t transA,void * row_sums)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_TIMING_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will perform the "infty_norm" operation, 
	 * measuring the time elapsed in seconds and writing it in a
	 * user set variable.
         * 
	 * Note that this dispatch function is matrix type indipendent.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_err_t errval = RSB_ERR_NO_ERROR;

	if( ! elapsed_time ) return RSB_ERR_BADARGS;

	*elapsed_time = - rsb_time();
	errval = rsb__do_infty_norm	(mtxAp,transA,row_sums);
	
	*elapsed_time += rsb_time(); 
	return errval;
}

#ifdef RSB_WANT_KERNELS_DEBUG
rsb_err_t rsb__rowssums_testing(const struct rsb_mtx_t * mtxAp,const rsb_trans_t transA,void * row_sums)
{
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_TESTING_FUNCTION macro */
	/*!
	 * \ingroup gr_debug
	 * This is a trivial reference implementation of the "rowssums" kernel, and 
	 * its numerical results will be used to shed some evidence if bugs 
	 * should be introduced in performance computational kernels.
	 * 
	 * It should be used for debugging or comparing with performance optimized
	 * functions.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	
	register rsb_coo_idx_t baserow = RSB_INI,basecolumn = RSB_INI,rows = RSB_INI,columns = RSB_INI;
	register rsb_coo_idx_t blockrow = RSB_INI,blockcolumn = RSB_INI;
	register rsb_byte_t *bp=0;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!mtxAp /*|| !mtxAp->options*/ )return RSB_ERR_BADARGS;
	{
	RSB_GET_FIRST_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_DOUBLE )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const double* a = (const double*)bp;
		double* row_sums_=row_sums;
		rsb_coo_idx_t i,j;
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				row_sums_[mtxAp->rpntr[blockrow]+i]+=a[i*columns+j];
	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_FLOAT )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const float* a = (const float*)bp;
		float* row_sums_=row_sums;
		rsb_coo_idx_t i,j;
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				row_sums_[mtxAp->rpntr[blockrow]+i]+=a[i*columns+j];
	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_FLOAT_COMPLEX )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const float complex* a = (const float complex*)bp;
		float complex* row_sums_=row_sums;
		rsb_coo_idx_t i,j;
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				row_sums_[mtxAp->rpntr[blockrow]+i]+=a[i*columns+j];
	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		const double complex* a = (const double complex*)bp;
		double complex* row_sums_=row_sums;
		rsb_coo_idx_t i,j;
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				row_sums_[mtxAp->rpntr[blockrow]+i]+=a[i*columns+j];
	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	{
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		return RSB_ERR_UNSUPPORTED_TYPE	;
	}
	}
	return RSB_ERR_NO_ERROR;	
}
#endif /* RSB_WANT_KERNELS_DEBUG */

rsb_err_t rsb_do_time_rowssums(double * elapsed_time, const struct rsb_mtx_t * mtxAp,const rsb_trans_t transA,void * row_sums)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_TIMING_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will perform the "rowssums" operation, 
	 * measuring the time elapsed in seconds and writing it in a
	 * user set variable.
         * 
	 * Note that this dispatch function is matrix type indipendent.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_err_t errval = RSB_ERR_NO_ERROR;

	if( ! elapsed_time ) return RSB_ERR_BADARGS;

	*elapsed_time = - rsb_time();
	errval = rsb__do_rowssums	(mtxAp,transA,row_sums);
	
	*elapsed_time += rsb_time(); 
	return errval;
}

#ifdef RSB_WANT_KERNELS_DEBUG
rsb_err_t rsb__scale_testing(struct rsb_mtx_t * mtxAp,const rsb_trans_t transA,const void * scale_factors)
{
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_TESTING_FUNCTION macro */
	/*!
	 * \ingroup gr_debug
	 * This is a trivial reference implementation of the "scale" kernel, and 
	 * its numerical results will be used to shed some evidence if bugs 
	 * should be introduced in performance computational kernels.
	 * 
	 * It should be used for debugging or comparing with performance optimized
	 * functions.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	
	register rsb_coo_idx_t baserow = RSB_INI,basecolumn = RSB_INI,rows = RSB_INI,columns = RSB_INI;
	register rsb_coo_idx_t blockrow = RSB_INI,blockcolumn = RSB_INI;
	register rsb_byte_t *bp=0;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!mtxAp /*|| !mtxAp->options*/ )return RSB_ERR_BADARGS;
	{
	RSB_GET_FIRST_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_DOUBLE )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		double* a = (double*)bp;
		rsb_coo_idx_t i,j;
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				a[i*columns+j]*=((const double*)scale_factors)[i];
	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_FLOAT )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		float* a = (float*)bp;
		rsb_coo_idx_t i,j;
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				a[i*columns+j]*=((const float*)scale_factors)[i];
	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_FLOAT_COMPLEX )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		float complex* a = (float complex*)bp;
		rsb_coo_idx_t i,j;
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				a[i*columns+j]*=((const float complex*)scale_factors)[i];
	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	if(mtxAp->typecode == RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX )
	{

	
	while(!RSB_GOT_LAST_BLOCK_POINTER(mtxAp))
	{
		double complex* a = (double complex*)bp;
		rsb_coo_idx_t i,j;
		for(i=0;i<rows;++i)
			for(j=0;j<columns;++j)
				a[i*columns+j]*=((const double complex*)scale_factors)[i];
	
		RSB_GET_NEXT_BLOCK_POINTER(bp,mtxAp,baserow,basecolumn,rows,columns,blockrow,blockcolumn);
	}
	}
	else
	{
		RSB_ERROR("Sorry, data type \"%c\" currently not supported.\n",mtxAp->typecode);
		return RSB_ERR_UNSUPPORTED_TYPE	;
	}
	}
	return RSB_ERR_NO_ERROR;	
}
#endif /* RSB_WANT_KERNELS_DEBUG */

rsb_err_t rsb_do_time_scale(double * elapsed_time, struct rsb_mtx_t * mtxAp,const rsb_trans_t transA,const void * scale_factors)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_TIMING_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will perform the "scale" operation, 
	 * measuring the time elapsed in seconds and writing it in a
	 * user set variable.
         * 
	 * Note that this dispatch function is matrix type indipendent.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_err_t errval = RSB_ERR_NO_ERROR;

	if( ! elapsed_time ) return RSB_ERR_BADARGS;

	*elapsed_time = - rsb_time();
	errval = rsb__do_scale	(mtxAp,transA,scale_factors);
	
	*elapsed_time += rsb_time(); 
	return errval;
}


rsb_err_t rsb__do_fullrangebenchmark_double_spmv_uaua(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "double" type implementation of operation "spmv_uaua" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_DOUBLE ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	double *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_double_spmv_uaua( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_double_spmv_uaua(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spmv_uaua" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spmv_uaua(&elapsed_time,mtxAp,rhs,out,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spmv_uaua(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spmv_uaua",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spmv_uaua,double) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_float_spmv_uaua(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "float" type implementation of operation "spmv_uaua" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_FLOAT ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	float *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_float_spmv_uaua( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_float_spmv_uaua(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spmv_uaua" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spmv_uaua(&elapsed_time,mtxAp,rhs,out,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spmv_uaua(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spmv_uaua",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spmv_uaua,float) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_float_complex_spmv_uaua(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "float complex" type implementation of operation "spmv_uaua" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	float complex *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_float_complex_spmv_uaua( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_float_complex_spmv_uaua(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spmv_uaua" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spmv_uaua(&elapsed_time,mtxAp,rhs,out,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spmv_uaua(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spmv_uaua",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spmv_uaua,float complex) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_double_complex_spmv_uaua(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "double complex" type implementation of operation "spmv_uaua" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	double complex *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_double_complex_spmv_uaua( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_double_complex_spmv_uaua(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spmv_uaua" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spmv_uaua(&elapsed_time,mtxAp,rhs,out,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spmv_uaua(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spmv_uaua",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spmv_uaua,double complex) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_double_spmv_uauz(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "double" type implementation of operation "spmv_uauz" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_DOUBLE ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	double *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_double_spmv_uauz( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_double_spmv_uauz(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spmv_uauz" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spmv_uauz(&elapsed_time,mtxAp,rhs,out,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spmv_uauz(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spmv_uauz",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spmv_uauz,double) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_float_spmv_uauz(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "float" type implementation of operation "spmv_uauz" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_FLOAT ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	float *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_float_spmv_uauz( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_float_spmv_uauz(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spmv_uauz" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spmv_uauz(&elapsed_time,mtxAp,rhs,out,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spmv_uauz(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spmv_uauz",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spmv_uauz,float) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_float_complex_spmv_uauz(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "float complex" type implementation of operation "spmv_uauz" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	float complex *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_float_complex_spmv_uauz( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_float_complex_spmv_uauz(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spmv_uauz" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spmv_uauz(&elapsed_time,mtxAp,rhs,out,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spmv_uauz(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spmv_uauz",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spmv_uauz,float complex) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_double_complex_spmv_uauz(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "double complex" type implementation of operation "spmv_uauz" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	double complex *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_double_complex_spmv_uauz( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_double_complex_spmv_uauz(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spmv_uauz" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spmv_uauz(&elapsed_time,mtxAp,rhs,out,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spmv_uauz(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spmv_uauz",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spmv_uauz,double complex) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_double_spmv_uxua(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "double" type implementation of operation "spmv_uxua" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_DOUBLE ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	double *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			double alpha=1.0;/* FIXME */
			double * alphap = &alpha;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_double_spmv_uxua( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,alphap,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_double_spmv_uxua(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const void * alphap,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spmv_uxua" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spmv_uxua(&elapsed_time,mtxAp,rhs,out,alphap,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spmv_uxua(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spmv_uxua",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spmv_uxua,double) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_float_spmv_uxua(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "float" type implementation of operation "spmv_uxua" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_FLOAT ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	float *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			double alpha=1.0;/* FIXME */
			double * alphap = &alpha;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_float_spmv_uxua( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,alphap,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_float_spmv_uxua(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const void * alphap,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spmv_uxua" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spmv_uxua(&elapsed_time,mtxAp,rhs,out,alphap,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spmv_uxua(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spmv_uxua",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spmv_uxua,float) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_float_complex_spmv_uxua(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "float complex" type implementation of operation "spmv_uxua" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	float complex *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			double alpha=1.0;/* FIXME */
			double * alphap = &alpha;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_float_complex_spmv_uxua( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,alphap,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_float_complex_spmv_uxua(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const void * alphap,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spmv_uxua" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spmv_uxua(&elapsed_time,mtxAp,rhs,out,alphap,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spmv_uxua(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spmv_uxua",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spmv_uxua,float complex) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_double_complex_spmv_uxua(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "double complex" type implementation of operation "spmv_uxua" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	double complex *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			double alpha=1.0;/* FIXME */
			double * alphap = &alpha;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_double_complex_spmv_uxua( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,alphap,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_double_complex_spmv_uxua(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const void * alphap,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spmv_uxua" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spmv_uxua(&elapsed_time,mtxAp,rhs,out,alphap,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spmv_uxua(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spmv_uxua",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spmv_uxua,double complex) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_double_spmv_unua(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "double" type implementation of operation "spmv_unua" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_DOUBLE ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	double *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_double_spmv_unua( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_double_spmv_unua(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spmv_unua" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spmv_unua(&elapsed_time,mtxAp,rhs,out,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spmv_unua(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spmv_unua",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spmv_unua,double) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_float_spmv_unua(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "float" type implementation of operation "spmv_unua" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_FLOAT ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	float *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_float_spmv_unua( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_float_spmv_unua(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spmv_unua" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spmv_unua(&elapsed_time,mtxAp,rhs,out,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spmv_unua(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spmv_unua",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spmv_unua,float) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_float_complex_spmv_unua(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "float complex" type implementation of operation "spmv_unua" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	float complex *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_float_complex_spmv_unua( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_float_complex_spmv_unua(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spmv_unua" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spmv_unua(&elapsed_time,mtxAp,rhs,out,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spmv_unua(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spmv_unua",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spmv_unua,float complex) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_double_complex_spmv_unua(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "double complex" type implementation of operation "spmv_unua" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	double complex *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_double_complex_spmv_unua( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_double_complex_spmv_unua(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spmv_unua" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spmv_unua(&elapsed_time,mtxAp,rhs,out,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spmv_unua(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spmv_unua",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spmv_unua,double complex) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_double_spmv_sasa(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "double" type implementation of operation "spmv_sasa" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_DOUBLE ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	double *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_double_spmv_sasa( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,incx,incy,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_double_spmv_sasa(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,rsb_coo_idx_t incx, rsb_coo_idx_t incy,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spmv_sasa" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spmv_sasa(&elapsed_time,mtxAp,rhs,out,incx,incy,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spmv_sasa(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spmv_sasa",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spmv_sasa,double) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_float_spmv_sasa(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "float" type implementation of operation "spmv_sasa" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_FLOAT ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	float *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_float_spmv_sasa( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,incx,incy,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_float_spmv_sasa(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,rsb_coo_idx_t incx, rsb_coo_idx_t incy,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spmv_sasa" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spmv_sasa(&elapsed_time,mtxAp,rhs,out,incx,incy,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spmv_sasa(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spmv_sasa",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spmv_sasa,float) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_float_complex_spmv_sasa(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "float complex" type implementation of operation "spmv_sasa" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	float complex *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_float_complex_spmv_sasa( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,incx,incy,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_float_complex_spmv_sasa(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,rsb_coo_idx_t incx, rsb_coo_idx_t incy,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spmv_sasa" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spmv_sasa(&elapsed_time,mtxAp,rhs,out,incx,incy,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spmv_sasa(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spmv_sasa",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spmv_sasa,float complex) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_double_complex_spmv_sasa(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "double complex" type implementation of operation "spmv_sasa" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	double complex *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_double_complex_spmv_sasa( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,incx,incy,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_double_complex_spmv_sasa(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,rsb_coo_idx_t incx, rsb_coo_idx_t incy,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spmv_sasa" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spmv_sasa(&elapsed_time,mtxAp,rhs,out,incx,incy,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spmv_sasa(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spmv_sasa",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spmv_sasa,double complex) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_double_spsv_uxua(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "double" type implementation of operation "spsv_uxua" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_DOUBLE ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	double *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_double_spsv_uxua( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_double_spsv_uxua(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spsv_uxua" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spsv_uxua(&elapsed_time,mtxAp,rhs,out,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spsv_uxua(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spsv_uxua",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spsv_uxua,double) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_float_spsv_uxua(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "float" type implementation of operation "spsv_uxua" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_FLOAT ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	float *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_float_spsv_uxua( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_float_spsv_uxua(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spsv_uxua" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spsv_uxua(&elapsed_time,mtxAp,rhs,out,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spsv_uxua(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spsv_uxua",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spsv_uxua,float) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_float_complex_spsv_uxua(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "float complex" type implementation of operation "spsv_uxua" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	float complex *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_float_complex_spsv_uxua( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_float_complex_spsv_uxua(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spsv_uxua" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spsv_uxua(&elapsed_time,mtxAp,rhs,out,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spsv_uxua(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spsv_uxua",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spsv_uxua,float complex) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_double_complex_spsv_uxua(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "double complex" type implementation of operation "spsv_uxua" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	double complex *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_double_complex_spsv_uxua( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_double_complex_spsv_uxua(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spsv_uxua" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spsv_uxua(&elapsed_time,mtxAp,rhs,out,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spsv_uxua(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spsv_uxua",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spsv_uxua,double complex) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_double_spmv_sxsa(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "double" type implementation of operation "spmv_sxsa" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_DOUBLE ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	double *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			double alpha=1.0;/* FIXME */
			double * alphap = &alpha;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_double_spmv_sxsa( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,alphap,incx,incy,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_double_spmv_sxsa(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const void * alphap,rsb_coo_idx_t incx, rsb_coo_idx_t incy,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spmv_sxsa" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spmv_sxsa(&elapsed_time,mtxAp,rhs,out,alphap,incx,incy,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spmv_sxsa(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spmv_sxsa",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spmv_sxsa,double) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_float_spmv_sxsa(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "float" type implementation of operation "spmv_sxsa" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_FLOAT ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	float *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			double alpha=1.0;/* FIXME */
			double * alphap = &alpha;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_float_spmv_sxsa( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,alphap,incx,incy,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_float_spmv_sxsa(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const void * alphap,rsb_coo_idx_t incx, rsb_coo_idx_t incy,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spmv_sxsa" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spmv_sxsa(&elapsed_time,mtxAp,rhs,out,alphap,incx,incy,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spmv_sxsa(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spmv_sxsa",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spmv_sxsa,float) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_float_complex_spmv_sxsa(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "float complex" type implementation of operation "spmv_sxsa" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	float complex *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			double alpha=1.0;/* FIXME */
			double * alphap = &alpha;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_float_complex_spmv_sxsa( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,alphap,incx,incy,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_float_complex_spmv_sxsa(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const void * alphap,rsb_coo_idx_t incx, rsb_coo_idx_t incy,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spmv_sxsa" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spmv_sxsa(&elapsed_time,mtxAp,rhs,out,alphap,incx,incy,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spmv_sxsa(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spmv_sxsa",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spmv_sxsa,float complex) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_double_complex_spmv_sxsa(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "double complex" type implementation of operation "spmv_sxsa" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	double complex *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			double alpha=1.0;/* FIXME */
			double * alphap = &alpha;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_double_complex_spmv_sxsa( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,alphap,incx,incy,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_double_complex_spmv_sxsa(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const void * alphap,rsb_coo_idx_t incx, rsb_coo_idx_t incy,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spmv_sxsa" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spmv_sxsa(&elapsed_time,mtxAp,rhs,out,alphap,incx,incy,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spmv_sxsa(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spmv_sxsa",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spmv_sxsa,double complex) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_double_spsv_sxsx(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "double" type implementation of operation "spsv_sxsx" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_DOUBLE ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	double *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			double alpha=1.0;/* FIXME */
			double * alphap = &alpha;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_double_spsv_sxsx( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,alphap,incx,incy,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_double_spsv_sxsx(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const void * alphap,rsb_coo_idx_t incx, rsb_coo_idx_t incy,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spsv_sxsx" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spsv_sxsx(&elapsed_time,mtxAp,rhs,out,alphap,incx,incy,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spsv_sxsx(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spsv_sxsx",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spsv_sxsx,double) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_float_spsv_sxsx(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "float" type implementation of operation "spsv_sxsx" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_FLOAT ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	float *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			double alpha=1.0;/* FIXME */
			double * alphap = &alpha;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_float_spsv_sxsx( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,alphap,incx,incy,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_float_spsv_sxsx(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const void * alphap,rsb_coo_idx_t incx, rsb_coo_idx_t incy,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spsv_sxsx" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spsv_sxsx(&elapsed_time,mtxAp,rhs,out,alphap,incx,incy,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spsv_sxsx(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spsv_sxsx",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spsv_sxsx,float) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_float_complex_spsv_sxsx(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "float complex" type implementation of operation "spsv_sxsx" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	float complex *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			double alpha=1.0;/* FIXME */
			double * alphap = &alpha;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_float_complex_spsv_sxsx( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,alphap,incx,incy,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_float_complex_spsv_sxsx(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const void * alphap,rsb_coo_idx_t incx, rsb_coo_idx_t incy,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spsv_sxsx" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spsv_sxsx(&elapsed_time,mtxAp,rhs,out,alphap,incx,incy,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spsv_sxsx(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spsv_sxsx",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spsv_sxsx,float complex) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_double_complex_spsv_sxsx(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "double complex" type implementation of operation "spsv_sxsx" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	double complex *out=NULL,*rhs=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			rsb_coo_idx_t bstride = 0;
			rsb_coo_idx_t cstride = 0;
			rsb_coo_idx_t nrhs=1;
			double alpha=1.0;/* FIXME */
			double * alphap = &alpha;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			bstride=cols+bc;
			cstride = rows+br;
			rhs = rsb__malloc(mtxAp->el_size*(bstride)*nrhs);
			out = rsb__malloc(mtxAp->el_size*(cstride)*nrhs);
			if(!out || rsb__fill_with_ones(out,mtxAp->typecode,cstride*nrhs,incy)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!rhs || rsb__fill_with_ones(rhs,mtxAp->typecode,bstride*nrhs,incx)){errval = RSB_ERR_ENOMEM;goto erri;}
			if(!out || !rhs) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(rhs,mtxAp->typecode,(cols)*nrhs,cols))     {errval = RSB_ERR_ENOMEM;goto erri;}
			/* FIXME : are we sure this is correct ?*/
			if(rsb__cblas_Xscal(mtxAp->typecode,(rows+br)*nrhs,NULL,out,incy)) {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_double_complex_spsv_sxsx( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,rhs,out,alphap,incx,incy,transA);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(out);
			RSB_CONDITIONAL_FREE(rhs);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_double_complex_spsv_sxsx(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const void * alphap,rsb_coo_idx_t incx, rsb_coo_idx_t incy,const rsb_trans_t transA)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "spsv_sxsx" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_spsv_sxsx(&elapsed_time,mtxAp,rhs,out,alphap,incx,incy,transA);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_spsv_sxsx(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"spsv_sxsx",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (spsv_sxsx,double complex) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_double_infty_norm(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "double" type implementation of operation "infty_norm" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_DOUBLE ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	double * row_sums=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			row_sums = rsb__malloc(mtxAp->el_size*(rows+br));
			if(!row_sums) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(row_sums,mtxAp->typecode,cols,1))     {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_double_infty_norm( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,transA,row_sums);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(row_sums);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_double_infty_norm(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const rsb_trans_t transA,void * row_sums)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "infty_norm" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_infty_norm(&elapsed_time,mtxAp,transA,row_sums);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_infty_norm(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"infty_norm",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (infty_norm,double) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_float_infty_norm(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "float" type implementation of operation "infty_norm" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_FLOAT ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	float * row_sums=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			row_sums = rsb__malloc(mtxAp->el_size*(rows+br));
			if(!row_sums) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(row_sums,mtxAp->typecode,cols,1))     {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_float_infty_norm( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,transA,row_sums);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(row_sums);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_float_infty_norm(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const rsb_trans_t transA,void * row_sums)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "infty_norm" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_infty_norm(&elapsed_time,mtxAp,transA,row_sums);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_infty_norm(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"infty_norm",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (infty_norm,float) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_float_complex_infty_norm(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "float complex" type implementation of operation "infty_norm" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	float complex * row_sums=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			row_sums = rsb__malloc(mtxAp->el_size*(rows+br));
			if(!row_sums) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(row_sums,mtxAp->typecode,cols,1))     {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_float_complex_infty_norm( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,transA,row_sums);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(row_sums);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_float_complex_infty_norm(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const rsb_trans_t transA,void * row_sums)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "infty_norm" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_infty_norm(&elapsed_time,mtxAp,transA,row_sums);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_infty_norm(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"infty_norm",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (infty_norm,float complex) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_double_complex_infty_norm(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "double complex" type implementation of operation "infty_norm" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	double complex * row_sums=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			row_sums = rsb__malloc(mtxAp->el_size*(rows+br));
			if(!row_sums) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(row_sums,mtxAp->typecode,cols,1))     {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_double_complex_infty_norm( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,transA,row_sums);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(row_sums);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_double_complex_infty_norm(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const rsb_trans_t transA,void * row_sums)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "infty_norm" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_infty_norm(&elapsed_time,mtxAp,transA,row_sums);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_infty_norm(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"infty_norm",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (infty_norm,double complex) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_double_rowssums(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "double" type implementation of operation "rowssums" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_DOUBLE ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	double * row_sums=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			row_sums = rsb__malloc(mtxAp->el_size*(rows+br));
			if(!row_sums) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(row_sums,mtxAp->typecode,cols,1))     {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_double_rowssums( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,transA,row_sums);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(row_sums);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_double_rowssums(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const rsb_trans_t transA,void * row_sums)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "rowssums" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_rowssums(&elapsed_time,mtxAp,transA,row_sums);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_rowssums(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"rowssums",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (rowssums,double) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_float_rowssums(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "float" type implementation of operation "rowssums" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_FLOAT ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	float * row_sums=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			row_sums = rsb__malloc(mtxAp->el_size*(rows+br));
			if(!row_sums) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(row_sums,mtxAp->typecode,cols,1))     {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_float_rowssums( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,transA,row_sums);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(row_sums);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_float_rowssums(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const rsb_trans_t transA,void * row_sums)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "rowssums" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_rowssums(&elapsed_time,mtxAp,transA,row_sums);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_rowssums(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"rowssums",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (rowssums,float) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_float_complex_rowssums(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "float complex" type implementation of operation "rowssums" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	float complex * row_sums=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			row_sums = rsb__malloc(mtxAp->el_size*(rows+br));
			if(!row_sums) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(row_sums,mtxAp->typecode,cols,1))     {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_float_complex_rowssums( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,transA,row_sums);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(row_sums);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_float_complex_rowssums(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const rsb_trans_t transA,void * row_sums)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "rowssums" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_rowssums(&elapsed_time,mtxAp,transA,row_sums);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_rowssums(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"rowssums",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (rowssums,float complex) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_double_complex_rowssums(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "double complex" type implementation of operation "rowssums" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	double complex * row_sums=NULL;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			row_sums = rsb__malloc(mtxAp->el_size*(rows+br));
			if(!row_sums) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(row_sums,mtxAp->typecode,cols,1))     {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_double_complex_rowssums( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,transA,row_sums);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(row_sums);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_double_complex_rowssums(double * total_elapsed_time, double * m_flops, const struct rsb_mtx_t * mtxAp,const rsb_trans_t transA,void * row_sums)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "rowssums" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_rowssums(&elapsed_time,mtxAp,transA,row_sums);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_rowssums(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"rowssums",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (rowssums,double complex) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_double_scale(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "double" type implementation of operation "scale" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_DOUBLE ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			double * scale_factors = NULL;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			scale_factors = rsb__malloc(mtxAp->el_size*(rows+br));
			if(!scale_factors) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(scale_factors,mtxAp->typecode,rows,1))     {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_double_scale( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,transA,scale_factors);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(scale_factors);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_double_scale(double * total_elapsed_time, double * m_flops, struct rsb_mtx_t * mtxAp,const rsb_trans_t transA,const void * scale_factors)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "scale" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_scale(&elapsed_time,mtxAp,transA,scale_factors);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_scale(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"scale",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (scale,double) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_float_scale(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "float" type implementation of operation "scale" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_FLOAT ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			float * scale_factors = NULL;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			scale_factors = rsb__malloc(mtxAp->el_size*(rows+br));
			if(!scale_factors) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(scale_factors,mtxAp->typecode,rows,1))     {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_float_scale( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,transA,scale_factors);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(scale_factors);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_float_scale(double * total_elapsed_time, double * m_flops, struct rsb_mtx_t * mtxAp,const rsb_trans_t transA,const void * scale_factors)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "scale" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_scale(&elapsed_time,mtxAp,transA,scale_factors);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_scale(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"scale",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (scale,float) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_float_complex_scale(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "float complex" type implementation of operation "scale" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			float complex * scale_factors = NULL;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			scale_factors = rsb__malloc(mtxAp->el_size*(rows+br));
			if(!scale_factors) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(scale_factors,mtxAp->typecode,rows,1))     {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_float_complex_scale( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,transA,scale_factors);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(scale_factors);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_float_complex_scale(double * total_elapsed_time, double * m_flops, struct rsb_mtx_t * mtxAp,const rsb_trans_t transA,const void * scale_factors)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "scale" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_scale(&elapsed_time,mtxAp,transA,scale_factors);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_scale(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"scale",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (scale,float complex) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}

rsb_err_t rsb__do_fullrangebenchmark_double_complex_scale(void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags)
/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_FULLRANGEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * Will benchmark the "double complex" type implementation of operation "scale" 
	 * for a single matrix, but for the whole range of different block sizes
	 * partitionings.
         * 
         * Therefore, the VBR features of this library will be NOT used here.
	 *
	 * The performance information will be written in a user supplied structure.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ;
	int ri=0,ci=0;
	rsb_blk_idx_t br=0,bc=0;
	//rsb_blk_idx_t M_b,K_b;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	struct rsb_mtx_t * mtxAp = NULL;
	rsb_trans_t transA = RSB_DEFAULT_TRANSPOSITION;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	rsb_coo_idx_t incx=1,incy=1;
	incx=1,incy=1;	/* just to avoid "unused variable"-like  just to avoid "unused variable"-like warnings warnings */

	if(!VA || !IA || !JA || !mpi)
		return RSB_ERR_BADARGS;

	RSB_BZERO_P(mpi);
	mpi->rows = rows;
	mpi->cols=cols;
	mpi->nnz=nnz;

	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			double complex * scale_factors = NULL;
			br = rua[ri];
			bc = cua[ci];
			mtxAp = rsb__do_mtx_alloc_from_coo_const(VA,IA,JA,nnz,typecode,rows,cols,br,bc,flags,&errval);
			if(!mtxAp||RSB_SOME_ERROR(errval)) {goto erri;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
			{

				/* no need for further benchmarks (FIXME : a temporary, horrible hack! ) */
				ri=ci=-1;
				for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
					for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
						if( rua[ri] == mtxAp->rpntr[1] - mtxAp->rpntr[0] )
							if( cua[ci] == mtxAp->cpntr[1] - mtxAp->cpntr[0] )
								goto ok; /* lol */
				errval = RSB_ERR_INTERNAL_ERROR;
				goto erri;
			}

			ok:
				br = rua[ri];
				bc = cua[ci];
				/* autoblocking found a blocking among the supported ones.
				 * we fill in performance info and quit.
				 */

			scale_factors = rsb__malloc(mtxAp->el_size*(rows+br));
			if(!scale_factors) {errval = RSB_ERR_ENOMEM;goto erri;}
			if(rsb__fill_with_ones(scale_factors,mtxAp->typecode,rows,1))     {errval = RSB_ERR_ENOMEM;goto erri;}
			
			mpi->seconds[ri][ci] = RSB_BENCHMARK_MIN_SECONDS; /* min seconds */
			mpi->m_flops[ri][ci] = (double)RSB_BENCHMARK_MIN_RUNS; /* min runs */

			rsb__do_benchmark_double_complex_scale( &(mpi->seconds[ri][ci]), &(mpi->m_flops[ri][ci]), mtxAp,transA,scale_factors);
			mpi->fillin[ri][ci] = rsb__do_get_matrix_fillin(mtxAp);
			mpi->e_mflops[ri][ci] =	mpi->m_flops[ri][ci] / mpi->fillin[ri][ci] ;/* new */
			erri:
			RSB_CONDITIONAL_FREE(scale_factors);
			RSB_MTX_FREE(mtxAp);
			if(RSB_SOME_ERROR(errval)){rsb__do_perror(NULL,errval);return errval;}

			if( ( flags & RSB_FLAG_AUTO_BLOCKING ) != 0)
				return errval;/* no need for further benchmarks (FIXME : a temporary hack! ) */
		}
	}
	return errval;
}

rsb_err_t rsb__do_benchmark_double_complex_scale(double * total_elapsed_time, double * m_flops, struct rsb_mtx_t * mtxAp,const rsb_trans_t transA,const void * scale_factors)
{
	/*!
	 * \ingroup gr_bench
	 * This wrapper function will benchmark the "scale" operation
	 * a number of times, measuring the elapsed time in seconds
	 * and writing it in a user set location for a specified matrix.
	 *
	 * It will also add  the performed millions of floating point
	 * operation count in another user specified location.
	 *
	 * \param total_elapsed_time if > 0 on input, will benchmark at least total_elapsed_time seconds
	 * \param m_flops if m_flops > 0 on input, will benchmark at least m_flops times
	 *
	 * If neither of the two input arguments will be set on input,
	 * the benchmark will cease after RSB_BENCHMARK_MIN_RUNS runs or RSB_BENCHMARK_MIN_SECONDS seconds.
	 *
	 * Assuming time_limit = *total_elapsed_time :
	 *
	 * if(time_limit <= 0) will benchmark at least min_runs times
	 * if(time_limit >  0) will benchmark at least min_runs times and for time_limit seconds
	 *
	 * \return \rsb_errval_inp_param_msg
         *
	 */

	double time_limit;
	double elapsed_time;
	rsb_err_t errval = RSB_ERR_NO_ERROR;
	int runs=0,min_runs=0;

        if( ! total_elapsed_time || ! m_flops)
		return RSB_ERR_BADARGS;

	time_limit = *total_elapsed_time;	/* we read input (FIXME) */
	min_runs   = (int)*m_flops;			/* we read input (FIXME) */

	*total_elapsed_time = RSB_TIME_ZERO;
	*m_flops = RSB_TIME_ZERO;

	if(time_limit <= 0 )
	{
		time_limit = RSB_BENCHMARK_MIN_SECONDS;
	}

	if(min_runs   <= 0 )
	{
		min_runs = RSB_BENCHMARK_MIN_RUNS ;	/* NOTE : this is a completely arbitrary number (FIXME) */
	}

	//RSB_INFO("will perform min  %d runs, for %lg seconds\n",min_runs, time_limit);

	// FIXME : seems like this affects performance ...
	// *total_elapsed_time = - rsb_time();
	*total_elapsed_time =0;

	while( ( time_limit? ( *total_elapsed_time < time_limit):0 ) || ( min_runs ? ( runs < min_runs ) : 0 ) )
	{
		//elapsed_time = RSB_TIME_ZERO;
		//errval = 		/* FIXME : use an even more general function here (the following is vbr-only!) */
rsb_do_time_scale(&elapsed_time,mtxAp,transA,scale_factors);

		//*total_elapsed_time += rsb_time();
/*		RSB_INFO("tl : %lg\n",time_limit );*/
/*		RSB_INFO("ss : %lg\n",*total_elapsed_time );*/
/*		RSB_INFO("sse : %lg\n",elapsed_time );*/

		*total_elapsed_time  +=  elapsed_time;
		*m_flops += rsb__estimate_mflops_per_op_scale(mtxAp);
		if(RSB_SOME_ERROR(errval)) return errval;
		++runs;
	}
	/* FIXME : get rid of this line */
	{rsb_char_t buf[RSB_MAX_LINE_LENGTH];
	RSB_STDERR("%s : ",rsb__sprint_matrix_implementation_code(mtxAp,"scale",RSB_FLAG_NOFLAGS,buf));}
	RSB_STDERR("performed %d runs, %lg/%lg seconds (scale,double complex) \n",runs, *total_elapsed_time,time_limit);

	/*
         * FIXME : this is a candidate location for a conditional performance data printout
         */

	return RSB_ERR_NO_ERROR;
}


/* Dispatch table for type and scale specific benchmarks (FIXME : NEW) */
 rsb_err_t (* rsb_benchmark_dispatch_table [RSB_IMPLEMENTED_TYPES][RSB_IMPLEMENTED_MOPS]) 
   (void *VA, rsb_coo_idx_t * IA, rsb_coo_idx_t * JA, rsb_nnz_idx_t nnz, rsb_coo_idx_t rows, rsb_coo_idx_t cols, struct rsb_mop_performance_info_t * mpi, rsb_flags_t flags_pointer_table)
 =  { 
{
 rsb__do_fullrangebenchmark_double_spmv_uaua,
 rsb__do_fullrangebenchmark_double_spmv_uauz,
 rsb__do_fullrangebenchmark_double_spmv_uxua,
 rsb__do_fullrangebenchmark_double_spmv_unua,
 rsb__do_fullrangebenchmark_double_spmv_sasa,
 rsb__do_fullrangebenchmark_double_spsv_uxua,
 rsb__do_fullrangebenchmark_double_spmv_sxsa,
 rsb__do_fullrangebenchmark_double_spsv_sxsx,
 rsb__do_fullrangebenchmark_double_infty_norm,
 rsb__do_fullrangebenchmark_double_rowssums,
 rsb__do_fullrangebenchmark_double_scale 
}
,
{
 rsb__do_fullrangebenchmark_float_spmv_uaua,
 rsb__do_fullrangebenchmark_float_spmv_uauz,
 rsb__do_fullrangebenchmark_float_spmv_uxua,
 rsb__do_fullrangebenchmark_float_spmv_unua,
 rsb__do_fullrangebenchmark_float_spmv_sasa,
 rsb__do_fullrangebenchmark_float_spsv_uxua,
 rsb__do_fullrangebenchmark_float_spmv_sxsa,
 rsb__do_fullrangebenchmark_float_spsv_sxsx,
 rsb__do_fullrangebenchmark_float_infty_norm,
 rsb__do_fullrangebenchmark_float_rowssums,
 rsb__do_fullrangebenchmark_float_scale 
}
,
{
 rsb__do_fullrangebenchmark_float_complex_spmv_uaua,
 rsb__do_fullrangebenchmark_float_complex_spmv_uauz,
 rsb__do_fullrangebenchmark_float_complex_spmv_uxua,
 rsb__do_fullrangebenchmark_float_complex_spmv_unua,
 rsb__do_fullrangebenchmark_float_complex_spmv_sasa,
 rsb__do_fullrangebenchmark_float_complex_spsv_uxua,
 rsb__do_fullrangebenchmark_float_complex_spmv_sxsa,
 rsb__do_fullrangebenchmark_float_complex_spsv_sxsx,
 rsb__do_fullrangebenchmark_float_complex_infty_norm,
 rsb__do_fullrangebenchmark_float_complex_rowssums,
 rsb__do_fullrangebenchmark_float_complex_scale 
}
,
{
 rsb__do_fullrangebenchmark_double_complex_spmv_uaua,
 rsb__do_fullrangebenchmark_double_complex_spmv_uauz,
 rsb__do_fullrangebenchmark_double_complex_spmv_uxua,
 rsb__do_fullrangebenchmark_double_complex_spmv_unua,
 rsb__do_fullrangebenchmark_double_complex_spmv_sasa,
 rsb__do_fullrangebenchmark_double_complex_spsv_uxua,
 rsb__do_fullrangebenchmark_double_complex_spmv_sxsa,
 rsb__do_fullrangebenchmark_double_complex_spsv_sxsx,
 rsb__do_fullrangebenchmark_double_complex_infty_norm,
 rsb__do_fullrangebenchmark_double_complex_rowssums,
 rsb__do_fullrangebenchmark_double_complex_scale 
}
 
};

static rsb_err_t rsb_do_completetypebenchmark_double(const char * filename, struct rsb_mops_performance_info_t * mspi)/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_COMPLETETYPEBENCHMARK_FUNCTION macro */
{
        /*!
	 * \ingroup gr_bench
	 * Will benchmark all supported matrix operations over the "double" type.
	 * over all supported matrix partitionings for a fixed block size.
         *
	 * \return \rsb_errval_inp_param_msg
	 */

	rsb_err_t errval = RSB_ERR_NO_ERROR;
	rsb_coo_idx_t * IA=NULL,*JA=NULL;
	rsb_coo_idx_t rows=0,cols=0;
	rsb_nnz_idx_t nnz=0;
	void *VA=NULL;

	struct rsb_mop_performance_info_t * mpi = &(mspi->pipmo[0]);
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_DOUBLE ,flags=0;

	RSB_BZERO(mspi,sizeof(*mspi));

	if((rsb__util_mm_load_matrix_f(filename,&IA,&JA,&VA,&rows,&cols,&nnz,typecode,flags,NULL,NULL))!=0)
	{
		RSB_STDERR(RSB_ERRMSG_NOTMTXMKT" : %s ..\n",filename);
		goto err;
	}
	

	/* we benchmark our double library implementation for operation spmv_uaua */
	errval = rsb__do_fullrangebenchmark_double_spmv_uaua(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our double library implementation for operation spmv_uauz */
	errval = rsb__do_fullrangebenchmark_double_spmv_uauz(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our double library implementation for operation spmv_uxua */
	errval = rsb__do_fullrangebenchmark_double_spmv_uxua(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our double library implementation for operation spmv_unua */
	errval = rsb__do_fullrangebenchmark_double_spmv_unua(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our double library implementation for operation spmv_sasa */
	errval = rsb__do_fullrangebenchmark_double_spmv_sasa(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our double library implementation for operation spsv_uxua */
	errval = rsb__do_fullrangebenchmark_double_spsv_uxua(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our double library implementation for operation spmv_sxsa */
	errval = rsb__do_fullrangebenchmark_double_spmv_sxsa(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our double library implementation for operation spsv_sxsx */
	errval = rsb__do_fullrangebenchmark_double_spsv_sxsx(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our double library implementation for operation infty_norm */
	errval = rsb__do_fullrangebenchmark_double_infty_norm(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our double library implementation for operation rowssums */
	errval = rsb__do_fullrangebenchmark_double_rowssums(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our double library implementation for operation scale */
	errval = rsb__do_fullrangebenchmark_double_scale(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;
	mpi-=11;
	

	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_double_spmv_uaua");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_double_spmv_uauz");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_double_spmv_uxua");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_double_spmv_unua");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_double_spmv_sasa");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_double_spsv_uxua");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_double_spmv_sxsa");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_double_spsv_sxsx");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_double_infty_norm");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_double_rowssums");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_double_scale");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	mpi-=11;

	err:
	RSB_CONDITIONAL_FREE(IA);
	RSB_CONDITIONAL_FREE(JA);
	RSB_CONDITIONAL_FREE(VA);
	return errval;
}


static rsb_err_t rsb_do_completetypebenchmark_float(const char * filename, struct rsb_mops_performance_info_t * mspi)/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_COMPLETETYPEBENCHMARK_FUNCTION macro */
{
        /*!
	 * \ingroup gr_bench
	 * Will benchmark all supported matrix operations over the "float" type.
	 * over all supported matrix partitionings for a fixed block size.
         *
	 * \return \rsb_errval_inp_param_msg
	 */

	rsb_err_t errval = RSB_ERR_NO_ERROR;
	rsb_coo_idx_t * IA=NULL,*JA=NULL;
	rsb_coo_idx_t rows=0,cols=0;
	rsb_nnz_idx_t nnz=0;
	void *VA=NULL;

	struct rsb_mop_performance_info_t * mpi = &(mspi->pipmo[0]);
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_FLOAT ,flags=0;

	RSB_BZERO(mspi,sizeof(*mspi));

	if((rsb__util_mm_load_matrix_f(filename,&IA,&JA,&VA,&rows,&cols,&nnz,typecode,flags,NULL,NULL))!=0)
	{
		RSB_STDERR(RSB_ERRMSG_NOTMTXMKT" : %s ..\n",filename);
		goto err;
	}
	

	/* we benchmark our float library implementation for operation spmv_uaua */
	errval = rsb__do_fullrangebenchmark_float_spmv_uaua(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our float library implementation for operation spmv_uauz */
	errval = rsb__do_fullrangebenchmark_float_spmv_uauz(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our float library implementation for operation spmv_uxua */
	errval = rsb__do_fullrangebenchmark_float_spmv_uxua(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our float library implementation for operation spmv_unua */
	errval = rsb__do_fullrangebenchmark_float_spmv_unua(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our float library implementation for operation spmv_sasa */
	errval = rsb__do_fullrangebenchmark_float_spmv_sasa(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our float library implementation for operation spsv_uxua */
	errval = rsb__do_fullrangebenchmark_float_spsv_uxua(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our float library implementation for operation spmv_sxsa */
	errval = rsb__do_fullrangebenchmark_float_spmv_sxsa(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our float library implementation for operation spsv_sxsx */
	errval = rsb__do_fullrangebenchmark_float_spsv_sxsx(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our float library implementation for operation infty_norm */
	errval = rsb__do_fullrangebenchmark_float_infty_norm(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our float library implementation for operation rowssums */
	errval = rsb__do_fullrangebenchmark_float_rowssums(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our float library implementation for operation scale */
	errval = rsb__do_fullrangebenchmark_float_scale(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;
	mpi-=11;
	

	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_float_spmv_uaua");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_float_spmv_uauz");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_float_spmv_uxua");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_float_spmv_unua");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_float_spmv_sasa");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_float_spsv_uxua");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_float_spmv_sxsa");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_float_spsv_sxsx");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_float_infty_norm");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_float_rowssums");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_float_scale");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	mpi-=11;

	err:
	RSB_CONDITIONAL_FREE(IA);
	RSB_CONDITIONAL_FREE(JA);
	RSB_CONDITIONAL_FREE(VA);
	return errval;
}


static rsb_err_t rsb_do_completetypebenchmark_float_complex(const char * filename, struct rsb_mops_performance_info_t * mspi)/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_COMPLETETYPEBENCHMARK_FUNCTION macro */
{
        /*!
	 * \ingroup gr_bench
	 * Will benchmark all supported matrix operations over the "float complex" type.
	 * over all supported matrix partitionings for a fixed block size.
         *
	 * \return \rsb_errval_inp_param_msg
	 */

	rsb_err_t errval = RSB_ERR_NO_ERROR;
	rsb_coo_idx_t * IA=NULL,*JA=NULL;
	rsb_coo_idx_t rows=0,cols=0;
	rsb_nnz_idx_t nnz=0;
	void *VA=NULL;

	struct rsb_mop_performance_info_t * mpi = &(mspi->pipmo[0]);
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_FLOAT_COMPLEX ,flags=0;

	RSB_BZERO(mspi,sizeof(*mspi));

	if((rsb__util_mm_load_matrix_f(filename,&IA,&JA,&VA,&rows,&cols,&nnz,typecode,flags,NULL,NULL))!=0)
	{
		RSB_STDERR(RSB_ERRMSG_NOTMTXMKT" : %s ..\n",filename);
		goto err;
	}
	

	/* we benchmark our float complex library implementation for operation spmv_uaua */
	errval = rsb__do_fullrangebenchmark_float_complex_spmv_uaua(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our float complex library implementation for operation spmv_uauz */
	errval = rsb__do_fullrangebenchmark_float_complex_spmv_uauz(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our float complex library implementation for operation spmv_uxua */
	errval = rsb__do_fullrangebenchmark_float_complex_spmv_uxua(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our float complex library implementation for operation spmv_unua */
	errval = rsb__do_fullrangebenchmark_float_complex_spmv_unua(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our float complex library implementation for operation spmv_sasa */
	errval = rsb__do_fullrangebenchmark_float_complex_spmv_sasa(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our float complex library implementation for operation spsv_uxua */
	errval = rsb__do_fullrangebenchmark_float_complex_spsv_uxua(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our float complex library implementation for operation spmv_sxsa */
	errval = rsb__do_fullrangebenchmark_float_complex_spmv_sxsa(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our float complex library implementation for operation spsv_sxsx */
	errval = rsb__do_fullrangebenchmark_float_complex_spsv_sxsx(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our float complex library implementation for operation infty_norm */
	errval = rsb__do_fullrangebenchmark_float_complex_infty_norm(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our float complex library implementation for operation rowssums */
	errval = rsb__do_fullrangebenchmark_float_complex_rowssums(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our float complex library implementation for operation scale */
	errval = rsb__do_fullrangebenchmark_float_complex_scale(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;
	mpi-=11;
	

	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_float_complex_spmv_uaua");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_float_complex_spmv_uauz");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_float_complex_spmv_uxua");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_float_complex_spmv_unua");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_float_complex_spmv_sasa");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_float_complex_spsv_uxua");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_float_complex_spmv_sxsa");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_float_complex_spsv_sxsx");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_float_complex_infty_norm");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_float_complex_rowssums");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_float_complex_scale");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	mpi-=11;

	err:
	RSB_CONDITIONAL_FREE(IA);
	RSB_CONDITIONAL_FREE(JA);
	RSB_CONDITIONAL_FREE(VA);
	return errval;
}


static rsb_err_t rsb_do_completetypebenchmark_double_complex(const char * filename, struct rsb_mops_performance_info_t * mspi)/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_COMPLETETYPEBENCHMARK_FUNCTION macro */
{
        /*!
	 * \ingroup gr_bench
	 * Will benchmark all supported matrix operations over the "double complex" type.
	 * over all supported matrix partitionings for a fixed block size.
         *
	 * \return \rsb_errval_inp_param_msg
	 */

	rsb_err_t errval = RSB_ERR_NO_ERROR;
	rsb_coo_idx_t * IA=NULL,*JA=NULL;
	rsb_coo_idx_t rows=0,cols=0;
	rsb_nnz_idx_t nnz=0;
	void *VA=NULL;

	struct rsb_mop_performance_info_t * mpi = &(mspi->pipmo[0]);
	rsb_flags_t typecode = RSB_NUMERICAL_TYPE_DOUBLE_COMPLEX ,flags=0;

	RSB_BZERO(mspi,sizeof(*mspi));

	if((rsb__util_mm_load_matrix_f(filename,&IA,&JA,&VA,&rows,&cols,&nnz,typecode,flags,NULL,NULL))!=0)
	{
		RSB_STDERR(RSB_ERRMSG_NOTMTXMKT" : %s ..\n",filename);
		goto err;
	}
	

	/* we benchmark our double complex library implementation for operation spmv_uaua */
	errval = rsb__do_fullrangebenchmark_double_complex_spmv_uaua(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our double complex library implementation for operation spmv_uauz */
	errval = rsb__do_fullrangebenchmark_double_complex_spmv_uauz(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our double complex library implementation for operation spmv_uxua */
	errval = rsb__do_fullrangebenchmark_double_complex_spmv_uxua(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our double complex library implementation for operation spmv_unua */
	errval = rsb__do_fullrangebenchmark_double_complex_spmv_unua(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our double complex library implementation for operation spmv_sasa */
	errval = rsb__do_fullrangebenchmark_double_complex_spmv_sasa(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our double complex library implementation for operation spsv_uxua */
	errval = rsb__do_fullrangebenchmark_double_complex_spsv_uxua(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our double complex library implementation for operation spmv_sxsa */
	errval = rsb__do_fullrangebenchmark_double_complex_spmv_sxsa(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our double complex library implementation for operation spsv_sxsx */
	errval = rsb__do_fullrangebenchmark_double_complex_spsv_sxsx(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our double complex library implementation for operation infty_norm */
	errval = rsb__do_fullrangebenchmark_double_complex_infty_norm(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our double complex library implementation for operation rowssums */
	errval = rsb__do_fullrangebenchmark_double_complex_rowssums(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;

	/* we benchmark our double complex library implementation for operation scale */
	errval = rsb__do_fullrangebenchmark_double_complex_scale(VA,IA,JA,nnz,rows,cols,mpi,flags);
	++mpi;
	if(RSB_SOME_ERROR(errval))goto err;
	mpi-=11;
	

	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_double_complex_spmv_uaua");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_double_complex_spmv_uauz");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_double_complex_spmv_uxua");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_double_complex_spmv_unua");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_double_complex_spmv_sasa");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_double_complex_spsv_uxua");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_double_complex_spmv_sxsa");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_double_complex_spsv_sxsx");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_double_complex_infty_norm");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_double_complex_rowssums");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	/* FIXME : WE SHOULD DUMP OUT PERFORMANCE INFORMATION HERE ! */
	errval = rsb__dump_performance_info(mpi,"pi_double_complex_scale");
	if(RSB_SOME_ERROR(errval))goto err;
	++mpi;
	mpi-=11;

	err:
	RSB_CONDITIONAL_FREE(IA);
	RSB_CONDITIONAL_FREE(JA);
	RSB_CONDITIONAL_FREE(VA);
	return errval;
}

#if 0
rsb_err_t rsb__do_spmv_uaua_with_macros_vbr(const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
{
/* generated by the RSB_M4_MULTI_BLOCK_KERNEL_TYPE_DISPATCH_FUNCTION macro */
	/*!
	 * \ingroup rsb_doc_kernels
	 * Kernel function dispatching will be performed inline, after type dispatching, in a separate function.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	return RSB_ERR_UNSUPPORTED_TYPE	;
}

#endif /* 0 */
#pragma GCC visibility push(default)
double rsb__estimate_mflops_per_op_spmv_uaua(const struct rsb_mtx_t * mtxAp)
/* generated by the RSB_M4_ESTIMATE_MFLOPS_PER_MOP_FUNCTION macro */
{
	/*!
	 * \ingroup gr_internals
	 * Return the canonical count of floating point operations
	 * needed to perform the "spmv_uaua" matrix operation.
	 * In the case of a complex type, the number of operations is increased by six:
	 *  (a +bi)*(c+di) = (ac-bd)+(ad+bc)i
	 * accounting for an extra of four real multiplications and two real additions.
	 * In the case of symmetric/hermitian, this is further multiplied by two.
	 * Note that this count is very rough: e.g. ignores diagonal implicit or diagonal with symmetry.
	 */

	const double M_  = 1000000.0;
	const double Ec = ((double)mtxAp->element_count);
	double Me = Ec;
	if(RSB_IS_MATRIX_TYPE_COMPLEX(mtxAp->typecode)) { Me=8*Ec; } else { Me=2*Ec; }
	if(rsb__is_not_unsymmetric(mtxAp)){ Me*=2; }
	Me /= M_;
	return Me;
}

#if 0
rsb_err_t rsb__do_spmv_uauz_with_macros_vbr(const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
{
/* generated by the RSB_M4_MULTI_BLOCK_KERNEL_TYPE_DISPATCH_FUNCTION macro */
	/*!
	 * \ingroup rsb_doc_kernels
	 * Kernel function dispatching will be performed inline, after type dispatching, in a separate function.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	return RSB_ERR_UNSUPPORTED_TYPE	;
}

#endif /* 0 */
#pragma GCC visibility push(default)
double rsb__estimate_mflops_per_op_spmv_uauz(const struct rsb_mtx_t * mtxAp)
/* generated by the RSB_M4_ESTIMATE_MFLOPS_PER_MOP_FUNCTION macro */
{
	/*!
	 * \ingroup gr_internals
	 * Return the canonical count of floating point operations
	 * needed to perform the "spmv_uauz" matrix operation.
	 * In the case of a complex type, the number of operations is increased by six:
	 *  (a +bi)*(c+di) = (ac-bd)+(ad+bc)i
	 * accounting for an extra of four real multiplications and two real additions.
	 * In the case of symmetric/hermitian, this is further multiplied by two.
	 * Note that this count is very rough: e.g. ignores diagonal implicit or diagonal with symmetry.
	 */

	const double M_  = 1000000.0;
	const double Ec = ((double)mtxAp->element_count);
	double Me = Ec;
	if(RSB_IS_MATRIX_TYPE_COMPLEX(mtxAp->typecode)) { Me=8*Ec; } else { Me=2*Ec; }
	if(rsb__is_not_unsymmetric(mtxAp)){ Me*=2; }
	Me /= M_;
	return Me;
}

#if 0
rsb_err_t rsb__do_spmv_uxua_with_macros_vbr(const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const void * alphap,const rsb_trans_t transA)
{
/* generated by the RSB_M4_MULTI_BLOCK_KERNEL_TYPE_DISPATCH_FUNCTION macro */
	/*!
	 * \ingroup rsb_doc_kernels
	 * Kernel function dispatching will be performed inline, after type dispatching, in a separate function.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	return RSB_ERR_UNSUPPORTED_TYPE	;
}

#endif /* 0 */
#pragma GCC visibility push(default)
double rsb__estimate_mflops_per_op_spmv_uxua(const struct rsb_mtx_t * mtxAp)
/* generated by the RSB_M4_ESTIMATE_MFLOPS_PER_MOP_FUNCTION macro */
{
	/*!
	 * \ingroup gr_internals
	 * Return the canonical count of floating point operations
	 * needed to perform the "spmv_uxua" matrix operation.
	 * In the case of a complex type, the number of operations is increased by six:
	 *  (a +bi)*(c+di) = (ac-bd)+(ad+bc)i
	 * accounting for an extra of four real multiplications and two real additions.
	 * In the case of symmetric/hermitian, this is further multiplied by two.
	 * Note that this count is very rough: e.g. ignores diagonal implicit or diagonal with symmetry.
	 */

	const double M_  = 1000000.0;
	const double Ec = ((double)mtxAp->element_count);
	double Me = Ec;
	if(RSB_IS_MATRIX_TYPE_COMPLEX(mtxAp->typecode)) { Me=8*Ec; } else { Me=2*Ec; }
	if(rsb__is_not_unsymmetric(mtxAp)){ Me*=2; }
	Me /= M_;
	return Me;
}

#if 0
rsb_err_t rsb__do_spmv_unua_with_macros_vbr(const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
{
/* generated by the RSB_M4_MULTI_BLOCK_KERNEL_TYPE_DISPATCH_FUNCTION macro */
	/*!
	 * \ingroup rsb_doc_kernels
	 * Kernel function dispatching will be performed inline, after type dispatching, in a separate function.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	return RSB_ERR_UNSUPPORTED_TYPE	;
}

#endif /* 0 */
#pragma GCC visibility push(default)
double rsb__estimate_mflops_per_op_spmv_unua(const struct rsb_mtx_t * mtxAp)
/* generated by the RSB_M4_ESTIMATE_MFLOPS_PER_MOP_FUNCTION macro */
{
	/*!
	 * \ingroup gr_internals
	 * Return the canonical count of floating point operations
	 * needed to perform the "spmv_unua" matrix operation.
	 * In the case of a complex type, the number of operations is increased by six:
	 *  (a +bi)*(c+di) = (ac-bd)+(ad+bc)i
	 * accounting for an extra of four real multiplications and two real additions.
	 * In the case of symmetric/hermitian, this is further multiplied by two.
	 * Note that this count is very rough: e.g. ignores diagonal implicit or diagonal with symmetry.
	 */

	const double M_  = 1000000.0;
	const double Ec = ((double)mtxAp->element_count);
	double Me = Ec;
	if(RSB_IS_MATRIX_TYPE_COMPLEX(mtxAp->typecode)) { Me=8*Ec; } else { Me=2*Ec; }
	if(rsb__is_not_unsymmetric(mtxAp)){ Me*=2; }
	Me /= M_;
	return Me;
}

#if 0
rsb_err_t rsb__do_spmv_sasa_with_macros_vbr(const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,rsb_coo_idx_t incx, rsb_coo_idx_t incy,const rsb_trans_t transA)
{
/* generated by the RSB_M4_MULTI_BLOCK_KERNEL_TYPE_DISPATCH_FUNCTION macro */
	/*!
	 * \ingroup rsb_doc_kernels
	 * Kernel function dispatching will be performed inline, after type dispatching, in a separate function.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	return RSB_ERR_UNSUPPORTED_TYPE	;
}

#endif /* 0 */
#pragma GCC visibility push(default)
double rsb__estimate_mflops_per_op_spmv_sasa(const struct rsb_mtx_t * mtxAp)
/* generated by the RSB_M4_ESTIMATE_MFLOPS_PER_MOP_FUNCTION macro */
{
	/*!
	 * \ingroup gr_internals
	 * Return the canonical count of floating point operations
	 * needed to perform the "spmv_sasa" matrix operation.
	 * In the case of a complex type, the number of operations is increased by six:
	 *  (a +bi)*(c+di) = (ac-bd)+(ad+bc)i
	 * accounting for an extra of four real multiplications and two real additions.
	 * In the case of symmetric/hermitian, this is further multiplied by two.
	 * Note that this count is very rough: e.g. ignores diagonal implicit or diagonal with symmetry.
	 */

	const double M_  = 1000000.0;
	const double Ec = ((double)mtxAp->element_count);
	double Me = Ec;
	if(RSB_IS_MATRIX_TYPE_COMPLEX(mtxAp->typecode)) { Me=8*Ec; } else { Me=2*Ec; }
	if(rsb__is_not_unsymmetric(mtxAp)){ Me*=2; }
	Me /= M_;
	return Me;
}

#if 0
rsb_err_t rsb__do_spsv_uxua_with_macros_vbr(const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const rsb_trans_t transA)
{
/* generated by the RSB_M4_MULTI_BLOCK_KERNEL_TYPE_DISPATCH_FUNCTION macro */
	/*!
	 * \ingroup rsb_doc_kernels
	 * Kernel function dispatching will be performed inline, after type dispatching, in a separate function.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	return RSB_ERR_UNSUPPORTED_TYPE	;
}

#endif /* 0 */
#pragma GCC visibility push(default)
double rsb__estimate_mflops_per_op_spsv_uxua(const struct rsb_mtx_t * mtxAp)
/* generated by the RSB_M4_ESTIMATE_MFLOPS_PER_MOP_FUNCTION macro */
{
	/*!
	 * \ingroup gr_internals
	 * Return the canonical count of floating point operations
	 * needed to perform the "spsv_uxua" matrix operation.
	 * In the case of a complex type, the number of operations is increased by six:
	 *  (a +bi)*(c+di) = (ac-bd)+(ad+bc)i
	 * accounting for an extra of four real multiplications and two real additions.
	 * In the case of symmetric/hermitian, this is further multiplied by two.
	 * Note that this count is very rough: e.g. ignores diagonal implicit or diagonal with symmetry.
	 */

	const double M_  = 1000000.0;
	const double Ec = ((double)mtxAp->element_count);
	double Me = Ec;
	if(RSB_IS_MATRIX_TYPE_COMPLEX(mtxAp->typecode)) { Me=8*Ec; } else { Me=2*Ec; }
	Me /= M_;
	return Me;
}

#if 0
rsb_err_t rsb__do_spmv_sxsa_with_macros_vbr(const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const void * alphap,rsb_coo_idx_t incx, rsb_coo_idx_t incy,const rsb_trans_t transA)
{
/* generated by the RSB_M4_MULTI_BLOCK_KERNEL_TYPE_DISPATCH_FUNCTION macro */
	/*!
	 * \ingroup rsb_doc_kernels
	 * Kernel function dispatching will be performed inline, after type dispatching, in a separate function.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	return RSB_ERR_UNSUPPORTED_TYPE	;
}

#endif /* 0 */
#pragma GCC visibility push(default)
double rsb__estimate_mflops_per_op_spmv_sxsa(const struct rsb_mtx_t * mtxAp)
/* generated by the RSB_M4_ESTIMATE_MFLOPS_PER_MOP_FUNCTION macro */
{
	/*!
	 * \ingroup gr_internals
	 * Return the canonical count of floating point operations
	 * needed to perform the "spmv_sxsa" matrix operation.
	 * In the case of a complex type, the number of operations is increased by six:
	 *  (a +bi)*(c+di) = (ac-bd)+(ad+bc)i
	 * accounting for an extra of four real multiplications and two real additions.
	 * In the case of symmetric/hermitian, this is further multiplied by two.
	 * Note that this count is very rough: e.g. ignores diagonal implicit or diagonal with symmetry.
	 */

	const double M_  = 1000000.0;
	const double Ec = ((double)mtxAp->element_count);
	double Me = Ec;
	if(RSB_IS_MATRIX_TYPE_COMPLEX(mtxAp->typecode)) { Me=8*Ec; } else { Me=2*Ec; }
	if(rsb__is_not_unsymmetric(mtxAp)){ Me*=2; }
	Me /= M_;
	return Me;
}

#if 0
rsb_err_t rsb__do_spsv_sxsx_with_macros_vbr(const struct rsb_mtx_t * mtxAp,const void * restrict rhs, void * restrict out,const void * alphap,rsb_coo_idx_t incx, rsb_coo_idx_t incy,const rsb_trans_t transA)
{
/* generated by the RSB_M4_MULTI_BLOCK_KERNEL_TYPE_DISPATCH_FUNCTION macro */
	/*!
	 * \ingroup rsb_doc_kernels
	 * Kernel function dispatching will be performed inline, after type dispatching, in a separate function.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	return RSB_ERR_UNSUPPORTED_TYPE	;
}

#endif /* 0 */
#pragma GCC visibility push(default)
double rsb__estimate_mflops_per_op_spsv_sxsx(const struct rsb_mtx_t * mtxAp)
/* generated by the RSB_M4_ESTIMATE_MFLOPS_PER_MOP_FUNCTION macro */
{
	/*!
	 * \ingroup gr_internals
	 * Return the canonical count of floating point operations
	 * needed to perform the "spsv_sxsx" matrix operation.
	 * In the case of a complex type, the number of operations is increased by six:
	 *  (a +bi)*(c+di) = (ac-bd)+(ad+bc)i
	 * accounting for an extra of four real multiplications and two real additions.
	 * In the case of symmetric/hermitian, this is further multiplied by two.
	 * Note that this count is very rough: e.g. ignores diagonal implicit or diagonal with symmetry.
	 */

	const double M_  = 1000000.0;
	const double Ec = ((double)mtxAp->element_count);
	double Me = Ec;
	if(RSB_IS_MATRIX_TYPE_COMPLEX(mtxAp->typecode)) { Me=8*Ec; } else { Me=2*Ec; }
	Me /= M_;
	return Me;
}

#if 0
rsb_err_t rsb__do_infty_norm_with_macros_vbr(const struct rsb_mtx_t * mtxAp,const rsb_trans_t transA,void * row_sums)
{
/* generated by the RSB_M4_MULTI_BLOCK_KERNEL_TYPE_DISPATCH_FUNCTION macro */
	/*!
	 * \ingroup rsb_doc_kernels
	 * Kernel function dispatching will be performed inline, after type dispatching, in a separate function.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	return RSB_ERR_UNSUPPORTED_TYPE	;
}

#endif /* 0 */
#pragma GCC visibility push(default)
double rsb__estimate_mflops_per_op_infty_norm(const struct rsb_mtx_t * mtxAp)
/* generated by the RSB_M4_ESTIMATE_MFLOPS_PER_MOP_FUNCTION macro */
{
	/*!
	 * \ingroup gr_internals
	 * Return the canonical count of floating point operations
	 * needed to perform the "infty_norm" matrix operation.
	 * In the case of a complex type, the number of operations is increased by six:
	 *  (a +bi)*(c+di) = (ac-bd)+(ad+bc)i
	 * accounting for an extra of four real multiplications and two real additions.
	 * In the case of symmetric/hermitian, this is further multiplied by two.
	 * Note that this count is very rough: e.g. ignores diagonal implicit or diagonal with symmetry.
	 */

	const double M_  = 1000000.0;
	const double Ec = ((double)mtxAp->element_count);
	double Me = Ec;
	Me /= M_;
	return Me;
}

#if 0
rsb_err_t rsb__do_rowssums_with_macros_vbr(const struct rsb_mtx_t * mtxAp,const rsb_trans_t transA,void * row_sums)
{
/* generated by the RSB_M4_MULTI_BLOCK_KERNEL_TYPE_DISPATCH_FUNCTION macro */
	/*!
	 * \ingroup rsb_doc_kernels
	 * Kernel function dispatching will be performed inline, after type dispatching, in a separate function.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	return RSB_ERR_UNSUPPORTED_TYPE	;
}

#endif /* 0 */
#pragma GCC visibility push(default)
double rsb__estimate_mflops_per_op_rowssums(const struct rsb_mtx_t * mtxAp)
/* generated by the RSB_M4_ESTIMATE_MFLOPS_PER_MOP_FUNCTION macro */
{
	/*!
	 * \ingroup gr_internals
	 * Return the canonical count of floating point operations
	 * needed to perform the "rowssums" matrix operation.
	 * In the case of a complex type, the number of operations is increased by six:
	 *  (a +bi)*(c+di) = (ac-bd)+(ad+bc)i
	 * accounting for an extra of four real multiplications and two real additions.
	 * In the case of symmetric/hermitian, this is further multiplied by two.
	 * Note that this count is very rough: e.g. ignores diagonal implicit or diagonal with symmetry.
	 */

	const double M_  = 1000000.0;
	const double Ec = ((double)mtxAp->element_count);
	double Me = Ec;
	Me /= M_;
	return Me;
}

#if 0
rsb_err_t rsb__do_scale_with_macros_vbr(struct rsb_mtx_t * mtxAp,const rsb_trans_t transA,const void * scale_factors)
{
/* generated by the RSB_M4_MULTI_BLOCK_KERNEL_TYPE_DISPATCH_FUNCTION macro */
	/*!
	 * \ingroup rsb_doc_kernels
	 * Kernel function dispatching will be performed inline, after type dispatching, in a separate function.
         *
	 * \return \rsb_errval_inp_param_msg
	 */
	return RSB_ERR_UNSUPPORTED_TYPE	;
}

#endif /* 0 */
#pragma GCC visibility push(default)
double rsb__estimate_mflops_per_op_scale(const struct rsb_mtx_t * mtxAp)
/* generated by the RSB_M4_ESTIMATE_MFLOPS_PER_MOP_FUNCTION macro */
{
	/*!
	 * \ingroup gr_internals
	 * Return the canonical count of floating point operations
	 * needed to perform the "scale" matrix operation.
	 * In the case of a complex type, the number of operations is increased by six:
	 *  (a +bi)*(c+di) = (ac-bd)+(ad+bc)i
	 * accounting for an extra of four real multiplications and two real additions.
	 * In the case of symmetric/hermitian, this is further multiplied by two.
	 * Note that this count is very rough: e.g. ignores diagonal implicit or diagonal with symmetry.
	 */

	const double M_  = 1000000.0;
	const double Ec = ((double)mtxAp->element_count);
	double Me = Ec;
	Me /= M_;
	return Me;
}


rsb_err_t rsb_do_completebenchmark(const int argc, char *const argv[])/* generated by the RSB_M4_DIRECT_KERNEL_DISPATCH_COMPLETEBENCHMARK_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * A complete benchmark program.
	 * Will benchmark all supported matrix operations over all supported (double,float,float complex,double complex)
	 * over all supported matrix partitionings for a fixed block size.
         *
	 * \return \rsb_errval_inp_param_msg
         *
	 * FIXME : UNFINISHED: should process and dump this info in a header file.
	 */
	struct rsb_global_performance_info_t mspis;
	struct rsb_mops_performance_info_t * mspi = &(mspis.gpi[0]);

	rsb_option options[] = {
	    {"matrix-filename",	required_argument, NULL, 0x66},  /* f */
	    {0,0,0,0}
	};
	const char * filename=NULL;
	int c=0;
	int opt_index=0;
	rsb_err_t errval = RSB_ERR_NO_ERROR;

	if(rsb_lib_init(RSB_NULL_INIT_OPTIONS))goto err;

	for (;;)
	{
		c = rsb_getopt_long(argc, argv, "f:" , options, &opt_index);/* Flawfinder: ignore */
		if (c == -1)break;
		switch (c)
		{
			case 0x66:/* f */
			filename = optarg;
			break;
	    	}
	}


	errval=rsb_do_completetypebenchmark_double(filename,mspi);
	if(RSB_SOME_ERROR(errval)) return errval;
	++mspi;

	errval=rsb_do_completetypebenchmark_float(filename,mspi);
	if(RSB_SOME_ERROR(errval)) return errval;
	++mspi;

	errval=rsb_do_completetypebenchmark_float_complex(filename,mspi);
	if(RSB_SOME_ERROR(errval)) return errval;
	++mspi;

	errval=rsb_do_completetypebenchmark_double_complex(filename,mspi);
	if(RSB_SOME_ERROR(errval)) return errval;
	++mspi;

	if( rsb_lib_exit(RSB_NULL_EXIT_OPTIONS) )
		return RSB_ERR_INTERNAL_ERROR;
	return RSB_ERR_NO_ERROR;
	err:
	return RSB_ERR_INTERNAL_ERROR;
}
rsb_err_t rsb__dump_performance_array(const char * an, const double*array)
/* generated by the RSB_M4_DUMP_PERFORMANCE_INFO_ARRAY_FUNCTION macro */
{
	/*!
	 * \ingroup gr_bench
	 * A benchmark info dumping function.
         *
	 * \return \rsb_errval_inp_param_msg
         *
	 * FIXME : UNFINISHED
	 */
#if RSB_ALLOW_STDOUT
	int ri,ci;
	rsb_blk_idx_t rua[]=RSB_ROWS_UNROLL_ARRAY;
	rsb_blk_idx_t cua[]=RSB_COLUMNS_UNROLL_ARRAY;
	if(!array || !an)
		return RSB_ERR_BADARGS;

/*	RSB_STDOUT("const double %s [RSB_ROWS_UNROLL_ARRAY_LENGTH][RSB_COLUMNS_UNROLL_ARRAY_LENGTH] = \n",an);*/
	RSB_STDOUT(".%s = \n",an);
	RSB_STDOUT("{");
	RSB_STDOUT("\t/*");
	for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci) RSB_STDOUT("%d, ",cua[ci]);
	RSB_STDOUT("columns per block */\n");
		
	for(ri=0;ri<RSB_ROWS_UNROLL_ARRAY_LENGTH;++ri)
	{
		RSB_STDOUT("\t{");
		for(ci=0;ci<RSB_COLUMNS_UNROLL_ARRAY_LENGTH;++ci)
		{
			if(ci)RSB_STDOUT(",");
			RSB_STDOUT(" %lg",array[ri*RSB_ROWS_UNROLL_ARRAY_LENGTH+ci]);
		}
		RSB_STDOUT(" }, /* %d rows per block */\n",rua[ri]);
	}
	RSB_STDOUT("},\n");
	return RSB_ERR_NO_ERROR;
#else /* RSB_ALLOW_STDOUT */
	return RSB_ERR_UNSUPPORTED_FEATURE;
#endif /* RSB_ALLOW_STDOUT */
}

#ifdef __cplusplus
}
#endif  /* __cplusplus */





/*!
 @file
 @brief ...
 */
/* @endcond */
